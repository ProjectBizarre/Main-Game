"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransformState = void 0;
var typescript_1 = __importDefault(require("typescript"));
var fs_1 = __importDefault(require("fs"));
var crypto_1 = __importDefault(require("crypto"));
var path_1 = __importDefault(require("path"));
var transformNode_1 = require("../transformations/transformNode");
var pathTranslator_1 = require("./rojoResolver/pathTranslator");
var rojoResolver_1 = require("./rojoResolver/rojoResolver");
var cache_1 = require("../util/cache");
var getPackageJson_1 = require("../util/functions/getPackageJson");
var buildInfo_1 = require("./buildInfo");
var logger_1 = require("./logger");
var assert_1 = require("./rojoResolver/util/assert");
var symbolProvider_1 = require("./symbolProvider");
var factory_1 = require("../util/factory");
var isPathDescendantOf_1 = require("../util/functions/isPathDescendantOf");
var getDeclarationName_1 = require("../util/functions/getDeclarationName");
var hashids_1 = __importDefault(require("hashids"));
var callMacros_1 = require("../transformations/macros/call/callMacros");
var isCleanBuildDirectory_1 = require("../util/functions/isCleanBuildDirectory");
var parseCommandLine_1 = require("../util/functions/parseCommandLine");
var IGNORE_RBXTS_REGEX = /node_modules\/@rbxts\/(compiler-types|types)\/.*\.d\.ts$/;
var TransformState = /** @class */ (function () {
    function TransformState(program, context, config) {
        var _a, _b, _c;
        this.program = program;
        this.context = context;
        this.config = config;
        this.parsedCommandLine = parseCommandLine_1.parseCommandLine();
        this.currentDirectory = this.parsedCommandLine.project;
        this.options = this.program.getCompilerOptions();
        this.srcDir = (_a = this.options.rootDir) !== null && _a !== void 0 ? _a : this.currentDirectory;
        this.outDir = (_b = this.options.outDir) !== null && _b !== void 0 ? _b : this.currentDirectory;
        this.typeChecker = this.program.getTypeChecker();
        this.symbolProvider = new symbolProvider_1.SymbolProvider(this);
        this.classes = new Map();
        this.callMacros = new Map();
        this.areMacrosSetup = false;
        this.fileImports = new Map();
        this.hasErrors = false;
        this.prereqStack = new Array();
        if (((_c = config.hashPrefix) === null || _c === void 0 ? void 0 : _c.startsWith("$")) && !config.$rbxpackmode$) {
            throw new Error("The hashPrefix $ is used internally by Flamework");
        }
        this.setupRojo();
        this.setupBuildInfo();
        this.buildInfo.setIdentifierPrefix(config.hashPrefix);
        var packageJson = getPackageJson_1.getPackageJson(this.currentDirectory).result;
        assert_1.assert(packageJson.name);
        this.packageName = packageJson.name;
        this.isGame = !this.packageName.startsWith("@");
        cache_1.Cache.isInitialCompile = false;
    }
    TransformState.prototype.setupBuildInfo = function () {
        var e_1, _a, e_2, _b;
        var _c;
        var baseBuildInfo = buildInfo_1.BuildInfo.fromDirectory(this.currentDirectory);
        if (!baseBuildInfo || (cache_1.Cache.isInitialCompile && isCleanBuildDirectory_1.isCleanBuildDirectory(this.options))) {
            if (this.options.incremental && this.options.tsBuildInfoFile) {
                if (typescript_1.default.sys.fileExists(this.options.tsBuildInfoFile)) {
                    throw new Error("Flamework cannot be built in a dirty environment, please delete your tsbuildinfo");
                }
            }
            baseBuildInfo = new buildInfo_1.BuildInfo(path_1.default.join(this.currentDirectory, "flamework.build"));
        }
        this.buildInfo = baseBuildInfo;
        var candidates = (_c = cache_1.Cache.buildInfoCandidates) !== null && _c !== void 0 ? _c : [];
        if (!cache_1.Cache.buildInfoCandidates) {
            cache_1.Cache.buildInfoCandidates = candidates;
            var candidatesSet = new Set();
            try {
                for (var _d = __values(this.program.getSourceFiles()), _e = _d.next(); !_e.done; _e = _d.next()) {
                    var file = _e.value;
                    var buildCandidate = buildInfo_1.BuildInfo.findCandidateUpper(path_1.default.dirname(file.fileName));
                    if (buildCandidate &&
                        buildCandidate !== baseBuildInfo.buildInfoPath &&
                        !candidatesSet.has(buildCandidate)) {
                        candidatesSet.add(buildCandidate);
                        candidates.push(buildCandidate);
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        try {
            for (var candidates_1 = __values(candidates), candidates_1_1 = candidates_1.next(); !candidates_1_1.done; candidates_1_1 = candidates_1.next()) {
                var candidate = candidates_1_1.value;
                var relativeCandidate = path_1.default.relative(this.currentDirectory, candidate);
                var buildInfo = buildInfo_1.BuildInfo.fromPath(candidate);
                if (buildInfo) {
                    logger_1.Logger.infoIfVerbose("Loaded buildInfo at " + relativeCandidate + ", next id: " + buildInfo.getLatestId());
                    baseBuildInfo.addBuildInfo(buildInfo);
                }
                else {
                    logger_1.Logger.warn("Build info not valid at " + relativeCandidate);
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (candidates_1_1 && !candidates_1_1.done && (_b = candidates_1.return)) _b.call(candidates_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
    };
    TransformState.prototype.setupRojo = function () {
        this.pathTranslator = new pathTranslator_1.PathTranslator(this.srcDir, this.outDir, undefined, false);
        var rojoConfig = rojoResolver_1.RojoResolver.findRojoConfigFilePath(this.currentDirectory);
        if (rojoConfig) {
            var rojoContents = fs_1.default.readFileSync(rojoConfig, { encoding: "ascii" });
            var sum = crypto_1.default.createHash("md5").update(rojoContents).digest("hex");
            if (sum === cache_1.Cache.rojoSum) {
                this.rojoResolver = cache_1.Cache.rojoResolver;
            }
            else {
                this.rojoResolver = rojoResolver_1.RojoResolver.fromPath(rojoConfig);
                cache_1.Cache.rojoSum = sum;
                cache_1.Cache.rojoResolver = this.rojoResolver;
            }
        }
    };
    TransformState.prototype.setupMacros = function () {
        var e_3, _a, e_4, _b;
        if (this.areMacrosSetup)
            return;
        this.areMacrosSetup = true;
        try {
            for (var CALL_MACROS_1 = __values(callMacros_1.CALL_MACROS), CALL_MACROS_1_1 = CALL_MACROS_1.next(); !CALL_MACROS_1_1.done; CALL_MACROS_1_1 = CALL_MACROS_1.next()) {
                var macro = CALL_MACROS_1_1.value;
                var symbols = macro.getSymbol(this);
                if (Array.isArray(symbols)) {
                    try {
                        for (var symbols_1 = (e_4 = void 0, __values(symbols)), symbols_1_1 = symbols_1.next(); !symbols_1_1.done; symbols_1_1 = symbols_1.next()) {
                            var symbol = symbols_1_1.value;
                            this.callMacros.set(symbol, macro);
                        }
                    }
                    catch (e_4_1) { e_4 = { error: e_4_1 }; }
                    finally {
                        try {
                            if (symbols_1_1 && !symbols_1_1.done && (_b = symbols_1.return)) _b.call(symbols_1);
                        }
                        finally { if (e_4) throw e_4.error; }
                    }
                    macro._symbols = symbols;
                }
                else {
                    this.callMacros.set(symbols, macro);
                    macro._symbols = [symbols];
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (CALL_MACROS_1_1 && !CALL_MACROS_1_1.done && (_a = CALL_MACROS_1.return)) _a.call(CALL_MACROS_1);
            }
            finally { if (e_3) throw e_3.error; }
        }
    };
    TransformState.prototype.addFileImport = function (file, importPath, name) {
        var e_5, _a, e_6, _b;
        var _c;
        var symbolProvider = this.symbolProvider;
        if (importPath === "@flamework/core") {
            if ((file === symbolProvider.flameworkFile.file ||
                this.getSymbol(file) === symbolProvider.flameworkFile.fileSymbol) &&
                name === "Flamework") {
                return factory_1.f.identifier("Flamework");
            }
            var flameworkDir = path_1.default.dirname(symbolProvider.flameworkFile.file.fileName);
            var modulePath = path_1.default.join(flameworkDir, name === "Reflect" ? "reflect" : "flamework");
            if (isPathDescendantOf_1.isPathDescendantOf(file.fileName, flameworkDir)) {
                importPath = "./" + path_1.default.relative(path_1.default.dirname(file.fileName), modulePath) || ".";
            }
        }
        var importInfos = this.fileImports.get(file.fileName);
        if (!importInfos)
            this.fileImports.set(file.fileName, (importInfos = []));
        var importInfo = importInfos.find(function (x) { return x.path === importPath; });
        if (!importInfo)
            importInfos.push((importInfo = { path: importPath, entries: [] }));
        var identifier = (_c = importInfo.entries.find(function (x) { return x.name === name; })) === null || _c === void 0 ? void 0 : _c.identifier;
        if (!identifier) {
            if (!file.identifiers.has(name)) {
                identifier = factory_1.f.identifier(name);
                importInfo.entries.push({ name: name, identifier: identifier });
            }
        }
        if (!identifier) {
            try {
                start: for (var _d = __values(file.statements), _e = _d.next(); !_e.done; _e = _d.next()) {
                    var statement = _e.value;
                    if (!factory_1.f.is.importDeclaration(statement))
                        break;
                    if (!factory_1.f.is.string(statement.moduleSpecifier))
                        continue;
                    if (!factory_1.f.is.importClauseDeclaration(statement.importClause))
                        continue;
                    if (!factory_1.f.is.namedImports(statement.importClause.namedBindings))
                        continue;
                    if (statement.moduleSpecifier.text !== importPath)
                        continue;
                    try {
                        for (var _f = (e_6 = void 0, __values(statement.importClause.namedBindings.elements)), _g = _f.next(); !_g.done; _g = _f.next()) {
                            var importElement = _g.value;
                            if (importElement.propertyName) {
                                if (importElement.propertyName.text === name) {
                                    identifier = importElement.name;
                                    break start;
                                }
                            }
                            else {
                                if (importElement.name.text === name) {
                                    identifier = importElement.name;
                                    break start;
                                }
                            }
                        }
                    }
                    catch (e_6_1) { e_6 = { error: e_6_1 }; }
                    finally {
                        try {
                            if (_g && !_g.done && (_b = _f.return)) _b.call(_f);
                        }
                        finally { if (e_6) throw e_6.error; }
                    }
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
                }
                finally { if (e_5) throw e_5.error; }
            }
        }
        if (!identifier)
            importInfo.entries.push({ name: name, identifier: (identifier = factory_1.f.identifier(name, true)) });
        return identifier;
    };
    TransformState.prototype.getSourceFile = function (node) {
        var parseNode = typescript_1.default.getParseTreeNode(node);
        if (!parseNode)
            throw new Error("Could not find parse tree node");
        return typescript_1.default.getSourceFileOfNode(parseNode);
    };
    TransformState.prototype.getSymbol = function (node, followAlias) {
        if (followAlias === void 0) { followAlias = true; }
        if (factory_1.f.is.classDeclaration(node) && factory_1.f.is.identifier(node.name)) {
            return this.getSymbol(node.name);
        }
        var symbol = this.typeChecker.getSymbolAtLocation(node);
        if (symbol && followAlias) {
            return typescript_1.default.skipAlias(symbol, this.typeChecker);
        }
        else {
            return symbol;
        }
    };
    TransformState.prototype.hash = function (id) {
        var _a;
        var hashPrefix = this.config.hashPrefix;
        var salt = (_a = this.config.salt) !== null && _a !== void 0 ? _a : this.buildInfo.getSalt();
        var hashGenerator = new hashids_1.default(salt, 2);
        if (this.isGame && !hashPrefix) {
            return "" + hashGenerator.encode(id);
        }
        else {
            // If the package name is namespaced, then it can be used in
            // other projects so we want to add a prefix to the Id to prevent
            // collisions with other packages or the game.
            return (hashPrefix !== null && hashPrefix !== void 0 ? hashPrefix : this.packageName) + ":" + hashGenerator.encode(id);
        }
    };
    TransformState.prototype.getInternalId = function (node, extra) {
        if (extra === void 0) { extra = false; }
        var filePath = this.getSourceFile(node).fileName;
        var fullName = getDeclarationName_1.getDeclarationName(node);
        var _a = getPackageJson_1.getPackageJson(path_1.default.dirname(filePath)), directory = _a.directory, result = _a.result;
        if (isPathDescendantOf_1.isPathDescendantOf(filePath, this.pathTranslator.rootDir)) {
            var outputPath = this.pathTranslator.getOutputPath(filePath).replace(/(\.lua)$/, "");
            var relativePath_1 = path_1.default.relative(this.currentDirectory, outputPath);
            var internalId_1 = result.name + ":" + relativePath_1.replace(/\\/g, "/") + "@" + fullName;
            return extra ? [false, internalId_1] : internalId_1;
        }
        var relativePath = path_1.default.relative(directory, filePath.replace(/(\.d)?.ts$/, "").replace(/index$/, "init"));
        var internalId = result.name + ":" + relativePath.replace(/\\/g, "/") + "@" + fullName;
        return extra ? [true, internalId] : internalId;
    };
    /**
     * Format the internal id to be shorter, remove `out` part of path, and use hashPrefix.
     */
    TransformState.prototype.formatInternalid = function (internalId, hashPrefix) {
        if (hashPrefix === void 0) { hashPrefix = this.config.hashPrefix; }
        var match = new RegExp("^@.*/.*:(.+)@(.+)$").exec(internalId);
        if (!match)
            return internalId;
        var _a = __read(match, 3), path = _a[1], name = _a[2];
        var revisedPath = path.replace(/^(.*)[\/\\]/, "");
        return hashPrefix + ":" + revisedPath + "@" + name;
    };
    TransformState.prototype.getUid = function (node) {
        var _a = __read(this.getInternalId(node, true), 2), isPackage = _a[0], internalId = _a[1];
        var id = this.buildInfo.getIdentifierFromInternal(internalId);
        if (id)
            return id;
        // this is a package, and the package itself did not generate an id
        // use the internal ID to prevent breakage between packages and games.
        if (isPackage) {
            var buildInfo = this.buildInfo.getBuildInfoFromFile(this.getSourceFile(node).fileName);
            if (buildInfo) {
                var prefix = buildInfo.getIdentifierPrefix();
                if (prefix) {
                    return this.formatInternalid(internalId, prefix);
                }
            }
            return internalId;
        }
        var newId = !this.config.obfuscation
            ? this.formatInternalid(internalId)
            : this.hash(this.buildInfo.getLatestId());
        this.buildInfo.addIdentifier(internalId, newId);
        return newId;
    };
    TransformState.prototype.obfuscateText = function (text, context) {
        return this.config.obfuscation ? this.buildInfo.hashString(text, context) : text;
    };
    TransformState.prototype.addDiagnostic = function (diag) {
        if (diag.category === typescript_1.default.DiagnosticCategory.Error) {
            this.hasErrors = true;
        }
        this.context.addDiagnostic(diag);
    };
    TransformState.prototype.capture = function (cb) {
        this.prereqStack.push([]);
        var result = cb();
        return [result, this.prereqStack.pop()];
    };
    TransformState.prototype.prereq = function (statement) {
        var stack = this.prereqStack[this.prereqStack.length - 1];
        if (stack)
            stack.push(statement);
    };
    TransformState.prototype.prereqList = function (statements) {
        var stack = this.prereqStack[this.prereqStack.length - 1];
        if (stack)
            stack.push.apply(stack, __spreadArray([], __read(statements)));
    };
    TransformState.prototype.isCapturing = function (threshold) {
        if (threshold === void 0) { threshold = 1; }
        return this.prereqStack.length > threshold;
    };
    TransformState.prototype.transform = function (node) {
        var _this = this;
        return typescript_1.default.visitEachChild(node, function (newNode) { return transformNode_1.transformNode(_this, newNode); }, this.context);
    };
    TransformState.prototype._shouldViewFile = function (file) {
        var e_7, _a;
        var fileName = path_1.default.posix.normalize(file.fileName);
        if (IGNORE_RBXTS_REGEX.test(fileName))
            return false;
        var buildCandidates = cache_1.Cache.buildInfoCandidates;
        try {
            for (var buildCandidates_1 = __values(buildCandidates), buildCandidates_1_1 = buildCandidates_1.next(); !buildCandidates_1_1.done; buildCandidates_1_1 = buildCandidates_1.next()) {
                var candidate = buildCandidates_1_1.value;
                var realPath = cache_1.Cache.realPath.get(candidate);
                if (!realPath)
                    cache_1.Cache.realPath.set(candidate, (realPath = fs_1.default.realpathSync(candidate)));
                var candidateDir = path_1.default.dirname(realPath);
                if (isPathDescendantOf_1.isPathDescendantOf(file.fileName, candidateDir) &&
                    !isPathDescendantOf_1.isPathDescendantOf(file.fileName, path_1.default.join(candidateDir, "node_modules"))) {
                    return true;
                }
            }
        }
        catch (e_7_1) { e_7 = { error: e_7_1 }; }
        finally {
            try {
                if (buildCandidates_1_1 && !buildCandidates_1_1.done && (_a = buildCandidates_1.return)) _a.call(buildCandidates_1);
            }
            finally { if (e_7) throw e_7.error; }
        }
        return false;
    };
    TransformState.prototype.shouldViewFile = function (file) {
        var _a;
        var cached = (_a = cache_1.Cache.shouldView) === null || _a === void 0 ? void 0 : _a.get(file.fileName);
        if (cached !== undefined)
            return cached;
        var result = this._shouldViewFile(file);
        cache_1.Cache.shouldView.set(file.fileName, result);
        return result;
    };
    return TransformState;
}());
exports.TransformState = TransformState;
