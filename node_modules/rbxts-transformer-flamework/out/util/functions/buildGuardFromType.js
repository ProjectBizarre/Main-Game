"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildGuardFromType = exports.buildGuardsFromType = void 0;
var typescript_1 = __importDefault(require("typescript"));
var diagnostics_1 = require("../../classes/diagnostics");
var factory_1 = require("../factory");
var getDeclarationOfType_1 = require("./getDeclarationOfType");
var getInstanceTypeFromType_1 = require("./getInstanceTypeFromType");
/**
 * Convert a type into a list of typeguards.
 * @param state The TransformState
 * @param file The file that this type belongs to
 * @param type The type to convert
 * @param isInterfaceType Determines whether unknown should be omitted.
 * @returns An array of property assignments.
 */
function buildGuardsFromType(state, file, type, isInterfaceType) {
    var e_1, _a;
    var _b;
    if (isInterfaceType === void 0) { isInterfaceType = false; }
    var typeChecker = state.typeChecker;
    var diagnosticsLocation = (_b = getDeclarationOfType_1.getDeclarationOfType(type)) !== null && _b !== void 0 ? _b : file;
    var guards = new Array();
    try {
        for (var _c = __values(type.getProperties()), _d = _c.next(); !_d.done; _d = _c.next()) {
            var property = _d.value;
            var propertyType = typeChecker.getTypeOfPropertyOfType(type, property.name);
            if (!propertyType)
                diagnostics_1.Diagnostics.error(diagnosticsLocation, "Could not find type for field");
            if (isInterfaceType && (propertyType.flags & typescript_1.default.TypeFlags.Unknown) !== 0) {
                continue;
            }
            var attribute = buildGuardFromType(state, file, propertyType);
            guards.push(factory_1.f.propertyDeclaration(property.name, attribute));
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return guards;
}
exports.buildGuardsFromType = buildGuardsFromType;
var rbxTypes = [
    "UDim",
    "UDim2",
    "BrickColor",
    "Color3",
    "Vector2",
    "Vector3",
    "NumberSequence",
    "NumberSequenceKeypoint",
    "ColorSequence",
    "ColorSequenceKeypoint",
    "NumberRange",
    "Rect",
    "DockWidgetPluginGuiInfo",
    "CFrame",
    "Axes",
    "Faces",
    "Instance",
    "Ray",
    "Random",
    "Region3",
    "Region3int16",
    "Enum",
    "TweenInfo",
    "PhysicalProperties",
    "Vector3int16",
    "PathWaypoint",
    "EnumItem",
    "RBXScriptSignal",
    "RBXScriptConnection",
    "thread",
];
/**
 * Convert a type into a type guard.
 * @param state The TransformState
 * @param file The file that this type belongs to
 * @param type The type to convert
 * @returns An array of property assignments.
 */
function buildGuardFromType(state, file, type) {
    var e_2, _a, e_3, _b;
    var _c, _d, _e, _f, _g, _h;
    var typeChecker = state.typeChecker;
    var diagnosticsLocation = (_c = getDeclarationOfType_1.getDeclarationOfType(type)) !== null && _c !== void 0 ? _c : file;
    var tId = state.addFileImport(file, "@rbxts/t", "t");
    if ((type.flags & typescript_1.default.TypeFlags.TypeVariable) !== 0) {
        var constraint = type.checker.getBaseConstraintOfType(type);
        if (!constraint)
            diagnostics_1.Diagnostics.error(diagnosticsLocation, "could not find constraint of type parameter");
        return buildGuardFromType(state, file, constraint);
    }
    if (isInstanceType(type)) {
        var instanceType = getInstanceTypeFromType_1.getInstanceTypeFromType(file, type);
        var additionalGuards = new Array();
        try {
            for (var _j = __values(type.getProperties()), _k = _j.next(); !_k.done; _k = _j.next()) {
                var property = _k.value;
                var propertyType = type.checker.getTypeOfPropertyOfType(type, property.name);
                if (propertyType && !instanceType.getProperty(property.name)) {
                    // assume intersections are children
                    additionalGuards.push(factory_1.f.propertyDeclaration(property.name, buildGuardFromType(state, file, propertyType)));
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_k && !_k.done && (_a = _j.return)) _a.call(_j);
            }
            finally { if (e_2) throw e_2.error; }
        }
        var baseGuard = factory_1.f.call(factory_1.f.field(tId, "instanceIsA"), [instanceType.symbol.name]);
        return additionalGuards.length === 0
            ? baseGuard
            : factory_1.f.call(factory_1.f.field(tId, "intersection"), [
                baseGuard,
                factory_1.f.call(factory_1.f.field(tId, "children"), [factory_1.f.object(additionalGuards)]),
            ]);
    }
    if (type.isUnion()) {
        return buildUnionGuard(state, file, type);
    }
    if (type.isIntersection()) {
        return buildIntersectionGuard(state, file, type);
    }
    if (type.isStringLiteral() || type.isNumberLiteral()) {
        return factory_1.f.call(factory_1.f.field(tId, "literal"), [type.value]);
    }
    if (typeChecker.isTupleType(type)) {
        var typeArgs = (_d = type.resolvedTypeArguments) !== null && _d !== void 0 ? _d : [];
        return factory_1.f.call(factory_1.f.field(tId, "strictArray"), typeArgs.map(function (x) { return buildGuardFromType(state, file, x); }));
    }
    if (typeChecker.isArrayType(type)) {
        var typeArg = (_e = type.typeArguments) === null || _e === void 0 ? void 0 : _e[0];
        return factory_1.f.call(factory_1.f.field(tId, "array"), [
            typeArg ? buildGuardFromType(state, file, typeArg) : factory_1.f.field(tId, "any"),
        ]);
    }
    if (type.getCallSignatures().length > 0) {
        return factory_1.f.field(tId, "callback");
    }
    var voidType = typeChecker.getVoidType();
    var undefinedType = typeChecker.getUndefinedType();
    if (type === voidType || type === undefinedType) {
        return factory_1.f.field(tId, "none");
    }
    var anyType = typeChecker.getAnyType();
    if (type === anyType) {
        return factory_1.f.field(tId, "any");
    }
    var trueType = typeChecker.getTrueType();
    if (type === trueType) {
        return factory_1.f.call(factory_1.f.field(tId, "literal"), [true]);
    }
    var falseType = typeChecker.getFalseType();
    if (type === falseType) {
        return factory_1.f.call(factory_1.f.field(tId, "literal"), [false]);
    }
    var stringType = typeChecker.getStringType();
    if (type === stringType) {
        return factory_1.f.field(tId, "string");
    }
    var numberType = typeChecker.getNumberType();
    if (type === numberType) {
        return factory_1.f.field(tId, "number");
    }
    if ((type.flags & typescript_1.default.TypeFlags.Unknown) !== 0) {
        return factory_1.f.call(factory_1.f.field(tId, "union"), [factory_1.f.field(tId, "any"), factory_1.f.field(tId, "none")]);
    }
    var symbol = type.getSymbol();
    if (!symbol)
        diagnostics_1.Diagnostics.error(diagnosticsLocation, "Attribute type has no symbol");
    var mapSymbol = typeChecker.resolveName("Map", undefined, typescript_1.default.SymbolFlags.Type, false);
    var readonlyMapSymbol = typeChecker.resolveName("ReadonlyMap", undefined, typescript_1.default.SymbolFlags.Type, false);
    var weakMapSymbol = typeChecker.resolveName("WeakMap", undefined, typescript_1.default.SymbolFlags.Type, false);
    if (symbol === mapSymbol || symbol === readonlyMapSymbol || symbol === weakMapSymbol) {
        var keyType = (_f = type.typeArguments) === null || _f === void 0 ? void 0 : _f[0];
        var valueType = (_g = type.typeArguments) === null || _g === void 0 ? void 0 : _g[1];
        return factory_1.f.call(factory_1.f.field(tId, "map"), [
            keyType ? buildGuardFromType(state, file, keyType) : factory_1.f.field(tId, "any"),
            valueType ? buildGuardFromType(state, file, valueType) : factory_1.f.field(tId, "any"),
        ]);
    }
    var setSymbol = typeChecker.resolveName("Set", undefined, typescript_1.default.SymbolFlags.Type, false);
    var readonlySetSymbol = typeChecker.resolveName("ReadonlySet", undefined, typescript_1.default.SymbolFlags.Type, false);
    if (symbol === setSymbol || symbol === readonlySetSymbol) {
        var valueType = (_h = type.typeArguments) === null || _h === void 0 ? void 0 : _h[0];
        return factory_1.f.call(factory_1.f.field(tId, "set"), [
            valueType ? buildGuardFromType(state, file, valueType) : factory_1.f.field(tId, "any"),
        ]);
    }
    var promiseSymbol = typeChecker.resolveName("Promise", undefined, typescript_1.default.SymbolFlags.Type, false);
    if (symbol === promiseSymbol) {
        return factory_1.f.field("Promise", "is");
    }
    try {
        for (var rbxTypes_1 = __values(rbxTypes), rbxTypes_1_1 = rbxTypes_1.next(); !rbxTypes_1_1.done; rbxTypes_1_1 = rbxTypes_1.next()) {
            var guard = rbxTypes_1_1.value;
            var guardSymbol = typeChecker.resolveName(guard, undefined, typescript_1.default.SymbolFlags.Type, false);
            if (!guardSymbol)
                diagnostics_1.Diagnostics.error(diagnosticsLocation, "Could not find symbol for " + guard);
            if (symbol === guardSymbol) {
                return factory_1.f.field(tId, guard);
            }
        }
    }
    catch (e_3_1) { e_3 = { error: e_3_1 }; }
    finally {
        try {
            if (rbxTypes_1_1 && !rbxTypes_1_1.done && (_b = rbxTypes_1.return)) _b.call(rbxTypes_1);
        }
        finally { if (e_3) throw e_3.error; }
    }
    if (type.isClass()) {
        diagnostics_1.Diagnostics.error(diagnosticsLocation, "Invalid type: class");
    }
    var isObject = isObjectType(type);
    if (isObject && type.getApparentProperties().length === 0) {
        return factory_1.f.field(tId, "any");
    }
    if (isObject || type.isClassOrInterface()) {
        return factory_1.f.call(factory_1.f.field(tId, "interface"), [factory_1.f.object(buildGuardsFromType(state, file, type, true))]);
    }
    diagnostics_1.Diagnostics.error(diagnosticsLocation, "Invalid type: " + typeChecker.typeToString(type));
}
exports.buildGuardFromType = buildGuardFromType;
function buildUnionGuard(state, file, type) {
    var tId = state.addFileImport(file, "@rbxts/t", "t");
    var boolType = type.checker.getBooleanType();
    if (type === boolType) {
        return factory_1.f.field(tId, "boolean");
    }
    var enumType = type.checker.resolveName("Enum", undefined, typescript_1.default.SymbolFlags.Type, false);
    if (type.aliasSymbol && type.aliasSymbol.parent === enumType) {
        return factory_1.f.call(factory_1.f.field(tId, "enum"), [factory_1.f.field("Enum", type.aliasSymbol.name)]);
    }
    var undefinedType = type.checker.getUndefinedType();
    var voidType = type.checker.getVoidType();
    var isOptional = type.types.some(function (x) { return x === undefinedType || x === voidType; });
    var guards = type.types
        .filter(function (x) { return x !== undefinedType && x !== voidType; })
        .map(function (type) { return buildGuardFromType(state, file, type); });
    var union = guards.length > 1 ? factory_1.f.call(factory_1.f.field(tId, "union"), guards) : guards[0];
    if (!union)
        return factory_1.f.field(tId, "none");
    return isOptional ? factory_1.f.call(factory_1.f.field(tId, "optional"), [union]) : union;
}
function buildIntersectionGuard(state, file, type) {
    var tId = state.addFileImport(file, "@rbxts/t", "t");
    var guards = type.types.map(function (x) { return buildGuardFromType(state, file, x); });
    return factory_1.f.call(factory_1.f.field(tId, "intersection"), guards);
}
function isObjectType(type) {
    return (type.flags & typescript_1.default.TypeFlags.Object) !== 0;
}
function isInstanceType(type) {
    return type.getProperty("_nominal_Instance") !== undefined;
}
