"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.f = void 0;
var typescript_1 = __importDefault(require("typescript"));
/**
 * Shorthand factory methods.
 *
 * Naming scheme:
 *
 * f.expressionType
 * f.declarationTypeDeclaration
 * f.statementTypeStatement
 * f.typeNodeType
 *
 * f.is.*
 * f.update.*
 *
 * Examples:
 *
 * f.string()
 * f.classDeclaration()
 * f.ifStatement()
 */
var f;
(function (f) {
    var factory = typescript_1.default.factory;
    function toExpression(expression, stringFn) {
        if (stringFn === void 0) { stringFn = string; }
        if (typeof expression === "string") {
            return stringFn(expression);
        }
        else if (typeof expression === "number") {
            return number(expression);
        }
        else if (typeof expression === "boolean") {
            return bool(expression);
        }
        else if (Array.isArray(expression)) {
            return array(expression.map(function (x) { return toExpression(x); }));
        }
        else {
            return expression;
        }
    }
    f.toExpression = toExpression;
    /// Expressions
    function string(str) {
        return factory.createStringLiteral(str);
    }
    f.string = string;
    function bool(value) {
        return value ? factory.createTrue() : factory.createFalse();
    }
    f.bool = bool;
    function array(values, multiLine) {
        if (multiLine === void 0) { multiLine = true; }
        return factory.createArrayLiteralExpression(values, multiLine);
    }
    f.array = array;
    function number(value, flags) {
        return factory.createNumericLiteral(value, flags);
    }
    f.number = number;
    function identifier(name, unique) {
        if (unique === void 0) { unique = false; }
        return unique ? factory.createUniqueName(name) : factory.createIdentifier(name);
    }
    f.identifier = identifier;
    function nil() {
        return identifier("undefined");
    }
    f.nil = nil;
    function field(name, property) {
        return factory.createPropertyAccessExpression(toExpression(name, identifier), property);
    }
    f.field = field;
    function statement(expression) {
        return factory.createExpressionStatement(toExpression(expression));
    }
    f.statement = statement;
    function call(expression, args, typeArguments) {
        return factory.createCallExpression(toExpression(expression, identifier), typeArguments, args === null || args === void 0 ? void 0 : args.map(function (x) { return toExpression(x); }));
    }
    f.call = call;
    function object(properties, multiLine) {
        var e_1, _a;
        if (multiLine === void 0) { multiLine = true; }
        if (Array.isArray(properties)) {
            return factory.createObjectLiteralExpression(properties, multiLine);
        }
        else {
            var realProperties = [];
            try {
                for (var _b = __values(Object.keys(properties)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var key = _c.value;
                    realProperties.push(propertyDeclaration(key, properties[key]));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return factory.createObjectLiteralExpression(realProperties, multiLine);
        }
    }
    f.object = object;
    function as(expression, node, explicit) {
        if (explicit === void 0) { explicit = false; }
        return explicit
            ? factory.createAsExpression(factory.createAsExpression(expression, keywordType(typescript_1.default.SyntaxKind.UnknownKeyword)), node)
            : factory.createAsExpression(expression, node);
    }
    f.as = as;
    function binary(left, op, right) {
        return factory.createBinaryExpression(toExpression(left), op, toExpression(right));
    }
    f.binary = binary;
    function elementAccessExpression(expression, index) {
        return factory.createElementAccessExpression(toExpression(expression), toExpression(index));
    }
    f.elementAccessExpression = elementAccessExpression;
    /// Statements
    /// Declarations
    function propertyDeclaration(name, value) {
        return factory.createPropertyAssignment(typeof name === "string" ? string(name) : name, toExpression(value));
    }
    f.propertyDeclaration = propertyDeclaration;
    function importDeclaration(path, imports, defaultImport, typeOnly) {
        if (typeOnly === void 0) { typeOnly = false; }
        return factory.createImportDeclaration(undefined, undefined, factory.createImportClause(typeOnly, defaultImport, imports
            ? factory.createNamedImports(imports.map(function (x) {
                if (Array.isArray(x)) {
                    return factory.createImportSpecifier(typeof x[0] === "string" ? f.identifier(x[0]) : x[0], x[1]);
                }
                else {
                    return factory.createImportSpecifier(undefined, x);
                }
            }))
            : undefined), toExpression(path));
    }
    f.importDeclaration = importDeclaration;
    function functionDeclaration(name, body, parameters, type, typeParams) {
        if (parameters === void 0) { parameters = []; }
        return factory.createFunctionDeclaration(undefined, undefined, undefined, name, typeParams, parameters, type, body);
    }
    f.functionDeclaration = functionDeclaration;
    /// Type Nodes
    function referenceType(typeName, typeArguments) {
        return factory.createTypeReferenceNode(typeName, typeArguments);
    }
    f.referenceType = referenceType;
    function keywordType(kind) {
        return factory.createKeywordTypeNode(kind);
    }
    f.keywordType = keywordType;
    function qualifiedNameType(left, right) {
        return factory.createQualifiedName(left, right);
    }
    f.qualifiedNameType = qualifiedNameType;
    function typeLiteralType(members) {
        return factory.createTypeLiteralNode(members);
    }
    f.typeLiteralType = typeLiteralType;
    function literalType(expr) {
        return factory.createLiteralTypeNode(expr);
    }
    f.literalType = literalType;
    function propertySignatureType(name, type) {
        return factory.createPropertySignature(undefined, name, undefined, type);
    }
    f.propertySignatureType = propertySignatureType;
    function indexedAccessType(left, right) {
        return factory.createIndexedAccessTypeNode(left, right);
    }
    f.indexedAccessType = indexedAccessType;
    var is;
    (function (is) {
        /// Expressions
        function statement(node) {
            return node !== undefined && typescript_1.default.isExpressionStatement(node);
        }
        is.statement = statement;
        function string(node) {
            return node !== undefined && typescript_1.default.isStringLiteral(node);
        }
        is.string = string;
        function bool(node) {
            return node !== undefined && (node === f.bool(true) || node === f.bool(false));
        }
        is.bool = bool;
        function array(node) {
            return node !== undefined && typescript_1.default.isArrayLiteralExpression(node);
        }
        is.array = array;
        function number(node) {
            return node !== undefined && typescript_1.default.isNumericLiteral(node);
        }
        is.number = number;
        function identifier(node) {
            return node !== undefined && typescript_1.default.isIdentifier(node);
        }
        is.identifier = identifier;
        function nil(node) {
            return node !== undefined && identifier(node) && node.text === "undefined";
        }
        is.nil = nil;
        function call(node) {
            return node !== undefined && typescript_1.default.isCallExpression(node);
        }
        is.call = call;
        function object(node) {
            return node !== undefined && typescript_1.default.isObjectLiteralExpression(node);
        }
        is.object = object;
        function functionExpression(node) {
            return node !== undefined && (typescript_1.default.isArrowFunction(node) || typescript_1.default.isFunctionExpression(node));
        }
        is.functionExpression = functionExpression;
        function omitted(node) {
            return node !== undefined && typescript_1.default.isOmittedExpression(node);
        }
        is.omitted = omitted;
        function accessExpression(node) {
            return node !== undefined && typescript_1.default.isAccessExpression(node);
        }
        is.accessExpression = accessExpression;
        function propertyAccessExpression(node) {
            return node !== undefined && typescript_1.default.isPropertyAccessExpression(node);
        }
        is.propertyAccessExpression = propertyAccessExpression;
        function postfixUnary(node) {
            return node !== undefined && typescript_1.default.isPostfixUnaryExpression(node);
        }
        is.postfixUnary = postfixUnary;
        /// Statements
        /// Declarations
        function constructor(node) {
            return node !== undefined && typescript_1.default.isConstructorDeclaration(node);
        }
        is.constructor = constructor;
        function propertyDeclaration(node) {
            return node !== undefined && typescript_1.default.isPropertyDeclaration(node);
        }
        is.propertyDeclaration = propertyDeclaration;
        function propertyAssignmentDeclaration(node) {
            return node !== undefined && typescript_1.default.isPropertyAssignment(node);
        }
        is.propertyAssignmentDeclaration = propertyAssignmentDeclaration;
        function importDeclaration(node) {
            return node !== undefined && typescript_1.default.isImportDeclaration(node);
        }
        is.importDeclaration = importDeclaration;
        function classDeclaration(node) {
            return node !== undefined && typescript_1.default.isClassDeclaration(node);
        }
        is.classDeclaration = classDeclaration;
        function namespaceDeclaration(node) {
            return ((node !== undefined &&
                typescript_1.default.isModuleDeclaration(node) &&
                identifier(node.name) &&
                node.body &&
                typescript_1.default.isNamespaceBody(node.body)) ||
                false);
        }
        is.namespaceDeclaration = namespaceDeclaration;
        function moduleBlockDeclaration(node) {
            return node !== undefined && typescript_1.default.isModuleBlock(node);
        }
        is.moduleBlockDeclaration = moduleBlockDeclaration;
        function importClauseDeclaration(node) {
            return node !== undefined && typescript_1.default.isImportClause(node);
        }
        is.importClauseDeclaration = importClauseDeclaration;
        function namedDeclaration(node) {
            return node !== undefined && typescript_1.default.isNamedDeclaration(node);
        }
        is.namedDeclaration = namedDeclaration;
        function interfaceDeclaration(node) {
            return node !== undefined && typescript_1.default.isInterfaceDeclaration(node);
        }
        is.interfaceDeclaration = interfaceDeclaration;
        function typeAliasDeclaration(node) {
            return node !== undefined && typescript_1.default.isTypeAliasDeclaration(node);
        }
        is.typeAliasDeclaration = typeAliasDeclaration;
        /// Type Nodes
        function referenceType(node) {
            return node !== undefined && typescript_1.default.isTypeReferenceNode(node);
        }
        is.referenceType = referenceType;
        function queryType(node) {
            return node !== undefined && typescript_1.default.isTypeQueryNode(node);
        }
        is.queryType = queryType;
        /// OTHERS
        function namedImports(node) {
            return node !== undefined && typescript_1.default.isNamedImports(node);
        }
        is.namedImports = namedImports;
    })(is = f.is || (f.is = {}));
    var update;
    (function (update) {
        /// Expressions
        function call(node, expression, args, typeArguments) {
            var _a;
            if (expression === void 0) { expression = node.expression; }
            return factory.updateCallExpression(node, expression, typeArguments !== null && typeArguments !== void 0 ? typeArguments : node.typeArguments, (_a = args === null || args === void 0 ? void 0 : args.map(function (x) { return toExpression(x); })) !== null && _a !== void 0 ? _a : node.arguments);
        }
        update.call = call;
        function object(node, properties) {
            return factory.updateObjectLiteralExpression(node, properties !== null && properties !== void 0 ? properties : node.properties);
        }
        update.object = object;
        function propertyAccessExpression(node, expression, name) {
            return factory.updatePropertyAccessExpression(node, toExpression(expression), typeof name === "string" ? f.identifier(name) : name);
        }
        update.propertyAccessExpression = propertyAccessExpression;
        function elementAccessExpression(node, expression, name) {
            return factory.updateElementAccessExpression(node, toExpression(expression), toExpression(name));
        }
        update.elementAccessExpression = elementAccessExpression;
        /// Statements
        /// Declarations
        function classDeclaration(node, name, members, decorators, heritageClauses, typeParameters, modifiers) {
            if (name === void 0) { name = node.name; }
            if (members === void 0) { members = node.members; }
            if (heritageClauses === void 0) { heritageClauses = node.heritageClauses; }
            if (typeParameters === void 0) { typeParameters = node.typeParameters; }
            if (modifiers === void 0) { modifiers = node.modifiers; }
            return factory.updateClassDeclaration(node, decorators, modifiers, name, typeParameters, heritageClauses, members);
        }
        update.classDeclaration = classDeclaration;
        function propertyAssignmentDeclaration(node, initializer, name) {
            if (initializer === void 0) { initializer = node.initializer; }
            if (name === void 0) { name = node.name; }
            return factory.updatePropertyAssignment(node, typeof name === "string" ? f.identifier(name) : name, toExpression(initializer));
        }
        update.propertyAssignmentDeclaration = propertyAssignmentDeclaration;
        /// Type Nodes
        /// Other
        function sourceFile(sourceFile, statements, isDeclarationFile, referencedFiles, typeReferences, hasNoDefaultLib, libReferences) {
            if (statements === void 0) { statements = sourceFile.statements; }
            if (isDeclarationFile === void 0) { isDeclarationFile = sourceFile.isDeclarationFile; }
            if (referencedFiles === void 0) { referencedFiles = sourceFile.referencedFiles; }
            if (typeReferences === void 0) { typeReferences = sourceFile.typeReferenceDirectives; }
            if (hasNoDefaultLib === void 0) { hasNoDefaultLib = sourceFile.hasNoDefaultLib; }
            if (libReferences === void 0) { libReferences = sourceFile.libReferenceDirectives; }
            return factory.updateSourceFile(sourceFile, statements, isDeclarationFile, referencedFiles, typeReferences, hasNoDefaultLib, libReferences);
        }
        update.sourceFile = sourceFile;
    })(update = f.update || (f.update = {}));
    function setFactory(newFactory) {
        factory = newFactory;
    }
    f.setFactory = setFactory;
})(f = exports.f || (exports.f = {}));
