-- Compiled with roblox-ts v1.2.3
local TS = _G[script]
local Object = TS.import(script, TS.getModule(script, "@rbxts", "object-utils"))
local _services = TS.import(script, TS.getModule(script, "@rbxts", "services"))
local Players = _services.Players
local ReplicatedStorage = _services.ReplicatedStorage
local RunService = _services.RunService
local NetworkingImpl = {}
do
	local _container = NetworkingImpl
	local Sink = {}
	_container.Sink = Sink
	local function populateEvents(names, eventsName, map)
		local _result
		if RunService:IsServer() then
			_result = ReplicatedStorage:FindFirstChild(eventsName)
		else
			_result = ReplicatedStorage:WaitForChild(eventsName)
		end
		local remotes = _result
		if not remotes then
			remotes = Instance.new("Folder")
			remotes.Name = eventsName
			remotes.Parent = ReplicatedStorage
		end
		for _, name in ipairs(names) do
			if RunService:IsClient() then
				local instance = remotes:WaitForChild(name)
				if instance:IsA("RemoteEvent") then
					-- ▼ Map.set ▼
					map[name] = instance
					-- ▲ Map.set ▲
				end
			else
				local instance = remotes:FindFirstChild(name)
				if instance then
					if not instance:IsA("RemoteEvent") then
						error("Found " .. name .. " but it is not a remote.")
					end
					-- ▼ Map.set ▼
					map[name] = instance
					-- ▲ Map.set ▲
				else
					local remote = Instance.new("RemoteEvent")
					remote.Name = name
					remote.Parent = remotes
					-- ▼ Map.set ▼
					map[name] = remote
					-- ▲ Map.set ▲
				end
			end
		end
	end
	local function createEvent(name, _serverGuards, _clientGuards, serverMiddleware, clientMiddleware)
		local serverGuards = _serverGuards
		local clientGuards = _clientGuards
		local globalEvents = {}
		local remotes = {}
		populateEvents(Object.keys(serverGuards), "events-" .. name, remotes)
		populateEvents(Object.keys(clientGuards), "events-" .. name, remotes)
		local _result
		if RunService:IsServer() then
			_result = serverMiddleware
		else
			_result = clientMiddleware
		end
		local middleware = _result
		local connections = {}
		local eventExecutors = {}
		for name in pairs(remotes) do
			local executor = function(player, ...)
				local args = { ... }
				local bindable = connections[name]
				if not bindable then
					return warn("no bindable for", name)
				end
				return bindable:Fire(player, unpack(args))
			end
			local startingExecutor = executor
			local _eventMiddleware = middleware
			if _eventMiddleware ~= nil then
				_eventMiddleware = _eventMiddleware[name]
			end
			local eventMiddleware = _eventMiddleware
			if eventMiddleware ~= nil then
				do
					local i = #eventMiddleware - 1
					local _shouldIncrement = false
					while true do
						if _shouldIncrement then
							i -= 1
						else
							_shouldIncrement = true
						end
						if not (i >= 0) then
							break
						end
						local middleware = eventMiddleware[i + 1](startingExecutor, {
							name = name,
						})
						startingExecutor = middleware
					end
				end
			end
			local _startingExecutor = startingExecutor
			-- ▼ Map.set ▼
			eventExecutors[name] = _startingExecutor
			-- ▲ Map.set ▲
		end
		local function fireConnections(event, player, ...)
			local args = { ... }
			local executor = eventExecutors[event]
			if executor ~= nil then
				return executor(player, unpack(args))
			end
		end
		if RunService:IsServer() then
			globalEvents.server = {}
			globalEvents.server.connect = function(self, event, cb, additionalGuards)
				local remote = remotes[event]
				local guards = serverGuards[event]
				if not remote then
					error("Could not find remote " .. tostring(event))
				end
				if not guards then
					error("Could not find guards for " .. tostring(event))
				end
				local bindable = connections[event]
				if not bindable then
					local _exp = event
					bindable = Instance.new("BindableEvent")
					local _bindable = bindable
					-- ▼ Map.set ▼
					connections[_exp] = _bindable
					-- ▲ Map.set ▲
				end
				return bindable.Event:Connect(function(player, ...)
					local args = { ... }
					if additionalGuards then
						do
							local i = 0
							local _shouldIncrement = false
							while true do
								if _shouldIncrement then
									i += 1
								else
									_shouldIncrement = true
								end
								if not (i < #guards) then
									break
								end
								local guard = additionalGuards[i + 1]
								if guard ~= nil and not guard(args[i + 1]) then
									return nil
								end
							end
						end
					end
					return cb(player, unpack(args))
				end)
			end
			for name in pairs(clientGuards) do
				local remote = remotes[name]
				local method = {
					fire = function(self, player, ...)
						local args = { ... }
						remote:FireClient(player, unpack(args))
					end,
					broadcast = function(self, ...)
						local args = { ... }
						remote:FireAllClients(unpack(args))
					end,
					except = function(self, players, ...)
						local args = { ... }
						if typeof(players) == "Instance" then
							players = { players }
						end
						for _, player in ipairs(Players:GetPlayers()) do
							if not (table.find(players, player) ~= nil) then
								self:fire(player, unpack(args))
							end
						end
					end,
				}
				setmetatable(method, {
					__call = function(method, player, ...)
						local args = { ... }
						if typeof(player) == "Instance" and player:IsA("Player") then
							method:fire(player, unpack(args))
						end
					end,
				})
				globalEvents.server[name] = method
			end
			for name, remote in pairs(remotes) do
				remote.OnServerEvent:Connect(function(player, ...)
					local args = { ... }
					local guards = serverGuards[name]
					if not guards then
						error("Could not find guards for " .. name)
					end
					do
						local i = 0
						local _shouldIncrement = false
						while true do
							if _shouldIncrement then
								i += 1
							else
								_shouldIncrement = true
							end
							if not (i < #guards) then
								break
							end
							local guard = guards[i + 1]
							if not guard(args[i + 1]) then
								return nil
							end
						end
					end
					fireConnections(name, player, unpack(args))
				end)
			end
		else
			globalEvents.client = {}
			globalEvents.client.connect = function(self, event, cb, additionalGuards)
				local remote = remotes[event]
				local guards = clientGuards[event]
				if not remote then
					error("Could not find remote " .. tostring(event))
				end
				if not guards then
					error("Could not find guards for " .. tostring(event))
				end
				local bindable = connections[event]
				if not bindable then
					local _exp = event
					bindable = Instance.new("BindableEvent")
					local _bindable = bindable
					-- ▼ Map.set ▼
					connections[_exp] = _bindable
					-- ▲ Map.set ▲
				end
				return bindable.Event:Connect(function(player, ...)
					local args = { ... }
					if additionalGuards then
						do
							local i = 0
							local _shouldIncrement = false
							while true do
								if _shouldIncrement then
									i += 1
								else
									_shouldIncrement = true
								end
								if not (i < #guards) then
									break
								end
								local guard = additionalGuards[i + 1]
								if guard ~= nil and not guard(args[i + 1]) then
									return nil
								end
							end
						end
					end
					return cb(unpack(args))
				end)
			end
			globalEvents.client.predict = function(self, event, ...)
				local args = { ... }
				fireConnections(event, Players.LocalPlayer, unpack(args))
			end
			for name in pairs(serverGuards) do
				local remote = remotes[name]
				globalEvents.client[name] = (function(...)
					local args = { ... }
					remote:FireServer(unpack(args))
				end)
			end
			for name, remote in pairs(remotes) do
				remote.OnClientEvent:Connect(function(...)
					local args = { ... }
					local guards = clientGuards[name]
					if not guards then
						error("Could not find guards for " .. name)
					end
					do
						local i = 0
						local _shouldIncrement = false
						while true do
							if _shouldIncrement then
								i += 1
							else
								_shouldIncrement = true
							end
							if not (i < #guards) then
								break
							end
							local guard = guards[i + 1]
							if not guard(args[i + 1]) then
								return nil
							end
						end
					end
					fireConnections(name, nil, unpack(args))
				end)
			end
		end
		return globalEvents
	end
	_container.createEvent = createEvent
end
local Networking = {}
do
	local _container = Networking
	-- * @hidden
	-- * @hidden
	local _createEvent = NetworkingImpl.createEvent
	_container._createEvent = _createEvent
end
return {
	Networking = Networking,
}
