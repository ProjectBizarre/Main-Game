-- Compiled with roblox-ts v1.2.3
--[[
	*
	* Reflection/metadata API
]]
local Reflect = {}
do
	local _container = Reflect
	-- object -> property -> key -> value
	local metadata = setmetatable({}, {
		__mode = "k",
	})
	_container.metadata = metadata
	local idToObj = {}
	_container.idToObj = idToObj
	local objToId = {}
	_container.objToId = objToId
	local NO_PROP_MARKER = {}
	local function getObjMetadata(obj, prop, create)
		local _condition = prop
		if _condition == nil then
			_condition = NO_PROP_MARKER
		end
		local realProp = _condition
		if create then
			local objMetadata = metadata[obj]
			if not objMetadata then
				objMetadata = {}
				local _objMetadata = objMetadata
				-- ▼ Map.set ▼
				metadata[obj] = _objMetadata
				-- ▲ Map.set ▲
			end
			local propMetadata = objMetadata[realProp]
			if not propMetadata then
				local _objMetadata = objMetadata
				propMetadata = {}
				local _propMetadata = propMetadata
				-- ▼ Map.set ▼
				_objMetadata[realProp] = _propMetadata
				-- ▲ Map.set ▲
			end
			return propMetadata
		else
			local _result = metadata[obj]
			if _result ~= nil then
				_result = _result[realProp]
			end
			return _result
		end
	end
	local function getParentConstructor(obj)
		local metatable = getmetatable(obj)
		if metatable and type(metatable) == "table" then
			return rawget(metatable, "__index")
		end
	end
	--[[
		*
		* Apply metadata onto this object.
	]]
	local function defineMetadata(obj, key, value, property)
		-- 'identifier' is a special, unique ID across all metadata classes.
		if key == "identifier" then
			local _arg0 = type(value) == "string"
			assert(_arg0, "identifier must be a string.")
			local _arg0_1 = not (objToId[obj] ~= nil)
			assert(_arg0_1, "obj is already registered.")
			local _arg0_2 = not (idToObj[value] ~= nil)
			assert(_arg0_2, "id is already registered.")
			-- ▼ Map.set ▼
			objToId[obj] = value
			-- ▲ Map.set ▲
			-- ▼ Map.set ▼
			idToObj[value] = obj
			-- ▲ Map.set ▲
		end
		local metadata = getObjMetadata(obj, property, true)
		-- ▼ Map.set ▼
		metadata[key] = value
		-- ▲ Map.set ▲
	end
	_container.defineMetadata = defineMetadata
	--[[
		*
		* Apply metadata in batch onto this object.
	]]
	local function defineMetadataBatch(obj, list, property)
		local metadata = getObjMetadata(obj, property, true)
		for key, value in pairs(list) do
			-- ▼ Map.set ▼
			metadata[key] = value
			-- ▲ Map.set ▲
		end
	end
	_container.defineMetadataBatch = defineMetadataBatch
	--[[
		*
		* Delete metadata from this object.
	]]
	local function deleteMetadata(obj, key, property)
		local metadata = getObjMetadata(obj, property)
		local _result = metadata
		if _result ~= nil then
			-- ▼ Map.delete ▼
			_result[key] = nil
			-- ▲ Map.delete ▲
		end
	end
	_container.deleteMetadata = deleteMetadata
	--[[
		*
		* Get metadata from this object.
		* Type parameter is an assertion.
	]]
	local function getOwnMetadata(obj, key, property)
		local metadata = getObjMetadata(obj, property)
		local _result = metadata
		if _result ~= nil then
			_result = _result[key]
		end
		return _result
	end
	_container.getOwnMetadata = getOwnMetadata
	--[[
		*
		* Check if this object has the specified metadata key.
	]]
	local function hasOwnMetadata(obj, key, property)
		local metadata = getObjMetadata(obj, property)
		local _result = metadata
		if _result ~= nil then
			_result = _result[key] ~= nil
		end
		local _condition = _result
		if _condition == nil then
			_condition = false
		end
		return _condition
	end
	_container.hasOwnMetadata = hasOwnMetadata
	--[[
		*
		* Retrieve all metadata keys for this object.
	]]
	local function getOwnMetadataKeys(obj, property)
		local metadata = getObjMetadata(obj, property)
		local keys = {}
		local _result = metadata
		if _result ~= nil then
			local _arg0 = function(_, key)
				-- ▼ Array.push ▼
				local _length = #keys
				keys[_length + 1] = key
				-- ▲ Array.push ▲
				return _length + 1
			end
			-- ▼ ReadonlyMap.forEach ▼
			for _k, _v in pairs(_result) do
				_arg0(_v, _k, _result)
			end
			-- ▲ ReadonlyMap.forEach ▲
		end
		return keys
	end
	_container.getOwnMetadataKeys = getOwnMetadataKeys
	--[[
		*
		* Retrieve all values for the specified key from the object and its parents.
		* Type parameter is an assertion.
	]]
	local function getMetadatas(obj, key, property)
		local values = {}
		local value = getOwnMetadata(obj, key, property)
		if value ~= nil then
			-- ▼ Array.push ▼
			values[#values + 1] = value
			-- ▲ Array.push ▲
		end
		local parent = getParentConstructor(obj)
		if parent then
			local _exp = getMetadatas(parent, key, property)
			local _arg0 = function(value)
				-- ▼ Array.push ▼
				local _length = #values
				values[_length + 1] = value
				-- ▲ Array.push ▲
				return _length + 1
			end
			-- ▼ ReadonlyArray.forEach ▼
			for _k, _v in ipairs(_exp) do
				_arg0(_v, _k - 1, _exp)
			end
			-- ▲ ReadonlyArray.forEach ▲
		end
		return values
	end
	_container.getMetadatas = getMetadatas
	--[[
		*
		* Get metadata from this object or its parents.
		* Type parameter is an assertion.
	]]
	local function getMetadata(obj, key, property)
		local value = getOwnMetadata(obj, key, property)
		if value ~= nil then
			return value
		end
		local parent = getParentConstructor(obj)
		if parent then
			return getMetadata(parent, key, property)
		end
	end
	_container.getMetadata = getMetadata
	--[[
		*
		* Check if this object or any of its parents has the specified metadata key.
	]]
	local function hasMetadata(obj, key, property)
		local value = hasOwnMetadata(obj, key, property)
		if value then
			return value
		end
		local parent = getParentConstructor(obj)
		if parent then
			return hasMetadata(parent, key, property)
		end
		return false
	end
	_container.hasMetadata = hasMetadata
	--[[
		*
		* Retrieve all metadata keys for this object and its parents.
	]]
	local function getMetadataKeys(obj, property)
		local _set = {}
		for _, _v in ipairs(getOwnMetadataKeys(obj, property)) do
			_set[_v] = true
		end
		local keys = _set
		local parent = getParentConstructor(obj)
		if parent then
			local _exp = getMetadataKeys(parent, property)
			local _arg0 = function(key)
				-- ▼ Set.add ▼
				keys[key] = true
				-- ▲ Set.add ▲
				return keys
			end
			-- ▼ ReadonlyArray.forEach ▼
			for _k, _v in ipairs(_exp) do
				_arg0(_v, _k - 1, _exp)
			end
			-- ▲ ReadonlyArray.forEach ▲
		end
		local _ptr = {}
		local _length = #_ptr
		for _v in pairs(keys) do
			_length += 1
			_ptr[_length] = _v
		end
		return _ptr
	end
	_container.getMetadataKeys = getMetadataKeys
end
return {
	Reflect = Reflect,
}
