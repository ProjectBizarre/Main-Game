/// <reference types="@rbxts/compiler-types" />
/// <reference types="t" />
import { t } from "@rbxts/t";
import { Constructor } from "./types";
export declare namespace Flamework {
    export type Config = (ComponentConfig & {
        type: "Component";
    }) | (ServiceConfig & {
        type: "Service";
    }) | (ControllerConfig & {
        type: "Controller";
    }) | (ArbitraryConfig & {
        type: "Arbitrary";
    });
    export type ConfigType<T extends keyof ConfigTypes> = _<Extract<Config, {
        type: T;
    }>>;
    export interface ConfigTypes {
        Component: ComponentConfig;
        Service: ServiceConfig;
        Controller: ControllerConfig;
        Arbitrary: ArbitraryConfig;
    }
    export interface ComponentConfig {
        tag?: string;
        attributes?: {
            [key: string]: t.check<unknown>;
        };
        defaults?: {
            [key: string]: unknown;
        };
        instanceGuard?: t.check<unknown>;
        refreshAttributes?: boolean;
    }
    export interface ServiceConfig {
        loadOrder?: number;
    }
    export interface ControllerConfig {
        loadOrder?: number;
    }
    export interface ArbitraryConfig {
        arguments: unknown[];
    }
    export interface FlameworkConfig {
        isDefault: boolean;
        loadOverride?: Constructor<unknown>[];
    }
    export const flameworkConfig: FlameworkConfig;
    export let isInitialized: boolean;
    /** @hidden */
    export function createDependency(ctor: Constructor): unknown;
    /** @hidden */
    export function resolveDependency(id: string): unknown;
    /** @hidden */
    export function _addPaths(...args: [
        ...string[]
    ][]): void;
    /** @hidden */
    export function _implements<T>(object: unknown, id: string): object is T;
    /**
     * Allow an external module to be bootstrapped by Flamework.ignite()
     */
    export function registerExternalClass(ctor: Constructor): void;
    type LoadableConfigs = Extract<Config, {
        type: "Service" | "Controller";
    }>;
    /**
     * Initialize Flamework.
     *
     * This will start up the lifecycle events on all currently registered
     * classes.
     *
     * You should preload all necessary directories before calling this
     * as newly registered classes will not run their lifecycle events.
     *
     * @returns All the dependencies that have been loaded.
     */
    export function ignite(patchedConfig?: Partial<FlameworkConfig>): [unknown, LoadableConfigs][];
    /**
     * Preload the specified paths by requiring all ModuleScript descendants.
     */
    export function addPaths(...args: string[]): void;
    /**
     * Retrieve the identifier for the specified type.
     */
    export function id<T>(): string;
    /**
     * Check if object implements the specified interface.
     */
    export function implements<T>(object: unknown): object is T;
    /**
     * Creates a type guard from any arbitrary type.
     */
    export function createGuard<T>(): t.check<T>;
    /**
     * Hash a function using the method used internally by Flamework.
     * If a context is provided, then Flamework will create a new hash
     * if the specified string does not have one in that context.
     * @param str The string to hash
     * @param context A scope for the hash
     */
    export function hash(str: string, context?: string): string;
    /**
     * Utility for use in test suites, not recommended for anything else.
     */
    export namespace Testing {
        function patchDependency<T>(patchedClass: Constructor<unknown>, id?: string): void;
    }
    export {};
}
declare type ClassDecorator = (ctor: any) => any;
export declare function Dependency<T>(): T;
export declare function Dependency<T>(ctor: Constructor<T>): T;
export declare function Dependency<T>(ctor?: Constructor<T>): T;
/**
 * Register a class as a Service.
 *
 * @server
 */
export declare function Service(opts?: Flamework.ServiceConfig): ClassDecorator;
/**
 * Register a class as a Controller.
 *
 * @client
 */
export declare function Controller(opts?: Flamework.ControllerConfig): ClassDecorator;
/**
 * Marks this class as an external class.
 *
 * External classes are designed for packages and won't be
 * bootstrapped unless explicitly specified. Excluding this
 * inside of a package will make the class load as long as
 * it has been loaded.
 */
export declare function External(): ClassDecorator;
/**
 * Hook into the OnInit lifecycle event.
 */
export interface OnInit {
    /**
     * This function will be called whenever the game is starting up.
     * This should only be used to setup your object prior to other objects using it.
     *
     * It's safe to load dependencies here, but it is not safe to use them.
     * Yielding or returning a promise will delay initialization of other dependencies.
     */
    onInit(): void | Promise<void>;
}
/**
 * Hook into the OnStart lifecycle event.
 */
export interface OnStart {
    /**
     * This function will be called after the game has been initialized.
     * This function will be called asynchronously.
     */
    onStart(): void;
}
/**
 * Hook into the OnTick lifecycle event.
 * Equivalent to: RunService.Heartbeat
 */
export interface OnTick {
    /**
     * Called every frame, after physics.
     */
    onTick(dt: number): void;
}
/**
 * Hook into the OnPhysics lifecycle event.
 * Equivalent to: RunService.Stepped
 */
export interface OnPhysics {
    /**
     * Called every frame, before physics.
     */
    onPhysics(dt: number, time: number): void;
}
/**
 * Hook into the OnRender lifecycle event.
 * Equivalent to: RunService.RenderStepped
 *
 * @client
 */
export interface OnRender {
    /**
     * Called every frame, before rendering.
     * Only available for controllers.
     */
    onRender(dt: number): void;
}
export {};
