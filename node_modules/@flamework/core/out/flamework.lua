-- Compiled with roblox-ts v1.2.3
local TS = _G[script]
local _services = TS.import(script, TS.getModule(script, "@rbxts", "services"))
local Players = _services.Players
local RunService = _services.RunService
local Reflect = TS.import(script, script.Parent, "reflect").Reflect
local Flamework
local Flamework = {}
do
	local _container = Flamework
	local flameworkConfig = {
		isDefault = true,
	}
	_container.flameworkConfig = flameworkConfig
	_container.isInitialized = false
	local resolvedDependencies = {}
	local loadingList = {}
	-- * @hidden
	local resolveDependency
	local function createDependency(ctor)
		if table.find(loadingList, ctor) ~= nil then
			-- ▼ ReadonlyArray.join ▼
			local _arg0 = " <=> "
			if _arg0 == nil then
				_arg0 = ", "
			end
			local _result = table.create(#loadingList)
			for _k, _v in ipairs(loadingList) do
				_result[_k] = tostring(_v)
			end
			-- ▲ ReadonlyArray.join ▲
			error("Circular dependency detected " .. table.concat(_result, _arg0) .. " <=> " .. tostring(ctor))
		end
		-- ▼ Array.push ▼
		loadingList[#loadingList + 1] = ctor
		-- ▲ Array.push ▲
		local dependencies = Reflect.getMetadata(ctor, "flamework:dependencies")
		local constructorDependencies = {}
		if dependencies then
			for index, dependencyId in pairs(dependencies) do
				local dependency = resolveDependency(dependencyId)
				constructorDependencies[index - 1 + 1] = dependency
			end
		end
		local dependency = ctor.new(unpack(constructorDependencies))
		-- ▼ Array.pop ▼
		loadingList[#loadingList] = nil
		-- ▲ Array.pop ▲
		return dependency
	end
	_container.createDependency = createDependency
	-- * @hidden
	local isConstructor
	function resolveDependency(id)
		local resolvedDependency = resolvedDependencies[id]
		if resolvedDependency ~= nil then
			return resolvedDependency
		end
		local ctor = Reflect.idToObj[id]
		if ctor == nil then
			error("Dependency " .. id .. " could not be found.")
		end
		local _arg0 = isConstructor(ctor)
		assert(_arg0)
		local dependency = createDependency(ctor)
		-- ▼ Map.set ▼
		resolvedDependencies[id] = dependency
		-- ▲ Map.set ▲
		return dependency
	end
	_container.resolveDependency = resolveDependency
	-- * @hidden
	local function _addPaths(...)
		local args = { ... }
		local preloadPaths = {}
		for _, arg in ipairs(args) do
			local service = table.remove(arg, 1)
			local currentPath = game:GetService(service)
			if service == "StarterPlayer" then
				if arg[1] ~= "StarterPlayerScripts" then
					error("StarterPlayer only supports StarterPlayerScripts")
				end
				if not RunService:IsClient() then
					error("The server cannot load StarterPlayer content")
				end
				currentPath = Players.LocalPlayer:WaitForChild("PlayerScripts")
				table.remove(arg, 1)
			end
			do
				local i = 0
				local _shouldIncrement = false
				while true do
					if _shouldIncrement then
						i += 1
					else
						_shouldIncrement = true
					end
					if not (i < #arg) then
						break
					end
					currentPath = currentPath:WaitForChild(arg[i + 1])
				end
			end
			local _currentPath = currentPath
			-- ▼ Array.push ▼
			preloadPaths[#preloadPaths + 1] = _currentPath
			-- ▲ Array.push ▲
		end
		local preload = function(moduleScript)
			local start = os.clock()
			local _success, _valueOrError = pcall(require, moduleScript)
			local result = _success and {
				success = true,
				value = _valueOrError,
			} or {
				success = false,
				error = _valueOrError,
			}
			local endTime = math.floor((os.clock() - start) * 1000)
			if not result.success then
				error(moduleScript:GetFullName() .. " failed to preload (" .. tostring(endTime) .. "ms): " .. result.error)
			end
			print("Preloaded " .. moduleScript:GetFullName() .. " (" .. tostring(endTime) .. "ms)")
		end
		for _, path in ipairs(preloadPaths) do
			if path:IsA("ModuleScript") then
				preload(path)
			end
			for _, instance in ipairs(path:GetDescendants()) do
				if instance:IsA("ModuleScript") then
					preload(instance)
				end
			end
		end
	end
	_container._addPaths = _addPaths
	-- * @hidden
	local function _implements(object, id)
		local _exp = Reflect.getMetadatas(object, "flamework:implements")
		local _arg0 = function(impl)
			return table.find(impl, id) ~= nil
		end
		-- ▼ ReadonlyArray.some ▼
		local _result = false
		for _k, _v in ipairs(_exp) do
			if _arg0(_v, _k - 1, _exp) then
				_result = true
				break
			end
		end
		-- ▲ ReadonlyArray.some ▲
		return _result
	end
	_container._implements = _implements
	function isConstructor(obj)
		return obj.new ~= nil and obj.constructor ~= nil
	end
	local function getDecorator(ctor, configType)
		local decorators = Reflect.getMetadatas(ctor, "flamework:decorators")
		if not decorators then
			return nil
		end
		for _, decoratorIds in ipairs(decorators) do
			for _, decoratorId in ipairs(decoratorIds) do
				local config = Reflect.getMetadata(ctor, "flamework:decorators." .. decoratorId)
				local _result = config
				if _result ~= nil then
					_result = _result.type
				end
				if _result == configType then
					return config
				end
			end
		end
	end
	local function fastSpawn(func)
		local bindable = Instance.new("BindableEvent")
		bindable.Event:Connect(func)
		bindable:Fire()
		bindable:Destroy()
	end
	local externalClasses = {}
	--[[
		*
		* Allow an external module to be bootstrapped by Flamework.ignite()
	]]
	local function registerExternalClass(ctor)
		-- ▼ Set.add ▼
		externalClasses[ctor] = true
		-- ▲ Set.add ▲
	end
	_container.registerExternalClass = registerExternalClass
	local hasFlameworkIgnited = false
	--[[
		*
		* Initialize Flamework.
		*
		* This will start up the lifecycle events on all currently registered
		* classes.
		*
		* You should preload all necessary directories before calling this
		* as newly registered classes will not run their lifecycle events.
		*
		* @returns All the dependencies that have been loaded.
	]]
	local function ignite(patchedConfig)
		if hasFlameworkIgnited then
			error("Flamework.ignite() should only be called once")
		end
		hasFlameworkIgnited = true
		if patchedConfig then
			for key, value in pairs(patchedConfig) do
				flameworkConfig[key] = value
			end
		end
		for ctor, identifier in pairs(Reflect.objToId) do
			if not isConstructor(ctor) then
				continue
			end
			local isPatched = Reflect.getOwnMetadata(ctor, "flamework:isPatched")
			if flameworkConfig.loadOverride and not (table.find(flameworkConfig.loadOverride, ctor) ~= nil) then
				if not isPatched then
					continue
				end
			end
			resolveDependency(identifier)
		end
		local dependencies = {}
		local decoratorType = RunService:IsServer() and "Service" or "Controller"
		for id in pairs(resolvedDependencies) do
			local ctor = Reflect.idToObj[id]
			if ctor == nil then
				error("Could not find constructor for " .. id)
			end
			local decorator = getDecorator(ctor, decoratorType)
			if not decorator then
				continue
			end
			local isExternal = Reflect.getOwnMetadata(ctor, "flamework:isExternal")
			if isExternal and not (externalClasses[ctor] ~= nil) then
				continue
			end
			local dependency = resolveDependency(id)
			local _arg0 = { dependency, decorator }
			-- ▼ Array.push ▼
			dependencies[#dependencies + 1] = _arg0
			-- ▲ Array.push ▲
		end
		local start = {}
		local init = {}
		local tick = {}
		local render = {}
		local physics = {}
		local _arg0 = function(_param, _param_1)
			local a = _param[2]
			local b = _param_1[2]
			local _condition = a.loadOrder
			if _condition == nil then
				_condition = 1
			end
			local _condition_1 = b.loadOrder
			if _condition_1 == nil then
				_condition_1 = 1
			end
			return _condition < _condition_1
		end
		-- ▼ Array.sort ▼
		table.sort(dependencies, _arg0)
		-- ▲ Array.sort ▲
		for _, _binding in ipairs(dependencies) do
			local dependency = _binding[1]
			if Flamework._implements(dependency, "$:flamework@OnInit") then
				-- ▼ Array.push ▼
				init[#init + 1] = dependency
				-- ▲ Array.push ▲
			end
			if Flamework._implements(dependency, "$:flamework@OnStart") then
				-- ▼ Array.push ▼
				start[#start + 1] = dependency
				-- ▲ Array.push ▲
			end
			if Flamework._implements(dependency, "$:flamework@OnTick") then
				-- ▼ Array.push ▼
				tick[#tick + 1] = dependency
				-- ▲ Array.push ▲
			end
			if Flamework._implements(dependency, "$:flamework@OnPhysics") then
				-- ▼ Array.push ▼
				physics[#physics + 1] = dependency
				-- ▲ Array.push ▲
			end
			if Flamework._implements(dependency, "$:flamework@OnRender") then
				-- ▼ Array.push ▼
				render[#render + 1] = dependency
				-- ▲ Array.push ▲
			end
		end
		for _, dependency in ipairs(init) do
			local initResult = dependency:onInit()
			if TS.Promise.is(initResult) then
				initResult:await()
			end
		end
		_container.isInitialized = true
		RunService.Heartbeat:Connect(function(dt)
			for _, dependency in ipairs(tick) do
				coroutine.wrap(function()
					return dependency:onTick(dt)
				end)()
			end
		end)
		RunService.Stepped:Connect(function(time, dt)
			for _, dependency in ipairs(physics) do
				coroutine.wrap(function()
					return dependency:onPhysics(dt, time)
				end)()
			end
		end)
		if RunService:IsClient() then
			RunService.RenderStepped:Connect(function(dt)
				for _, dependency in ipairs(render) do
					coroutine.wrap(function()
						return dependency:onRender(dt)
					end)()
				end
			end)
		end
		for _, dependency in ipairs(start) do
			fastSpawn(function()
				return dependency:onStart()
			end)
		end
		return dependencies
	end
	_container.ignite = ignite
	--[[
		*
		* Preload the specified paths by requiring all ModuleScript descendants.
	]]
	--[[
		*
		* Retrieve the identifier for the specified type.
	]]
	--[[
		*
		* Check if object implements the specified interface.
	]]
	--[[
		*
		* Creates a type guard from any arbitrary type.
	]]
	--[[
		*
		* Hash a function using the method used internally by Flamework.
		* If a context is provided, then Flamework will create a new hash
		* if the specified string does not have one in that context.
		* @param str The string to hash
		* @param context A scope for the hash
	]]
	--[[
		*
		* Utility for use in test suites, not recommended for anything else.
	]]
	local Testing = {}
	do
		local _container_1 = Testing
		local function patchDependency(patchedClass, id)
			if id == nil then
				error("Patching failed, no ID")
			end
			if resolvedDependencies[id] ~= nil then
				error(id .. " has already been resolved, continuing is unsafe")
			end
			local idCtor = Reflect.idToObj[id]
			if idCtor == nil then
				error("Dependency " .. id .. " was not found and cannot be patched.")
			end
			local objMetadata = Reflect.metadata[idCtor]
			if not objMetadata then
				error("Dependency " .. id .. " has no existing metadata.")
			end
			Reflect.defineMetadata(idCtor, "flamework:isPatched", true)
			-- ▼ Map.delete ▼
			Reflect.metadata[idCtor] = nil
			-- ▲ Map.delete ▲
			-- ▼ Map.set ▼
			Reflect.metadata[patchedClass] = objMetadata
			-- ▲ Map.set ▲
			-- ▼ Map.set ▼
			Reflect.objToId[patchedClass] = id
			-- ▲ Map.set ▲
			-- ▼ Map.set ▼
			Reflect.idToObj[id] = patchedClass
			-- ▲ Map.set ▲
		end
		_container_1.patchDependency = patchDependency
	end
	_container.Testing = Testing
end
-- eslint-disable-next-line @typescript-eslint/no-explicit-any
--[[
	*
	* Register a class as a Service.
	*
	* @server
]]
--[[
	*
	* Register a class as a Controller.
	*
	* @client
]]
--[[
	*
	* Marks this class as an external class.
	*
	* External classes are designed for packages and won't be
	* bootstrapped unless explicitly specified. Excluding this
	* inside of a package will make the class load as long as
	* it has been loaded.
]]
--[[
	*
	* Hook into the OnInit lifecycle event.
]]
--[[
	*
	* Hook into the OnStart lifecycle event.
]]
--[[
	*
	* Hook into the OnTick lifecycle event.
	* Equivalent to: RunService.Heartbeat
]]
--[[
	*
	* Hook into the OnPhysics lifecycle event.
	* Equivalent to: RunService.Stepped
]]
--[[
	*
	* Hook into the OnRender lifecycle event.
	* Equivalent to: RunService.RenderStepped
	*
	* @client
]]
return {
	Flamework = Flamework,
}
