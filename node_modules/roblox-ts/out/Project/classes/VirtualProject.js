"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.VirtualProject = void 0;
const byots_1 = __importDefault(require("byots"));
const LuauRenderer_1 = require("../../LuauRenderer");
const VirtualFileSystem_1 = require("./VirtualFileSystem");
const validateCompilerOptions_1 = require("../functions/validateCompilerOptions");
const getCustomPreEmitDiagnostics_1 = require("../util/getCustomPreEmitDiagnostics");
const hasErrors_1 = require("../util/hasErrors");
const PathTranslator_1 = require("../../Shared/classes/PathTranslator");
const RojoResolver_1 = require("../../Shared/classes/RojoResolver");
const constants_1 = require("../../Shared/constants");
const DiagnosticError_1 = require("../../Shared/errors/DiagnosticError");
const assert_1 = require("../../Shared/util/assert");
const TSTransformer_1 = require("../../TSTransformer");
const DiagnosticService_1 = require("../../TSTransformer/classes/DiagnosticService");
const createTransformServices_1 = require("../../TSTransformer/util/createTransformServices");
const PROJECT_DIR = VirtualFileSystem_1.PATH_SEP;
const ROOT_DIR = VirtualFileSystem_1.pathJoin(PROJECT_DIR, "src");
const OUT_DIR = VirtualFileSystem_1.pathJoin(PROJECT_DIR, "out");
const PLAYGROUND_PATH = VirtualFileSystem_1.pathJoin(ROOT_DIR, "playground.tsx");
const NODE_MODULES_PATH = VirtualFileSystem_1.pathJoin(PROJECT_DIR, constants_1.NODE_MODULES);
const RBXTS_SCOPE_PATH = VirtualFileSystem_1.pathJoin(NODE_MODULES_PATH, constants_1.RBXTS_SCOPE);
const INCLUDE_PATH = VirtualFileSystem_1.pathJoin(PROJECT_DIR, "include");
class VirtualProject {
    constructor() {
        this.nodeModulesPathMapping = new Map();
        this.data = {
            includePath: "",
            isPackage: false,
            logTruthyChanges: false,
            nodeModulesPath: NODE_MODULES_PATH,
            noInclude: false,
            pkgVersion: "",
            projectOptions: { includePath: "", rojo: "", type: constants_1.ProjectType.Model },
            projectPath: PROJECT_DIR,
            rojoConfigPath: undefined,
            tsConfigPath: "",
            writeOnlyChanged: false,
            watch: false,
        };
        this.compilerOptions = {
            allowSyntheticDefaultImports: true,
            downlevelIteration: true,
            noLib: true,
            strict: true,
            target: byots_1.default.ScriptTarget.ESNext,
            module: byots_1.default.ModuleKind.CommonJS,
            moduleResolution: byots_1.default.ModuleResolutionKind.NodeJs,
            typeRoots: [RBXTS_SCOPE_PATH],
            resolveJsonModule: true,
            rootDir: ROOT_DIR,
            outDir: OUT_DIR,
            jsx: byots_1.default.JsxEmit.React,
            jsxFactory: "Roact.createElement",
            jsxFragmentFactory: "Roact.Fragment",
        };
        validateCompilerOptions_1.validateCompilerOptions(this.compilerOptions, this.data.nodeModulesPath);
        this.vfs = new VirtualFileSystem_1.VirtualFileSystem();
        const system = {
            getExecutingFilePath: () => __filename,
            getCurrentDirectory: () => "/",
        };
        this.compilerHost = byots_1.default.createCompilerHostWorker(this.compilerOptions, undefined, system);
        this.compilerHost.readFile = filePath => this.vfs.readFile(filePath);
        this.compilerHost.fileExists = filePath => this.vfs.fileExists(filePath);
        this.compilerHost.directoryExists = dirPath => this.vfs.directoryExists(dirPath);
        this.compilerHost.getDirectories = dirPath => this.vfs.getDirectories(dirPath);
        this.compilerHost.useCaseSensitiveFileNames = () => true;
        this.compilerHost.getCurrentDirectory = () => VirtualFileSystem_1.PATH_SEP;
        this.rojoResolver = RojoResolver_1.RojoResolver.fromTree(PROJECT_DIR, {
            $path: OUT_DIR,
            include: {
                $path: INCLUDE_PATH,
                node_modules: {
                    $path: RBXTS_SCOPE_PATH,
                },
            },
        });
        this.pkgRojoResolvers = this.compilerOptions.typeRoots.map(RojoResolver_1.RojoResolver.synthetic);
    }
    compileSource(source) {
        this.vfs.writeFile(PLAYGROUND_PATH, source);
        const rootNames = this.vfs
            .getFilePaths()
            .filter(v => v.endsWith(byots_1.default.Extension.Ts) || v.endsWith(byots_1.default.Extension.Tsx) || v.endsWith(byots_1.default.Extension.Dts));
        this.program = byots_1.default.createProgram(rootNames, this.compilerOptions, this.compilerHost, this.program);
        this.typeChecker = this.program.getDiagnosticsProducingTypeChecker();
        const services = createTransformServices_1.createTransformServices(this.program, this.typeChecker, this.data);
        const pathTranslator = new PathTranslator_1.PathTranslator(ROOT_DIR, OUT_DIR, undefined, false);
        const sourceFile = this.program.getSourceFile(PLAYGROUND_PATH);
        assert_1.assert(sourceFile);
        const diagnostics = new Array();
        diagnostics.push(...getCustomPreEmitDiagnostics_1.getCustomPreEmitDiagnostics(sourceFile));
        if (hasErrors_1.hasErrors(diagnostics))
            throw new DiagnosticError_1.DiagnosticError(diagnostics);
        diagnostics.push(...byots_1.default.getPreEmitDiagnostics(this.program, sourceFile));
        if (hasErrors_1.hasErrors(diagnostics))
            throw new DiagnosticError_1.DiagnosticError(diagnostics);
        const multiTransformState = new TSTransformer_1.MultiTransformState();
        const runtimeLibRbxPath = undefined;
        const projectType = this.data.projectOptions.type;
        const transformState = new TSTransformer_1.TransformState(this.data, services, pathTranslator, multiTransformState, this.compilerOptions, this.rojoResolver, this.pkgRojoResolvers, this.nodeModulesPathMapping, new Map(), runtimeLibRbxPath, this.typeChecker, projectType, sourceFile);
        const luaAST = TSTransformer_1.transformSourceFile(transformState, sourceFile);
        diagnostics.push(...DiagnosticService_1.DiagnosticService.flush());
        if (hasErrors_1.hasErrors(diagnostics))
            throw new DiagnosticError_1.DiagnosticError(diagnostics);
        const luaSource = LuauRenderer_1.renderAST(luaAST);
        return luaSource;
    }
    setMapping(typings, main) {
        this.nodeModulesPathMapping.set(typings, main);
    }
}
exports.VirtualProject = VirtualProject;
//# sourceMappingURL=VirtualProject.js.map