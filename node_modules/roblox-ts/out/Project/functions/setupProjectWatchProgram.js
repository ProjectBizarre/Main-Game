"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.setupProjectWatchProgram = void 0;
const byots_1 = __importDefault(require("byots"));
const chokidar_1 = __importDefault(require("chokidar"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const cleanup_1 = require("./cleanup");
const compileFiles_1 = require("./compileFiles");
const copyFiles_1 = require("./copyFiles");
const copyInclude_1 = require("./copyInclude");
const copyItem_1 = require("./copyItem");
const createPathTranslator_1 = require("./createPathTranslator");
const createProgramFactory_1 = require("./createProgramFactory");
const getChangedSourceFiles_1 = require("./getChangedSourceFiles");
const getParsedCommandLine_1 = require("./getParsedCommandLine");
const tryRemoveOutput_1 = require("./tryRemoveOutput");
const hasErrors_1 = require("../util/hasErrors");
const isCompilableFile_1 = require("../util/isCompilableFile");
const walkDirectorySync_1 = require("../util/walkDirectorySync");
const DiagnosticError_1 = require("../../Shared/errors/DiagnosticError");
const assert_1 = require("../../Shared/util/assert");
const getRootDirs_1 = require("../../Shared/util/getRootDirs");
const CHOKIDAR_OPTIONS = {
    awaitWriteFinish: {
        pollInterval: 10,
        stabilityThreshold: 50,
    },
    ignoreInitial: true,
    disableGlobbing: true,
};
function fixSlashes(fsPath) {
    return fsPath.replace(/\\/g, "/");
}
function setupProjectWatchProgram(data, usePolling) {
    const { fileNames, options } = getParsedCommandLine_1.getParsedCommandLine(data);
    const fileNamesSet = new Set(fileNames);
    let initialCompileCompleted = false;
    let collecting = false;
    let filesToAdd = new Set();
    let filesToChange = new Set();
    let filesToDelete = new Set();
    const watchReporter = byots_1.default.createWatchStatusReporter(byots_1.default.sys, true);
    const diagnosticReporter = byots_1.default.createDiagnosticReporter(byots_1.default.sys, true);
    function reportText(messageText) {
        watchReporter({
            category: byots_1.default.DiagnosticCategory.Message,
            messageText,
            code: 0,
            file: undefined,
            length: undefined,
            start: undefined,
        }, byots_1.default.sys.newLine, options);
    }
    function reportEmitResult(emitResult) {
        for (const diagnostic of emitResult.diagnostics) {
            diagnosticReporter(diagnostic);
        }
        const amtErrors = emitResult.diagnostics.filter(v => v.category === byots_1.default.DiagnosticCategory.Error).length;
        reportText(`Found ${amtErrors} error${amtErrors === 1 ? "" : "s"}. Watching for file changes.`);
    }
    let program;
    let pathTranslator;
    const createProgram = createProgramFactory_1.createProgramFactory(data, options);
    function refreshProgram() {
        try {
            program = createProgram([...fileNamesSet], options);
            pathTranslator = createPathTranslator_1.createPathTranslator(program);
        }
        catch (e) {
            if (e instanceof DiagnosticError_1.DiagnosticError) {
                for (const diagnostic of e.diagnostics) {
                    diagnosticReporter(diagnostic);
                }
            }
            else {
                throw e;
            }
        }
    }
    function runInitialCompile() {
        refreshProgram();
        assert_1.assert(program && pathTranslator);
        cleanup_1.cleanup(pathTranslator);
        copyInclude_1.copyInclude(data);
        copyFiles_1.copyFiles(data, pathTranslator, new Set(getRootDirs_1.getRootDirs(options)));
        const sourceFiles = getChangedSourceFiles_1.getChangedSourceFiles(program);
        const emitResult = compileFiles_1.compileFiles(program.getProgram(), data, pathTranslator, sourceFiles);
        if (!hasErrors_1.hasErrors(emitResult.diagnostics)) {
            initialCompileCompleted = true;
        }
        return emitResult;
    }
    function runIncrementalCompile(additions, changes, removals) {
        const filesToCompile = new Set();
        const filesToCopy = new Set();
        const filesToClean = new Set();
        for (const fsPath of additions) {
            if (isCompilableFile_1.isCompilableFile(fsPath)) {
                fileNamesSet.add(fsPath);
                filesToCompile.add(fsPath);
            }
            else {
                filesToCopy.add(fsPath);
            }
            if (fs_extra_1.default.statSync(fsPath).isDirectory()) {
                walkDirectorySync_1.walkDirectorySync(fsPath, item => {
                    if (isCompilableFile_1.isCompilableFile(item)) {
                        filesToCompile.add(item);
                    }
                });
            }
        }
        for (const fsPath of changes) {
            if (isCompilableFile_1.isCompilableFile(fsPath)) {
                filesToCompile.add(fsPath);
            }
            else {
                filesToCopy.add(fsPath);
            }
        }
        for (const fsPath of removals) {
            fileNamesSet.delete(fsPath);
            filesToClean.add(fsPath);
        }
        refreshProgram();
        assert_1.assert(program && pathTranslator);
        for (const fsPath of filesToClean) {
            tryRemoveOutput_1.tryRemoveOutput(pathTranslator, pathTranslator.getOutputPath(fsPath));
            if (options.declaration) {
                tryRemoveOutput_1.tryRemoveOutput(pathTranslator, pathTranslator.getOutputDeclarationPath(fsPath));
            }
        }
        for (const fsPath of filesToCopy) {
            copyItem_1.copyItem(data, pathTranslator, fsPath);
        }
        const sourceFiles = getChangedSourceFiles_1.getChangedSourceFiles(program, options.incremental ? undefined : [...filesToCompile]);
        const emitResult = compileFiles_1.compileFiles(program.getProgram(), data, pathTranslator, sourceFiles);
        return emitResult;
    }
    function closeEventCollection() {
        collecting = false;
        const additions = filesToAdd;
        const changes = filesToChange;
        const removals = filesToDelete;
        filesToAdd = new Set();
        filesToChange = new Set();
        filesToDelete = new Set();
        const emitResult = !initialCompileCompleted
            ? runInitialCompile()
            : runIncrementalCompile(additions, changes, removals);
        reportEmitResult(emitResult);
    }
    function openEventCollection() {
        if (!collecting) {
            collecting = true;
            reportText("File change detected. Starting incremental compilation...");
            setTimeout(closeEventCollection, 100);
        }
    }
    function collectAddEvent(fsPath) {
        filesToAdd.add(fixSlashes(fsPath));
        openEventCollection();
    }
    function collectChangeEvent(fsPath) {
        filesToChange.add(fixSlashes(fsPath));
        openEventCollection();
    }
    function collectDeleteEvent(fsPath) {
        filesToDelete.add(fixSlashes(fsPath));
        openEventCollection();
    }
    const chokidarOptions = { ...CHOKIDAR_OPTIONS, usePolling };
    chokidar_1.default
        .watch(getRootDirs_1.getRootDirs(options), chokidarOptions)
        .on("add", collectAddEvent)
        .on("addDir", collectAddEvent)
        .on("change", collectChangeEvent)
        .on("unlink", collectDeleteEvent)
        .on("unlinkDir", collectDeleteEvent);
    reportText("Starting compilation in watch mode...");
    reportEmitResult(runInitialCompile());
}
exports.setupProjectWatchProgram = setupProjectWatchProgram;
//# sourceMappingURL=setupProjectWatchProgram.js.map