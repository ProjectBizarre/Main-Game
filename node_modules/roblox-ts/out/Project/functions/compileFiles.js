"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.compileFiles = void 0;
const byots_1 = __importDefault(require("byots"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const LuauRenderer_1 = require("../../LuauRenderer");
const path_1 = __importDefault(require("path"));
const checkRojoConfig_1 = require("./checkRojoConfig");
const createNodeModulesPathMapping_1 = require("./createNodeModulesPathMapping");
const transformPaths_1 = require("../transformers/builtin/transformPaths");
const transformTypeReferenceDirectives_1 = require("../transformers/builtin/transformTypeReferenceDirectives");
const createTransformerList_1 = require("../transformers/createTransformerList");
const createTransformerWatcher_1 = require("../transformers/createTransformerWatcher");
const getPluginConfigs_1 = require("../transformers/getPluginConfigs");
const getCustomPreEmitDiagnostics_1 = require("../util/getCustomPreEmitDiagnostics");
const hasErrors_1 = require("../util/hasErrors");
const LogService_1 = require("../../Shared/classes/LogService");
const RojoResolver_1 = require("../../Shared/classes/RojoResolver");
const constants_1 = require("../../Shared/constants");
const assert_1 = require("../../Shared/util/assert");
const benchmark_1 = require("../../Shared/util/benchmark");
const createTextDiagnostic_1 = require("../../Shared/util/createTextDiagnostic");
const getRootDirs_1 = require("../../Shared/util/getRootDirs");
const TSTransformer_1 = require("../../TSTransformer");
const DiagnosticService_1 = require("../../TSTransformer/classes/DiagnosticService");
const createTransformServices_1 = require("../../TSTransformer/util/createTransformServices");
function inferProjectType(data, rojoResolver) {
    if (data.isPackage) {
        return constants_1.ProjectType.Package;
    }
    else if (rojoResolver.isGame) {
        return constants_1.ProjectType.Game;
    }
    else {
        return constants_1.ProjectType.Model;
    }
}
function emitResultFailure(messageText) {
    return {
        emitSkipped: false,
        diagnostics: [createTextDiagnostic_1.createTextDiagnostic(messageText)],
    };
}
function getReverseSymlinkMap(program) {
    const getCanonicalFileName = byots_1.default.createGetCanonicalFileName(byots_1.default.sys.useCaseSensitiveFileNames);
    const symlinkCache = byots_1.default.discoverProbableSymlinks(program.getSourceFiles(), getCanonicalFileName, byots_1.default.sys.getCurrentDirectory());
    const directoriesMap = symlinkCache.getSymlinkedDirectories();
    const result = new Map();
    if (directoriesMap) {
        directoriesMap.forEach((dir, fsPath) => {
            if (typeof dir !== "boolean") {
                result.set(dir.real, fsPath);
            }
        });
    }
    return result;
}
function compileFiles(program, data, pathTranslator, sourceFiles) {
    var _a;
    const compilerOptions = program.getCompilerOptions();
    const multiTransformState = new TSTransformer_1.MultiTransformState();
    const outDir = compilerOptions.outDir;
    const rojoResolver = data.rojoConfigPath
        ? RojoResolver_1.RojoResolver.fromPath(data.rojoConfigPath)
        : RojoResolver_1.RojoResolver.synthetic(outDir);
    checkRojoConfig_1.checkRojoConfig(data, rojoResolver, getRootDirs_1.getRootDirs(compilerOptions), pathTranslator);
    const pkgRojoResolvers = compilerOptions.typeRoots.map(RojoResolver_1.RojoResolver.synthetic);
    const nodeModulesPathMapping = createNodeModulesPathMapping_1.createNodeModulesPathMapping(compilerOptions.typeRoots);
    const reverseSymlinkMap = getReverseSymlinkMap(program);
    const projectType = (_a = data.projectOptions.type) !== null && _a !== void 0 ? _a : inferProjectType(data, rojoResolver);
    if (projectType !== constants_1.ProjectType.Package && data.rojoConfigPath === undefined) {
        return emitResultFailure("Non-package projects must have a Rojo project file!");
    }
    let runtimeLibRbxPath;
    if (projectType !== constants_1.ProjectType.Package) {
        runtimeLibRbxPath = rojoResolver.getRbxPathFromFilePath(path_1.default.join(data.includePath, "RuntimeLib.lua"));
        if (!runtimeLibRbxPath) {
            return emitResultFailure("Rojo project contained no data for include folder!");
        }
        else if (rojoResolver.getNetworkType(runtimeLibRbxPath) !== RojoResolver_1.NetworkType.Unknown) {
            return emitResultFailure("Runtime library cannot be in a server-only or client-only container!");
        }
        else if (rojoResolver.isIsolated(runtimeLibRbxPath)) {
            return emitResultFailure("Runtime library cannot be in an isolated container!");
        }
    }
    if (projectType !== constants_1.ProjectType.Package &&
        !rojoResolver.getRbxPathFromFilePath(path_1.default.join(data.nodeModulesPath, constants_1.RBXTS_SCOPE))) {
        return emitResultFailure("Rojo project contained no data for node_modules/@rbxts folder!");
    }
    LogService_1.LogService.writeLineIfVerbose(`compiling as ${projectType}..`);
    const diagnostics = new Array();
    const fileWriteQueue = new Array();
    const progressMaxLength = `${sourceFiles.length}/${sourceFiles.length}`.length;
    let proxyProgram = program;
    if (compilerOptions.plugins && compilerOptions.plugins.length > 0) {
        benchmark_1.benchmarkIfVerbose(`running transformers..`, () => {
            const pluginConfigs = getPluginConfigs_1.getPluginConfigs(data.tsConfigPath);
            const transformerList = createTransformerList_1.createTransformerList(program, pluginConfigs, data.projectPath);
            const transformers = createTransformerList_1.flattenIntoTransformers(transformerList);
            if (transformers.length > 0) {
                if (!data.transformerWatcher) {
                    data.transformerWatcher = createTransformerWatcher_1.createTransformerWatcher(program);
                }
                const { service, updateFile } = data.transformerWatcher;
                const transformResult = byots_1.default.transformNodes(undefined, undefined, byots_1.default.factory, compilerOptions, sourceFiles, transformers, false);
                if (transformResult.diagnostics)
                    diagnostics.push(...transformResult.diagnostics);
                for (const sourceFile of transformResult.transformed) {
                    if (byots_1.default.isSourceFile(sourceFile)) {
                        updateFile(sourceFile.fileName, byots_1.default.createPrinter().printFile(sourceFile));
                    }
                }
                proxyProgram = service.getProgram();
            }
        });
    }
    if (hasErrors_1.hasErrors(diagnostics))
        return { emitSkipped: true, diagnostics };
    const typeChecker = proxyProgram.getDiagnosticsProducingTypeChecker();
    const services = createTransformServices_1.createTransformServices(proxyProgram, typeChecker, data);
    for (let i = 0; i < sourceFiles.length; i++) {
        const sourceFile = proxyProgram.getSourceFile(sourceFiles[i].fileName);
        assert_1.assert(sourceFile);
        const progress = `${i + 1}/${sourceFiles.length}`.padStart(progressMaxLength);
        benchmark_1.benchmarkIfVerbose(`${progress} compile ${path_1.default.relative(process.cwd(), sourceFile.fileName)}`, () => {
            diagnostics.push(...getCustomPreEmitDiagnostics_1.getCustomPreEmitDiagnostics(sourceFile));
            if (hasErrors_1.hasErrors(diagnostics))
                return;
            diagnostics.push(...byots_1.default.getPreEmitDiagnostics(proxyProgram, sourceFile));
            if (hasErrors_1.hasErrors(diagnostics))
                return;
            const transformState = new TSTransformer_1.TransformState(data, services, pathTranslator, multiTransformState, compilerOptions, rojoResolver, pkgRojoResolvers, nodeModulesPathMapping, reverseSymlinkMap, runtimeLibRbxPath, typeChecker, projectType, sourceFile);
            const luauAST = TSTransformer_1.transformSourceFile(transformState, sourceFile);
            diagnostics.push(...DiagnosticService_1.DiagnosticService.flush());
            if (hasErrors_1.hasErrors(diagnostics))
                return;
            const source = LuauRenderer_1.renderAST(luauAST);
            fileWriteQueue.push({ sourceFile, source });
        });
    }
    if (hasErrors_1.hasErrors(diagnostics))
        return { emitSkipped: false, diagnostics };
    if (fileWriteQueue.length > 0) {
        benchmark_1.benchmarkIfVerbose("writing compiled files", () => {
            for (const { sourceFile, source } of fileWriteQueue) {
                const outPath = pathTranslator.getOutputPath(sourceFile.fileName);
                if (!data.writeOnlyChanged ||
                    !fs_extra_1.default.pathExistsSync(outPath) ||
                    fs_extra_1.default.readFileSync(outPath).toString() !== source) {
                    fs_extra_1.default.outputFileSync(outPath, source);
                }
                if (compilerOptions.declaration) {
                    program.emit(sourceFile, byots_1.default.sys.writeFile, undefined, true, {
                        afterDeclarations: [transformTypeReferenceDirectives_1.transformTypeReferenceDirectives, transformPaths_1.transformPaths],
                    });
                }
            }
        });
    }
    program.emitBuildInfo();
    return { emitSkipped: false, diagnostics };
}
exports.compileFiles = compileFiles;
//# sourceMappingURL=compileFiles.js.map