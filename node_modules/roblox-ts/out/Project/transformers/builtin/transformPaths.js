"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformPaths = exports.normalizePath = void 0;
const byots_1 = __importDefault(require("byots"));
const fs_1 = require("fs");
const path_1 = require("path");
const assert_1 = require("../../../Shared/util/assert");
const url_1 = require("url");
const normalizePath = (p) => /^\\\\\?\\/.test(p) || /[^\u0000-\u0080]+/.test(p)
    ? p
    :
        p.replace(/[\\\/]+/g, "/");
exports.normalizePath = normalizePath;
const transformPaths = (context) => (sourceFile) => {
    var _a, _b;
    assert_1.assert(byots_1.default.isSourceFile(sourceFile));
    const resolver = typeof context.getEmitResolver === "function" ? context.getEmitResolver() : undefined;
    const compilerOptions = context.getCompilerOptions();
    const sourceDir = path_1.dirname(sourceFile.fileName);
    const implicitExtensions = [".ts", ".d.ts"];
    const allowJs = compilerOptions.allowJs === true;
    const allowJsx = compilerOptions.jsx !== undefined && compilerOptions.jsx !== byots_1.default.JsxEmit.None;
    const allowJson = compilerOptions.resolveJsonModule === true;
    allowJs && implicitExtensions.push(".js");
    allowJsx && implicitExtensions.push(".tsx");
    allowJs && allowJsx && implicitExtensions.push(".jsx");
    allowJson && implicitExtensions.push(".json");
    const { isDeclarationFile } = sourceFile;
    const { baseUrl = "", paths = {} } = compilerOptions;
    paths["*"] = (_b = (_a = paths["*"]) === null || _a === void 0 ? void 0 : _a.concat("*")) !== null && _b !== void 0 ? _b : ["*"];
    const binds = Object.keys(paths)
        .filter(key => paths[key].length)
        .map(key => ({
        regexp: new RegExp("^" + key.replace("*", "(.*)") + "$"),
        paths: paths[key],
    }));
    if (!baseUrl || binds.length === 0) {
        return sourceFile;
    }
    function isRelative(s) {
        return s[0] === ".";
    }
    function isUrl(s) {
        return url_1.parse(s).protocol !== null;
    }
    function fileExists(s) {
        for (const ext of implicitExtensions)
            if (fs_1.existsSync(s + ext))
                return true;
        if (path_1.extname(s) !== "")
            return fs_1.existsSync(s);
        return false;
    }
    function bindModuleToFile(moduleName) {
        if (isRelative(moduleName)) {
            return moduleName;
        }
        for (const { regexp, paths } of binds) {
            const match = regexp.exec(moduleName);
            if (match) {
                for (const p of paths) {
                    const out = p.replace(/\*/g, match[1]);
                    if (isUrl(out))
                        return out;
                    const filepath = path_1.resolve(baseUrl, out);
                    if (!fileExists(`${filepath}/index`) && !fileExists(filepath))
                        continue;
                    const resolved = fixupImportPath(path_1.relative(sourceDir, filepath));
                    return isRelative(resolved) ? resolved : `./${resolved}`;
                }
            }
        }
        return undefined;
    }
    const isRequire = (node) => byots_1.default.isCallExpression(node) &&
        byots_1.default.isIdentifier(node.expression) &&
        node.expression.text === "require" &&
        byots_1.default.isStringLiteral(node.arguments[0]) &&
        node.arguments.length === 1;
    const isAsyncImport = (node) => byots_1.default.isCallExpression(node) &&
        node.expression.kind === byots_1.default.SyntaxKind.ImportKeyword &&
        byots_1.default.isStringLiteral(node.arguments[0]) &&
        node.arguments.length === 1;
    function visit(node) {
        if (isRequire(node) || isAsyncImport(node)) {
            return unpathRequireAndAsyncImport(node);
        }
        if (byots_1.default.isExternalModuleReference(node)) {
            return unpathImportEqualsDeclaration(node);
        }
        if (byots_1.default.isImportDeclaration(node)) {
            return unpathImportDeclaration(node);
        }
        if (byots_1.default.isExportDeclaration(node)) {
            return unpathExportDeclaration(node);
        }
        if (byots_1.default.isImportTypeNode(node)) {
            return unpathImportTypeNode(node);
        }
        return byots_1.default.visitEachChild(node, visit, context);
    }
    function unpathRequireAndAsyncImport(node) {
        const firstArg = node.arguments[0];
        const file = bindModuleToFile(firstArg.text);
        if (!file) {
            return node;
        }
        const fileLiteral = byots_1.default.createLiteral(file);
        return byots_1.default.updateCall(node, node.expression, node.typeArguments, [fileLiteral]);
    }
    function unpathImportTypeNode(node) {
        const argument = node.argument;
        const literal = argument.literal;
        if (!byots_1.default.isStringLiteral(literal)) {
            return node;
        }
        const file = bindModuleToFile(literal.text);
        if (!file) {
            return node;
        }
        const fileLiteral = byots_1.default.createLiteral(file);
        const fileArgument = byots_1.default.updateLiteralTypeNode(argument, fileLiteral);
        return byots_1.default.updateImportTypeNode(node, fileArgument, node.qualifier, node.typeArguments, node.isTypeOf);
    }
    function unpathImportEqualsDeclaration(node) {
        if (!byots_1.default.isStringLiteral(node.expression)) {
            return node;
        }
        const file = bindModuleToFile(node.expression.text);
        if (!file) {
            return node;
        }
        const fileLiteral = byots_1.default.createLiteral(file);
        return byots_1.default.updateExternalModuleReference(node, fileLiteral);
    }
    function unpathImportDeclaration(node) {
        if (!byots_1.default.isStringLiteral(node.moduleSpecifier)) {
            return node;
        }
        const file = bindModuleToFile(node.moduleSpecifier.text);
        if (!file) {
            return node;
        }
        const fileLiteral = byots_1.default.createLiteral(file);
        const importClause = byots_1.default.visitNode(node.importClause, visitImportClause, byots_1.default.isImportClause);
        return node.importClause === importClause || importClause || isDeclarationFile
            ? byots_1.default.updateImportDeclaration(node, node.decorators, node.modifiers, node.importClause, fileLiteral)
            : undefined;
    }
    function visitImportClause(node) {
        const name = resolver.isReferencedAliasDeclaration(node) ? node.name : undefined;
        const namedBindings = byots_1.default.visitNode(node.namedBindings, visitNamedImportBindings, byots_1.default.isNamedImports);
        return name || namedBindings ? byots_1.default.updateImportClause(node, name, namedBindings, node.isTypeOnly) : undefined;
    }
    function visitNamedImportBindings(node) {
        if (node.kind === byots_1.default.SyntaxKind.NamespaceImport) {
            return resolver.isReferencedAliasDeclaration(node) ? node : undefined;
        }
        else {
            const elements = byots_1.default.visitNodes(node.elements, visitImportSpecifier, byots_1.default.isImportSpecifier);
            return elements.some(e => e) ? byots_1.default.updateNamedImports(node, elements) : undefined;
        }
    }
    function visitImportSpecifier(node) {
        return resolver.isReferencedAliasDeclaration(node) ? node : undefined;
    }
    function unpathExportDeclaration(node) {
        if (!node.moduleSpecifier || !byots_1.default.isStringLiteral(node.moduleSpecifier)) {
            return node;
        }
        const file = bindModuleToFile(node.moduleSpecifier.text);
        if (!file) {
            return node;
        }
        const fileLiteral = byots_1.default.createLiteral(file);
        if ((!node.exportClause &&
            !compilerOptions.isolatedModules &&
            !resolver.moduleExportsSomeValue(node.moduleSpecifier)) ||
            (node.exportClause && resolver.isValueAliasDeclaration(node))) {
            return byots_1.default.updateExportDeclaration(node, node.decorators, node.modifiers, node.exportClause, fileLiteral, node.isTypeOnly);
        }
        const exportClause = byots_1.default.visitNode(node.exportClause, visitNamedExports, byots_1.default.isNamedExports);
        return node.exportClause === exportClause || exportClause || isDeclarationFile
            ? byots_1.default.updateExportDeclaration(node, node.decorators, node.modifiers, node.exportClause, fileLiteral, node.isTypeOnly)
            : undefined;
    }
    function visitNamedExports(node) {
        const elements = byots_1.default.visitNodes(node.elements, visitExportSpecifier, byots_1.default.isExportSpecifier);
        return elements.some(e => e) ? byots_1.default.updateNamedExports(node, elements) : undefined;
    }
    function visitExportSpecifier(node) {
        return resolver.isValueAliasDeclaration(node) ? node : undefined;
    }
    function fixupImportPath(p) {
        let res = exports.normalizePath(p);
        const ext = path_1.extname(res);
        if (ext && implicitExtensions.includes(ext.replace(/^\./, "")))
            res = res.slice(0, -ext.length);
        return res;
    }
    return byots_1.default.visitNode(sourceFile, visit);
};
exports.transformPaths = transformPaths;
//# sourceMappingURL=transformPaths.js.map