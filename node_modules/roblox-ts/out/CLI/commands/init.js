"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const byots_1 = __importDefault(require("byots"));
const child_process_1 = require("child_process");
const build_1 = __importDefault(require("./build"));
const CLIError_1 = require("../errors/CLIError");
const fs_extra_1 = __importDefault(require("fs-extra"));
const kleur_1 = __importDefault(require("kleur"));
const lookpath_1 = require("lookpath");
const path_1 = __importDefault(require("path"));
const prompts_1 = __importDefault(require("prompts"));
const constants_1 = require("../../Shared/constants");
const benchmark_1 = require("../../Shared/util/benchmark");
const yargs_1 = __importDefault(require("yargs"));
var InitMode;
(function (InitMode) {
    InitMode["None"] = "none";
    InitMode["Game"] = "game";
    InitMode["Place"] = "place";
    InitMode["Model"] = "model";
    InitMode["Plugin"] = "plugin";
    InitMode["Package"] = "package";
})(InitMode || (InitMode = {}));
var PackageManager;
(function (PackageManager) {
    PackageManager["NPM"] = "npm";
    PackageManager["Yarn"] = "yarn";
    PackageManager["PNPM"] = "pnpm";
})(PackageManager || (PackageManager = {}));
const packageManagerCommands = {
    [PackageManager.NPM]: {
        init: "npm init -y",
        devInstall: "npm install --silent -D",
        build: "npm run build",
    },
    [PackageManager.Yarn]: {
        init: "yarn init -y",
        devInstall: "yarn add --silent -D",
        build: "yarn run build",
    },
    [PackageManager.PNPM]: {
        init: "pnpm init -y",
        devInstall: "pnpm install --silent -D",
        build: "pnpm run build",
    },
};
function cmd(cmdStr) {
    return new Promise((resolve, reject) => {
        child_process_1.exec(cmdStr, (error, stdout) => {
            if (error) {
                reject(error);
            }
            resolve(stdout);
        });
    }).catch((error) => {
        throw new CLIError_1.CLIError(`Command "${error.cmd}" exited with code ${error.code}\n\n${error.message}`);
    });
}
function getNonDevCompilerVersion() {
    var _a, _b;
    return (_b = (_a = constants_1.COMPILER_VERSION.match(/^(.+)-dev.+$/)) === null || _a === void 0 ? void 0 : _a[1]) !== null && _b !== void 0 ? _b : constants_1.COMPILER_VERSION;
}
const TEMPLATE_DIR = path_1.default.join(constants_1.PACKAGE_ROOT, "templates");
const GIT_IGNORE = ["/node_modules", "/out", "/include", "*.tsbuildinfo"];
async function init(argv, mode) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    const cwd = process.cwd();
    const paths = {
        packageJson: path_1.default.join(cwd, "package.json"),
        packageLockJson: path_1.default.join(cwd, "package-lock.json"),
        projectJson: path_1.default.join(cwd, "default.project.json"),
        serveProjectJson: mode === InitMode.Plugin && path_1.default.join(cwd, "serve.project.json"),
        src: path_1.default.join(cwd, "src"),
        tsconfig: path_1.default.join(cwd, "tsconfig.json"),
        gitignore: path_1.default.join(cwd, ".gitignore"),
        eslintrc: path_1.default.join(cwd, ".eslintrc.json"),
        settings: path_1.default.join(cwd, ".vscode", "settings.json"),
        extensions: path_1.default.join(cwd, ".vscode", "extensions.json"),
    };
    const existingPaths = new Array();
    for (const filePath of Object.values(paths)) {
        if (filePath && (await fs_extra_1.default.pathExists(filePath))) {
            const stat = await fs_extra_1.default.stat(filePath);
            if (stat.isFile() || (await fs_extra_1.default.readdir(filePath)).length > 0) {
                existingPaths.push(path_1.default.relative(cwd, filePath));
            }
        }
    }
    if (existingPaths.length > 0) {
        const pathInfo = existingPaths.map(v => `  - ${kleur_1.default.yellow(v)}\n`).join("");
        throw new CLIError_1.CLIError(`Cannot initialize project, process could overwrite:\n${pathInfo}`);
    }
    if (mode === InitMode.None) {
        mode = (await prompts_1.default({
            type: "select",
            name: "template",
            message: "Select template",
            choices: [InitMode.Game, InitMode.Model, InitMode.Plugin, InitMode.Package].map(value => ({
                title: value,
                value,
            })),
            initial: 0,
        })).template;
        if (mode === undefined) {
            return;
        }
    }
    const packageManagerExistance = {
        [PackageManager.NPM]: true,
        [PackageManager.PNPM]: (await lookpath_1.lookpath("pnpm")) ? true : false,
        [PackageManager.Yarn]: (await lookpath_1.lookpath("yarn")) ? true : false,
    };
    const packageManagerCount = Object.values(packageManagerExistance).filter(exists => exists).length;
    const { git = (_b = (_a = argv.git) !== null && _a !== void 0 ? _a : argv.yes) !== null && _b !== void 0 ? _b : false, eslint = (_d = (_c = argv.eslint) !== null && _c !== void 0 ? _c : argv.yes) !== null && _d !== void 0 ? _d : false, prettier = (_f = (_e = argv.prettier) !== null && _e !== void 0 ? _e : argv.yes) !== null && _f !== void 0 ? _f : false, vscode = (_h = (_g = argv.vscode) !== null && _g !== void 0 ? _g : argv.yes) !== null && _h !== void 0 ? _h : false, packageManager = (_j = argv.packageManager) !== null && _j !== void 0 ? _j : PackageManager.NPM, } = await prompts_1.default([
        {
            type: () => argv.git === undefined && argv.yes === undefined && "confirm",
            name: "git",
            message: "Configure Git",
            initial: true,
        },
        {
            type: () => argv.eslint === undefined && argv.yes === undefined && "confirm",
            name: "eslint",
            message: "Configure ESLint",
            initial: true,
        },
        {
            type: (_, values) => (argv.eslint || values.eslint) && argv.prettier === undefined && argv.yes === undefined && "confirm",
            name: "prettier",
            message: "Configure Prettier",
            initial: true,
        },
        {
            type: () => argv.vscode === undefined && argv.yes === undefined && "confirm",
            name: "vscode",
            message: "Configure VSCode Project Settings",
            initial: true,
        },
        {
            type: () => argv.packageManager === undefined && packageManagerCount > 1 && argv.yes === undefined && "select",
            name: "packageManager",
            message: "Multiple package managers detected. Select package manager:",
            choices: Object.entries(PackageManager)
                .filter(([, packageManager]) => packageManagerExistance[packageManager])
                .map(([managerDisplayName, managerEnum]) => ({
                title: managerDisplayName,
                value: managerEnum,
            })),
        },
    ]);
    await benchmark_1.benchmark("Initializing..", async () => {
        const selectedPackageManager = packageManagerCommands[packageManager];
        await cmd(selectedPackageManager.init);
        const pkgJson = await fs_extra_1.default.readJson(paths.packageJson);
        pkgJson.scripts = {
            build: "rbxtsc",
            watch: "rbxtsc -w",
        };
        if (mode === InitMode.Package) {
            pkgJson.name = constants_1.RBXTS_SCOPE + "/" + pkgJson.name;
            pkgJson.main = "out/init.lua";
            pkgJson.types = "out/index.d.ts";
            pkgJson.files = ["out"];
            pkgJson.publishConfig = {
                access: "public",
            };
            pkgJson.scripts.prepublishOnly = selectedPackageManager.build;
        }
        await fs_extra_1.default.outputFile(paths.packageJson, JSON.stringify(pkgJson, null, 2));
        if (git) {
            try {
                await cmd("git init");
            }
            catch (error) {
                if (!(error instanceof CLIError_1.CLIError))
                    throw error;
                throw new CLIError_1.CLIError(`${error.diagnostics[0].messageText}\nDo you not have Git installed? Git CLI is required to use Git functionality. If you do not wish to use Git, answer no to "Configure Git".`);
            }
            await fs_extra_1.default.outputFile(paths.gitignore, GIT_IGNORE.join("\n") + "\n");
        }
        const devDependencies = ["@rbxts/types", `@rbxts/compiler-types@compiler-${getNonDevCompilerVersion()}`];
        if (eslint) {
            devDependencies.push("eslint", "typescript", "@typescript-eslint/eslint-plugin", "@typescript-eslint/parser", "eslint-plugin-roblox-ts");
            if (prettier) {
                devDependencies.push("prettier", "eslint-config-prettier", "eslint-plugin-prettier");
            }
        }
        await cmd(`${selectedPackageManager.devInstall} ${devDependencies.join(" ")}`);
        if (eslint) {
            const eslintConfig = {
                parser: "@typescript-eslint/parser",
                parserOptions: {
                    jsx: true,
                    useJSXTextNode: true,
                    ecmaVersion: 2018,
                    sourceType: "module",
                    project: "./tsconfig.json",
                },
                plugins: ["@typescript-eslint", "roblox-ts"],
                extends: ["plugin:@typescript-eslint/recommended", "plugin:roblox-ts/recommended"],
                rules: byots_1.default.identity({}),
            };
            if (prettier) {
                eslintConfig.plugins.push("prettier");
                eslintConfig.extends.push("plugin:prettier/recommended");
                eslintConfig.rules["prettier/prettier"] = [
                    "warn",
                    {
                        semi: true,
                        trailingComma: "all",
                        singleQuote: false,
                        printWidth: 120,
                        tabWidth: 4,
                        useTabs: true,
                    },
                ];
            }
            await fs_extra_1.default.outputFile(paths.eslintrc, JSON.stringify(eslintConfig, undefined, "\t"));
        }
        if (vscode) {
            const extensions = {
                recommendations: ["roblox-ts.vscode-roblox-ts"],
            };
            if (eslint) {
                const settings = {
                    "[typescript]": {
                        "editor.defaultFormatter": "dbaeumer.vscode-eslint",
                        "editor.formatOnSave": true,
                    },
                    "[typescriptreact]": {
                        "editor.defaultFormatter": "dbaeumer.vscode-eslint",
                        "editor.formatOnSave": true,
                    },
                    "eslint.run": "onType",
                    "eslint.format.enable": true,
                    "typescript.tsdk": "node_modules/typescript/lib",
                };
                await fs_extra_1.default.outputFile(paths.settings, JSON.stringify(settings, undefined, "\t"));
                extensions.recommendations.push("dbaeumer.vscode-eslint");
            }
            await fs_extra_1.default.outputFile(paths.extensions, JSON.stringify(extensions, undefined, "\t"));
        }
        const templateTsConfig = path_1.default.join(TEMPLATE_DIR, `tsconfig-${mode === InitMode.Package ? "package" : "default"}.json`);
        await fs_extra_1.default.copy(templateTsConfig, paths.tsconfig);
        await fs_extra_1.default.copy(path_1.default.join(TEMPLATE_DIR, mode), cwd);
    });
    await benchmark_1.benchmark("Building..", () => build_1.default.handler({
        logTruthyChanges: false,
        noInclude: false,
        project: ".",
        usePolling: false,
        verbose: false,
        watch: false,
        writeOnlyChanged: false,
        $0: argv.$0,
        _: argv._,
    }));
}
const GAME_DESCRIPTION = "Generate a Roblox place";
const MODEL_DESCRIPTION = "Generate a Roblox model";
const PLUGIN_DESCRIPTION = "Generate a Roblox Studio plugin";
const PACKAGE_DESCRIPTION = "Generate a roblox-ts npm package";
module.exports = byots_1.default.identity({
    command: "init",
    describe: "Create a project from a template",
    builder: () => yargs_1.default
        .option("yes", {
        alias: "y",
        boolean: true,
        describe: "recommended options",
    })
        .option("git", {
        boolean: true,
        describe: "Configure Git",
    })
        .option("eslint", {
        boolean: true,
        describe: "Configure ESLint",
    })
        .option("prettier", {
        boolean: true,
        describe: "Configure Prettier",
    })
        .option("vscode", {
        boolean: true,
        describe: "Configure VSCode Project Settings",
    })
        .option("packageManager", {
        choices: Object.values(PackageManager),
        describe: "Choose an alternative package manager",
    })
        .command([InitMode.Game, InitMode.Place], GAME_DESCRIPTION, {}, argv => init(argv, InitMode.Game))
        .command(InitMode.Model, MODEL_DESCRIPTION, {}, argv => init(argv, InitMode.Model))
        .command(InitMode.Plugin, PLUGIN_DESCRIPTION, {}, argv => init(argv, InitMode.Plugin))
        .command(InitMode.Package, PACKAGE_DESCRIPTION, {}, argv => init(argv, InitMode.Package)),
    handler: argv => init(argv, InitMode.None),
});
//# sourceMappingURL=init.js.map