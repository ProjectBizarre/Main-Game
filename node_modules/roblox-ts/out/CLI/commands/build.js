"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const byots_1 = __importDefault(require("byots"));
const CLIError_1 = require("../errors/CLIError");
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const cleanup_1 = require("../../Project/functions/cleanup");
const compileFiles_1 = require("../../Project/functions/compileFiles");
const copyFiles_1 = require("../../Project/functions/copyFiles");
const copyInclude_1 = require("../../Project/functions/copyInclude");
const createPathTranslator_1 = require("../../Project/functions/createPathTranslator");
const createProjectData_1 = require("../../Project/functions/createProjectData");
const createProjectProgram_1 = require("../../Project/functions/createProjectProgram");
const getChangedSourceFiles_1 = require("../../Project/functions/getChangedSourceFiles");
const setupProjectWatchProgram_1 = require("../../Project/functions/setupProjectWatchProgram");
const hasErrors_1 = require("../../Project/util/hasErrors");
const LogService_1 = require("../../Shared/classes/LogService");
const constants_1 = require("../../Shared/constants");
const LoggableError_1 = require("../../Shared/errors/LoggableError");
const getRootDirs_1 = require("../../Shared/util/getRootDirs");
const yargs_1 = __importDefault(require("yargs"));
function getTsConfigProjectOptions(tsConfigPath) {
    if (tsConfigPath !== undefined) {
        const rawJson = byots_1.default.sys.readFile(tsConfigPath);
        if (rawJson !== undefined) {
            return byots_1.default.parseConfigFileTextToJson(tsConfigPath, rawJson).config.rbxts;
        }
    }
}
function findTsConfigPath(projectPath) {
    let tsConfigPath = path_1.default.resolve(projectPath);
    if (!fs_extra_1.default.existsSync(tsConfigPath) || !fs_extra_1.default.statSync(tsConfigPath).isFile()) {
        tsConfigPath = byots_1.default.findConfigFile(tsConfigPath, byots_1.default.sys.fileExists);
        if (tsConfigPath === undefined) {
            throw new CLIError_1.CLIError("Unable to find tsconfig.json!");
        }
    }
    return path_1.default.resolve(process.cwd(), tsConfigPath);
}
module.exports = byots_1.default.identity({
    command: ["$0", "build"],
    describe: "Build a project",
    builder: () => yargs_1.default
        .option("project", {
        alias: "p",
        string: true,
        default: ".",
        describe: "project path",
    })
        .option("watch", {
        alias: "w",
        boolean: true,
        default: false,
        describe: "enable watch mode",
    })
        .option("usePolling", {
        implies: "watch",
        boolean: true,
        default: false,
        describe: "use polling for watch mode",
    })
        .option("verbose", {
        boolean: true,
        default: false,
        describe: "enable verbose logs",
    })
        .option("noInclude", {
        boolean: true,
        default: false,
        describe: "do not copy include files",
    })
        .option("logTruthyChanges", {
        boolean: true,
        default: false,
        describe: "logs changes to truthiness evaluation from Lua truthiness rules",
    })
        .option("writeOnlyChanged", {
        boolean: true,
        default: false,
        hidden: true,
    })
        .option("type", {
        choices: [constants_1.ProjectType.Game, constants_1.ProjectType.Model, constants_1.ProjectType.Package],
        describe: "override project type",
    })
        .option("includePath", {
        alias: "i",
        string: true,
        describe: "folder to copy runtime files to",
    })
        .option("rojo", {
        string: true,
        describe: "manually select Rojo project file",
    }),
    handler: async (argv) => {
        const tsConfigPath = findTsConfigPath(argv.project);
        const projectOptions = Object.assign({}, getTsConfigProjectOptions(tsConfigPath), argv);
        LogService_1.LogService.verbose = argv.verbose === true;
        const diagnosticReporter = byots_1.default.createDiagnosticReporter(byots_1.default.sys, true);
        try {
            const data = createProjectData_1.createProjectData(tsConfigPath, projectOptions, argv);
            if (argv.watch) {
                setupProjectWatchProgram_1.setupProjectWatchProgram(data, argv.usePolling);
            }
            else {
                const program = createProjectProgram_1.createProjectProgram(data);
                const pathTranslator = createPathTranslator_1.createPathTranslator(program);
                cleanup_1.cleanup(pathTranslator);
                copyInclude_1.copyInclude(data);
                copyFiles_1.copyFiles(data, pathTranslator, new Set(getRootDirs_1.getRootDirs(program.getCompilerOptions())));
                const emitResult = compileFiles_1.compileFiles(program.getProgram(), data, pathTranslator, getChangedSourceFiles_1.getChangedSourceFiles(program));
                for (const diagnostic of emitResult.diagnostics) {
                    diagnosticReporter(diagnostic);
                }
                if (hasErrors_1.hasErrors(emitResult.diagnostics)) {
                    process.exitCode = 1;
                }
            }
        }
        catch (e) {
            process.exitCode = 1;
            if (e instanceof LoggableError_1.LoggableError) {
                e.log();
                debugger;
            }
            else {
                throw e;
            }
        }
    },
});
//# sourceMappingURL=build.js.map