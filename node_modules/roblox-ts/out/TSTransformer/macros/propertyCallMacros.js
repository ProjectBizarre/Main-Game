"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PROPERTY_CALL_MACROS = void 0;
const byots_1 = __importDefault(require("byots"));
const LuauAST_1 = __importDefault(require("../../LuauAST"));
const assert_1 = require("../../Shared/util/assert");
const convertToIndexableExpression_1 = require("../util/convertToIndexableExpression");
const isUsedAsStatement_1 = require("../util/isUsedAsStatement");
const offset_1 = require("../util/offset");
const types_1 = require("../util/types");
const valueToIdStr_1 = require("../util/valueToIdStr");
function makeMathMethod(operator) {
    return (state, node, expression, args) => {
        let rhs = args[0];
        if (!LuauAST_1.default.isSimple(rhs)) {
            rhs = LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.ParenthesizedExpression, { expression: rhs });
        }
        return LuauAST_1.default.binary(expression, operator, rhs);
    };
}
const OPERATOR_TO_NAME_MAP = new Map([
    ["+", "add"],
    ["-", "sub"],
    ["*", "mul"],
    ["/", "div"],
]);
function makeMathSet(...operators) {
    const result = {};
    for (const operator of operators) {
        const methodName = OPERATOR_TO_NAME_MAP.get(operator);
        assert_1.assert(methodName);
        result[methodName] = makeMathMethod(operator);
    }
    return result;
}
function makeStringCallback(strCallback) {
    return (state, node, expression, args) => {
        return LuauAST_1.default.call(strCallback, [expression, ...args]);
    };
}
const STRING_CALLBACKS = {
    size: (state, node, expression) => LuauAST_1.default.unary("#", expression),
    byte: makeStringCallback(LuauAST_1.default.globals.string.byte),
    find: makeStringCallback(LuauAST_1.default.globals.string.find),
    format: makeStringCallback(LuauAST_1.default.globals.string.format),
    gmatch: makeStringCallback(LuauAST_1.default.globals.string.gmatch),
    gsub: makeStringCallback(LuauAST_1.default.globals.string.gsub),
    lower: makeStringCallback(LuauAST_1.default.globals.string.lower),
    match: makeStringCallback(LuauAST_1.default.globals.string.match),
    rep: makeStringCallback(LuauAST_1.default.globals.string.rep),
    reverse: makeStringCallback(LuauAST_1.default.globals.string.reverse),
    split: makeStringCallback(LuauAST_1.default.globals.string.split),
    sub: makeStringCallback(LuauAST_1.default.globals.string.sub),
    upper: makeStringCallback(LuauAST_1.default.globals.string.upper),
};
function makeEveryOrSomeMethod(iterator, callbackArgsListMaker, initialState) {
    return (state, node, expression, args) => {
        expression = state.pushToVarIfComplex(expression, "exp");
        const resultId = state.pushToVar(LuauAST_1.default.bool(initialState), "result");
        const callbackId = state.pushToVarIfComplex(args[0], "callback");
        const keyId = LuauAST_1.default.tempId("k");
        const valueId = LuauAST_1.default.tempId("v");
        const callCallback = LuauAST_1.default.call(callbackId, callbackArgsListMaker(keyId, valueId, expression));
        state.prereq(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.ForStatement, {
            ids: LuauAST_1.default.list.make(keyId, valueId),
            expression: LuauAST_1.default.call(iterator, [expression]),
            statements: LuauAST_1.default.list.make(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.IfStatement, {
                condition: initialState ? LuauAST_1.default.unary("not", callCallback) : callCallback,
                statements: LuauAST_1.default.list.make(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.Assignment, {
                    left: resultId,
                    operator: "=",
                    right: LuauAST_1.default.bool(!initialState),
                }), LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.BreakStatement, {})),
                elseBody: LuauAST_1.default.list.make(),
            })),
        }));
        return resultId;
    };
}
function makeEveryMethod(iterator, callbackArgsListMaker) {
    return makeEveryOrSomeMethod(iterator, callbackArgsListMaker, true);
}
function makeSomeMethod(iterator, callbackArgsListMaker) {
    return makeEveryOrSomeMethod(iterator, callbackArgsListMaker, false);
}
function argumentsWithDefaults(state, args, defaults) {
    for (let i = 0; i < args.length; i++) {
        args[i] = state.pushToVar(args[i], valueToIdStr_1.valueToIdStr(args[i]) || `arg${i}`);
        state.prereq(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.IfStatement, {
            condition: LuauAST_1.default.binary(args[i], "==", LuauAST_1.default.nil()),
            statements: LuauAST_1.default.list.make(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.Assignment, {
                left: args[i],
                operator: "=",
                right: defaults[i],
            })),
            elseBody: LuauAST_1.default.list.make(),
        }));
    }
    for (let j = args.length; j < defaults.length; j++) {
        args[j] = defaults[j];
    }
    return args;
}
const ARRAY_LIKE_METHODS = {
    size: (state, node, expression) => LuauAST_1.default.unary("#", expression),
};
const READONLY_ARRAY_METHODS = {
    isEmpty: (state, node, expression) => LuauAST_1.default.binary(LuauAST_1.default.unary("#", expression), "==", LuauAST_1.default.number(0)),
    join: (state, node, expression, args) => {
        args = argumentsWithDefaults(state, args, [LuauAST_1.default.strings[", "]]);
        const indexType = state.typeChecker.getIndexTypeOfType(state.getType(node.expression.expression), byots_1.default.IndexKind.Number);
        if (indexType && types_1.isPossiblyType(indexType, t => !types_1.isStringType(t) && !types_1.isNumberType(t))) {
            expression = state.pushToVarIfComplex(expression, "exp");
            const id = state.pushToVar(LuauAST_1.default.call(LuauAST_1.default.globals.table.create, [LuauAST_1.default.unary("#", expression)]), "result");
            const keyId = LuauAST_1.default.tempId("k");
            const valueId = LuauAST_1.default.tempId("v");
            state.prereq(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.ForStatement, {
                ids: LuauAST_1.default.list.make(keyId, valueId),
                expression: LuauAST_1.default.call(LuauAST_1.default.globals.ipairs, [expression]),
                statements: LuauAST_1.default.list.make(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.Assignment, {
                    left: LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.ComputedIndexExpression, {
                        expression: id,
                        index: keyId,
                    }),
                    operator: "=",
                    right: LuauAST_1.default.call(LuauAST_1.default.globals.tostring, [valueId]),
                })),
            }));
            expression = id;
        }
        return LuauAST_1.default.call(LuauAST_1.default.globals.table.concat, [expression, args[0]]);
    },
    move: (state, node, expression, args) => {
        const moveArgs = [expression, offset_1.offset(args[0], 1), offset_1.offset(args[1], 1), offset_1.offset(args[2], 1)];
        if (args[3]) {
            moveArgs.push(args[3]);
        }
        return LuauAST_1.default.call(LuauAST_1.default.globals.table.move, moveArgs);
    },
    includes: (state, node, expression, args) => {
        const callArgs = [expression, args[0]];
        if (args[1]) {
            callArgs.push(offset_1.offset(args[1], 1));
        }
        return LuauAST_1.default.binary(LuauAST_1.default.call(LuauAST_1.default.globals.table.find, callArgs), "~=", LuauAST_1.default.nil());
    },
    indexOf: (state, node, expression, args) => {
        const findArgs = [expression, args[0]];
        if (args.length > 1) {
            findArgs.push(offset_1.offset(args[1], 1));
        }
        return offset_1.offset(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.BinaryExpression, {
            left: LuauAST_1.default.call(LuauAST_1.default.globals.table.find, findArgs),
            operator: "or",
            right: LuauAST_1.default.number(0),
        }), -1);
    },
    every: makeEveryMethod(LuauAST_1.default.globals.ipairs, (keyId, valueId, expression) => [
        valueId,
        offset_1.offset(keyId, -1),
        expression,
    ]),
    some: makeSomeMethod(LuauAST_1.default.globals.ipairs, (keyId, valueId, expression) => [valueId, offset_1.offset(keyId, -1), expression]),
    forEach: (state, node, expression, args) => {
        expression = state.pushToVarIfComplex(expression, "exp");
        const callbackId = state.pushToVarIfComplex(args[0], "callback");
        const keyId = LuauAST_1.default.tempId("k");
        const valueId = LuauAST_1.default.tempId("v");
        state.prereq(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.ForStatement, {
            ids: LuauAST_1.default.list.make(keyId, valueId),
            expression: LuauAST_1.default.call(LuauAST_1.default.globals.ipairs, [expression]),
            statements: LuauAST_1.default.list.make(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.CallStatement, {
                expression: LuauAST_1.default.call(callbackId, [valueId, offset_1.offset(keyId, -1), expression]),
            })),
        }));
        return LuauAST_1.default.nil();
    },
    map: (state, node, expression, args) => {
        expression = state.pushToVarIfComplex(expression, "exp");
        const newValueId = state.pushToVar(LuauAST_1.default.call(LuauAST_1.default.globals.table.create, [LuauAST_1.default.unary("#", expression)]), "newValue");
        const callbackId = state.pushToVarIfComplex(args[0], "callback");
        const keyId = LuauAST_1.default.tempId("k");
        const valueId = LuauAST_1.default.tempId("v");
        state.prereq(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.ForStatement, {
            ids: LuauAST_1.default.list.make(keyId, valueId),
            expression: LuauAST_1.default.call(LuauAST_1.default.globals.ipairs, [expression]),
            statements: LuauAST_1.default.list.make(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.Assignment, {
                left: LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.ComputedIndexExpression, {
                    expression: newValueId,
                    index: keyId,
                }),
                operator: "=",
                right: LuauAST_1.default.call(callbackId, [valueId, offset_1.offset(keyId, -1), expression]),
            })),
        }));
        return newValueId;
    },
    mapFiltered: (state, node, expression, args) => {
        expression = state.pushToVarIfComplex(expression, "exp");
        const newValueId = state.pushToVar(LuauAST_1.default.array(), "newValue");
        const callbackId = state.pushToVarIfComplex(args[0], "callback");
        const lengthId = state.pushToVar(LuauAST_1.default.number(0), "length");
        const keyId = LuauAST_1.default.tempId("k");
        const valueId = LuauAST_1.default.tempId("v");
        const resultId = LuauAST_1.default.tempId("result");
        state.prereq(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.ForStatement, {
            ids: LuauAST_1.default.list.make(keyId, valueId),
            expression: LuauAST_1.default.call(LuauAST_1.default.globals.ipairs, [expression]),
            statements: LuauAST_1.default.list.make(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.VariableDeclaration, {
                left: resultId,
                right: LuauAST_1.default.call(callbackId, [valueId, offset_1.offset(keyId, -1), expression]),
            }), LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.IfStatement, {
                condition: LuauAST_1.default.binary(resultId, "~=", LuauAST_1.default.nil()),
                statements: LuauAST_1.default.list.make(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.Assignment, {
                    left: lengthId,
                    operator: "+=",
                    right: LuauAST_1.default.number(1),
                }), LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.Assignment, {
                    left: LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.ComputedIndexExpression, {
                        expression: newValueId,
                        index: lengthId,
                    }),
                    operator: "=",
                    right: resultId,
                })),
                elseBody: LuauAST_1.default.list.make(),
            })),
        }));
        return newValueId;
    },
    filterUndefined: (state, node, expression) => {
        expression = state.pushToVarIfComplex(expression, "exp");
        const lengthId = state.pushToVar(LuauAST_1.default.number(0), "length");
        const indexId1 = LuauAST_1.default.tempId("i");
        state.prereq(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.ForStatement, {
            ids: LuauAST_1.default.list.make(indexId1),
            expression: LuauAST_1.default.call(LuauAST_1.default.globals.pairs, [expression]),
            statements: LuauAST_1.default.list.make(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.IfStatement, {
                condition: LuauAST_1.default.binary(indexId1, ">", lengthId),
                statements: LuauAST_1.default.list.make(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.Assignment, {
                    left: lengthId,
                    operator: "=",
                    right: indexId1,
                })),
                elseBody: LuauAST_1.default.list.make(),
            })),
        }));
        const resultId = state.pushToVar(LuauAST_1.default.array(), "result");
        const resultLengthId = state.pushToVar(LuauAST_1.default.number(0), "resultLength");
        const indexId2 = LuauAST_1.default.tempId("i");
        const valueId = LuauAST_1.default.tempId("v");
        state.prereq(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.NumericForStatement, {
            id: indexId2,
            start: LuauAST_1.default.number(1),
            end: lengthId,
            step: undefined,
            statements: LuauAST_1.default.list.make(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.VariableDeclaration, {
                left: valueId,
                right: LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.ComputedIndexExpression, {
                    expression: convertToIndexableExpression_1.convertToIndexableExpression(expression),
                    index: indexId2,
                }),
            }), LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.IfStatement, {
                condition: LuauAST_1.default.binary(valueId, "~=", LuauAST_1.default.nil()),
                statements: LuauAST_1.default.list.make(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.Assignment, {
                    left: resultLengthId,
                    operator: "+=",
                    right: LuauAST_1.default.number(1),
                }), LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.Assignment, {
                    left: LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.ComputedIndexExpression, {
                        expression: resultId,
                        index: resultLengthId,
                    }),
                    operator: "=",
                    right: valueId,
                })),
                elseBody: LuauAST_1.default.list.make(),
            })),
        }));
        return resultId;
    },
    filter: (state, node, expression, args) => {
        expression = state.pushToVarIfComplex(expression, "exp");
        const newValueId = state.pushToVar(LuauAST_1.default.array(), "newValue");
        const callbackId = state.pushToVarIfComplex(args[0], "callback");
        const lengthId = state.pushToVar(LuauAST_1.default.number(0), "length");
        const keyId = LuauAST_1.default.tempId("k");
        const valueId = LuauAST_1.default.tempId("v");
        state.prereq(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.ForStatement, {
            ids: LuauAST_1.default.list.make(keyId, valueId),
            expression: LuauAST_1.default.call(LuauAST_1.default.globals.ipairs, [expression]),
            statements: LuauAST_1.default.list.make(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.IfStatement, {
                condition: LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.BinaryExpression, {
                    left: LuauAST_1.default.call(callbackId, [valueId, offset_1.offset(keyId, -1), expression]),
                    operator: "==",
                    right: LuauAST_1.default.bool(true),
                }),
                statements: LuauAST_1.default.list.make(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.Assignment, {
                    left: lengthId,
                    operator: "+=",
                    right: LuauAST_1.default.number(1),
                }), LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.Assignment, {
                    left: LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.ComputedIndexExpression, {
                        expression: newValueId,
                        index: lengthId,
                    }),
                    operator: "=",
                    right: valueId,
                })),
                elseBody: LuauAST_1.default.list.make(),
            })),
        }));
        return newValueId;
    },
    reduce: (state, node, expression, args) => {
        expression = state.pushToVarIfComplex(expression, "exp");
        let start = LuauAST_1.default.number(1);
        const end = LuauAST_1.default.unary("#", expression);
        const step = 1;
        const lengthExp = LuauAST_1.default.unary("#", expression);
        let resultId;
        if (args.length < 2) {
            state.prereq(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.IfStatement, {
                condition: LuauAST_1.default.binary(lengthExp, "==", LuauAST_1.default.number(0)),
                statements: LuauAST_1.default.list.make(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.CallStatement, {
                    expression: LuauAST_1.default.call(LuauAST_1.default.globals.error, [
                        LuauAST_1.default.string("Attempted to call `ReadonlyArray.reduce()` on an empty array without an initialValue."),
                    ]),
                })),
                elseBody: LuauAST_1.default.list.make(),
            }));
            resultId = state.pushToVar(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.ComputedIndexExpression, {
                expression: convertToIndexableExpression_1.convertToIndexableExpression(expression),
                index: start,
            }), "result");
            start = offset_1.offset(start, step);
        }
        else {
            resultId = state.pushToVar(args[1], "result");
        }
        const callbackId = state.pushToVar(args[0], "callback");
        const iteratorId = LuauAST_1.default.tempId("i");
        state.prereq(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.NumericForStatement, {
            id: iteratorId,
            start,
            end,
            step: step === 1 ? undefined : LuauAST_1.default.number(step),
            statements: LuauAST_1.default.list.make(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.Assignment, {
                left: resultId,
                operator: "=",
                right: LuauAST_1.default.call(callbackId, [
                    resultId,
                    LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.ComputedIndexExpression, {
                        expression: convertToIndexableExpression_1.convertToIndexableExpression(expression),
                        index: iteratorId,
                    }),
                    offset_1.offset(iteratorId, -1),
                    expression,
                ]),
            })),
        }));
        return resultId;
    },
    find: (state, node, expression, args) => {
        expression = state.pushToVarIfComplex(expression, "exp");
        const callbackId = state.pushToVarIfComplex(args[0], "callback");
        const loopId = LuauAST_1.default.tempId("i");
        const valueId = LuauAST_1.default.tempId("v");
        const resultId = state.pushToVar(LuauAST_1.default.nil(), "result");
        state.prereq(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.ForStatement, {
            expression: LuauAST_1.default.call(LuauAST_1.default.globals.ipairs, [expression]),
            ids: LuauAST_1.default.list.make(loopId, valueId),
            statements: LuauAST_1.default.list.make(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.IfStatement, {
                condition: LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.BinaryExpression, {
                    left: LuauAST_1.default.call(callbackId, [valueId, offset_1.offset(loopId, -1), expression]),
                    operator: "==",
                    right: LuauAST_1.default.bool(true),
                }),
                statements: LuauAST_1.default.list.make(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.Assignment, {
                    left: resultId,
                    operator: "=",
                    right: valueId,
                }), LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.BreakStatement, {})),
                elseBody: LuauAST_1.default.list.make(),
            })),
        }));
        return resultId;
    },
    findIndex: (state, node, expression, args) => {
        expression = state.pushToVarIfComplex(expression, "exp");
        const callbackId = state.pushToVarIfComplex(args[0], "callback");
        const loopId = LuauAST_1.default.tempId("i");
        const valueId = LuauAST_1.default.tempId("v");
        const resultId = state.pushToVar(LuauAST_1.default.number(-1), "result");
        state.prereq(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.ForStatement, {
            expression: LuauAST_1.default.call(LuauAST_1.default.globals.ipairs, [expression]),
            ids: LuauAST_1.default.list.make(loopId, valueId),
            statements: LuauAST_1.default.list.make(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.IfStatement, {
                condition: LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.BinaryExpression, {
                    left: LuauAST_1.default.call(callbackId, [valueId, offset_1.offset(loopId, -1), expression]),
                    operator: "==",
                    right: LuauAST_1.default.bool(true),
                }),
                statements: LuauAST_1.default.list.make(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.Assignment, {
                    left: resultId,
                    operator: "=",
                    right: offset_1.offset(loopId, -1),
                }), LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.BreakStatement, {})),
                elseBody: LuauAST_1.default.list.make(),
            })),
        }));
        return resultId;
    },
};
const ARRAY_METHODS = {
    push: (state, node, expression, args) => {
        if (args.length === 0) {
            return LuauAST_1.default.unary("#", expression);
        }
        expression = state.pushToVarIfComplex(expression, valueToIdStr_1.valueToIdStr(expression) || "exp");
        args = args.map((arg, i) => state.pushToVarIfComplex(arg, valueToIdStr_1.valueToIdStr(arg) || `arg${i}`));
        const valueIsUsed = !isUsedAsStatement_1.isUsedAsStatement(node);
        const uses = (valueIsUsed ? 1 : 0) + args.length;
        let lengthExp = LuauAST_1.default.unary("#", expression);
        if (uses > 1) {
            lengthExp = state.pushToVar(lengthExp, "length");
        }
        for (let i = 0; i < args.length; i++) {
            state.prereq(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.Assignment, {
                left: LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.ComputedIndexExpression, {
                    expression: convertToIndexableExpression_1.convertToIndexableExpression(expression),
                    index: LuauAST_1.default.binary(lengthExp, "+", LuauAST_1.default.number(i + 1)),
                }),
                operator: "=",
                right: args[i],
            }));
        }
        return valueIsUsed ? LuauAST_1.default.binary(lengthExp, "+", LuauAST_1.default.number(args.length)) : LuauAST_1.default.nil();
    },
    pop: (state, node, expression) => {
        expression = state.pushToVarIfComplex(expression, "exp");
        let lengthExp = LuauAST_1.default.unary("#", expression);
        const valueIsUsed = !isUsedAsStatement_1.isUsedAsStatement(node);
        let retValue;
        if (valueIsUsed) {
            lengthExp = state.pushToVar(lengthExp, "length");
            retValue = state.pushToVar(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.ComputedIndexExpression, {
                expression: convertToIndexableExpression_1.convertToIndexableExpression(expression),
                index: lengthExp,
            }), "result");
        }
        state.prereq(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.Assignment, {
            left: LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.ComputedIndexExpression, {
                expression: convertToIndexableExpression_1.convertToIndexableExpression(expression),
                index: lengthExp,
            }),
            operator: "=",
            right: LuauAST_1.default.nil(),
        }));
        return valueIsUsed ? retValue : LuauAST_1.default.nil();
    },
    shift: (state, node, expression) => LuauAST_1.default.call(LuauAST_1.default.globals.table.remove, [expression, LuauAST_1.default.number(1)]),
    unshift: (state, node, expression, args) => {
        expression = state.pushToVarIfComplex(expression, "exp");
        for (let i = args.length - 1; i >= 0; i--) {
            const arg = args[i];
            state.prereq(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.CallStatement, {
                expression: LuauAST_1.default.call(LuauAST_1.default.globals.table.insert, [expression, LuauAST_1.default.number(1), arg]),
            }));
        }
        if (isUsedAsStatement_1.isUsedAsStatement(node)) {
            return LuauAST_1.default.nil();
        }
        else {
            return LuauAST_1.default.unary("#", expression);
        }
    },
    insert: (state, node, expression, args) => {
        return LuauAST_1.default.call(LuauAST_1.default.globals.table.insert, [expression, offset_1.offset(args[0], 1), args[1]]);
    },
    remove: (state, node, expression, args) => LuauAST_1.default.call(LuauAST_1.default.globals.table.remove, [expression, offset_1.offset(args[0], 1)]),
    unorderedRemove: (state, node, expression, args) => {
        const indexExp = state.pushToVarIfComplex(offset_1.offset(args[0], 1), "index");
        expression = state.pushToVarIfComplex(expression, "exp");
        const lengthId = state.pushToVar(LuauAST_1.default.unary("#", expression), "length");
        const valueIsUsed = !isUsedAsStatement_1.isUsedAsStatement(node);
        const valueId = state.pushToVar(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.ComputedIndexExpression, {
            expression: convertToIndexableExpression_1.convertToIndexableExpression(expression),
            index: indexExp,
        }), "value");
        state.prereq(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.IfStatement, {
            condition: valueId,
            statements: LuauAST_1.default.list.make(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.Assignment, {
                left: LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.ComputedIndexExpression, {
                    expression: convertToIndexableExpression_1.convertToIndexableExpression(expression),
                    index: indexExp,
                }),
                operator: "=",
                right: LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.ComputedIndexExpression, {
                    expression: convertToIndexableExpression_1.convertToIndexableExpression(expression),
                    index: lengthId,
                }),
            }), LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.Assignment, {
                left: LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.ComputedIndexExpression, {
                    expression: convertToIndexableExpression_1.convertToIndexableExpression(expression),
                    index: lengthId,
                }),
                operator: "=",
                right: LuauAST_1.default.nil(),
            })),
            elseBody: LuauAST_1.default.list.make(),
        }));
        return valueIsUsed ? valueId : LuauAST_1.default.nil();
    },
    sort: (state, node, expression, args) => {
        const valueIsUsed = !isUsedAsStatement_1.isUsedAsStatement(node);
        if (valueIsUsed) {
            expression = state.pushToVarIfComplex(expression, "exp");
        }
        args.unshift(expression);
        state.prereq(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.CallStatement, {
            expression: LuauAST_1.default.call(LuauAST_1.default.globals.table.sort, args),
        }));
        return valueIsUsed ? expression : LuauAST_1.default.nil();
    },
    clear: (state, node, expression) => {
        state.prereq(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.CallStatement, {
            expression: LuauAST_1.default.call(LuauAST_1.default.globals.table.clear, [expression]),
        }));
        return LuauAST_1.default.nil();
    },
};
const READONLY_SET_MAP_SHARED_METHODS = {
    isEmpty: (state, node, expression) => LuauAST_1.default.binary(LuauAST_1.default.call(LuauAST_1.default.globals.next, [expression]), "==", LuauAST_1.default.nil()),
    size: (state, node, expression) => {
        if (isUsedAsStatement_1.isUsedAsStatement(node)) {
            return LuauAST_1.default.nil();
        }
        const sizeId = state.pushToVar(LuauAST_1.default.number(0), "size");
        state.prereq(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.ForStatement, {
            ids: LuauAST_1.default.list.make(LuauAST_1.default.emptyId()),
            expression: LuauAST_1.default.call(LuauAST_1.default.globals.pairs, [expression]),
            statements: LuauAST_1.default.list.make(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.Assignment, {
                left: sizeId,
                operator: "+=",
                right: LuauAST_1.default.number(1),
            })),
        }));
        return sizeId;
    },
    has: (state, node, expression, args) => {
        const left = LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.ComputedIndexExpression, {
            expression: convertToIndexableExpression_1.convertToIndexableExpression(expression),
            index: args[0],
        });
        return LuauAST_1.default.binary(left, "~=", LuauAST_1.default.nil());
    },
};
const SET_MAP_SHARED_METHODS = {
    delete: (state, node, expression, args) => {
        const arg = state.pushToVarIfComplex(args[0], "value");
        const valueIsUsed = !isUsedAsStatement_1.isUsedAsStatement(node);
        let valueExistedId;
        if (valueIsUsed) {
            valueExistedId = state.pushToVar(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.BinaryExpression, {
                left: LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.ComputedIndexExpression, {
                    expression: convertToIndexableExpression_1.convertToIndexableExpression(expression),
                    index: arg,
                }),
                operator: "~=",
                right: LuauAST_1.default.nil(),
            }), "valueExisted");
        }
        state.prereq(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.Assignment, {
            left: LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.ComputedIndexExpression, {
                expression: convertToIndexableExpression_1.convertToIndexableExpression(expression),
                index: arg,
            }),
            operator: "=",
            right: LuauAST_1.default.nil(),
        }));
        return valueIsUsed ? valueExistedId : LuauAST_1.default.nil();
    },
    clear: (state, node, expression) => {
        state.prereq(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.CallStatement, {
            expression: LuauAST_1.default.call(LuauAST_1.default.globals.table.clear, [expression]),
        }));
        return LuauAST_1.default.nil();
    },
};
const READONLY_SET_METHODS = {
    ...READONLY_SET_MAP_SHARED_METHODS,
    forEach: (state, node, expression, args) => {
        expression = state.pushToVarIfComplex(expression, "exp");
        const callbackId = state.pushToVarIfComplex(args[0], "callback");
        const valueId = LuauAST_1.default.tempId("v");
        state.prereq(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.ForStatement, {
            ids: LuauAST_1.default.list.make(valueId),
            expression: LuauAST_1.default.call(LuauAST_1.default.globals.pairs, [expression]),
            statements: LuauAST_1.default.list.make(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.CallStatement, {
                expression: LuauAST_1.default.call(callbackId, [valueId, valueId, expression]),
            })),
        }));
        return LuauAST_1.default.nil();
    },
};
const SET_METHODS = {
    ...SET_MAP_SHARED_METHODS,
    add: (state, node, expression, args) => {
        const valueIsUsed = !isUsedAsStatement_1.isUsedAsStatement(node);
        if (valueIsUsed) {
            expression = state.pushToVarIfComplex(expression, "exp");
        }
        state.prereq(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.Assignment, {
            left: LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.ComputedIndexExpression, {
                expression: convertToIndexableExpression_1.convertToIndexableExpression(expression),
                index: args[0],
            }),
            operator: "=",
            right: LuauAST_1.default.bool(true),
        }));
        return valueIsUsed ? expression : LuauAST_1.default.nil();
    },
};
const READONLY_MAP_METHODS = {
    ...READONLY_SET_MAP_SHARED_METHODS,
    forEach: (state, node, expression, args) => {
        expression = state.pushToVarIfComplex(expression, "exp");
        const callbackId = state.pushToVarIfComplex(args[0], "callback");
        const keyId = LuauAST_1.default.tempId("k");
        const valueId = LuauAST_1.default.tempId("v");
        state.prereq(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.ForStatement, {
            ids: LuauAST_1.default.list.make(keyId, valueId),
            expression: LuauAST_1.default.call(LuauAST_1.default.globals.pairs, [expression]),
            statements: LuauAST_1.default.list.make(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.CallStatement, {
                expression: LuauAST_1.default.call(callbackId, [valueId, keyId, expression]),
            })),
        }));
        return LuauAST_1.default.nil();
    },
    get: (state, node, expression, args) => LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.ComputedIndexExpression, {
        expression: convertToIndexableExpression_1.convertToIndexableExpression(expression),
        index: args[0],
    }),
};
const MAP_METHODS = {
    ...SET_MAP_SHARED_METHODS,
    set: (state, node, expression, args) => {
        const [keyExp, valueExp] = args;
        const valueIsUsed = !isUsedAsStatement_1.isUsedAsStatement(node);
        if (valueIsUsed) {
            expression = state.pushToVarIfComplex(expression, "exp");
        }
        state.prereq(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.Assignment, {
            left: LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.ComputedIndexExpression, {
                expression: convertToIndexableExpression_1.convertToIndexableExpression(expression),
                index: keyExp,
            }),
            operator: "=",
            right: valueExp,
        }));
        return valueIsUsed ? expression : LuauAST_1.default.nil();
    },
};
const PROMISE_METHODS = {
    then: (state, node, expression, args) => LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.MethodCallExpression, {
        expression: convertToIndexableExpression_1.convertToIndexableExpression(expression),
        name: "andThen",
        args: LuauAST_1.default.list.make(...args),
    }),
};
exports.PROPERTY_CALL_MACROS = {
    CFrame: makeMathSet("+", "-", "*"),
    UDim: makeMathSet("+", "-"),
    UDim2: makeMathSet("+", "-"),
    Vector2: makeMathSet("+", "-", "*", "/"),
    Vector2int16: makeMathSet("+", "-", "*", "/"),
    Vector3: makeMathSet("+", "-", "*", "/"),
    Vector3int16: makeMathSet("+", "-", "*", "/"),
    String: STRING_CALLBACKS,
    ArrayLike: ARRAY_LIKE_METHODS,
    ReadonlyArray: READONLY_ARRAY_METHODS,
    Array: ARRAY_METHODS,
    ReadonlySet: READONLY_SET_METHODS,
    Set: SET_METHODS,
    ReadonlyMap: READONLY_MAP_METHODS,
    Map: MAP_METHODS,
    Promise: PROMISE_METHODS,
};
function header(text) {
    return LuauAST_1.default.comment(`▼ ${text} ▼`);
}
function footer(text) {
    return LuauAST_1.default.comment(`▲ ${text} ▲`);
}
function wasExpressionPushed(statements, expression) {
    if (LuauAST_1.default.list.isNonEmpty(statements)) {
        const firstStatement = statements.head.value;
        if (LuauAST_1.default.isVariableDeclaration(firstStatement)) {
            if (!LuauAST_1.default.list.isList(firstStatement.left) && LuauAST_1.default.isTemporaryIdentifier(firstStatement.left)) {
                if (firstStatement.right === expression) {
                    return true;
                }
            }
        }
    }
    return false;
}
function wrapComments(methodName, callback) {
    return (state, callNode, callExp, args) => {
        const [expression, prereqs] = state.capture(() => callback(state, callNode, callExp, args));
        let size = LuauAST_1.default.list.size(prereqs);
        if (size > 0) {
            const wasPushed = wasExpressionPushed(prereqs, callExp);
            let pushStatement;
            if (wasPushed) {
                pushStatement = LuauAST_1.default.list.shift(prereqs);
                size--;
            }
            if (size > 0) {
                LuauAST_1.default.list.unshift(prereqs, header(methodName));
                if (wasPushed && pushStatement) {
                    LuauAST_1.default.list.unshift(prereqs, pushStatement);
                }
                LuauAST_1.default.list.push(prereqs, footer(methodName));
            }
            else {
                if (wasPushed && pushStatement) {
                    LuauAST_1.default.list.unshift(prereqs, pushStatement);
                }
            }
        }
        state.prereqList(prereqs);
        return expression;
    };
}
for (const [className, macroList] of Object.entries(exports.PROPERTY_CALL_MACROS)) {
    for (const [methodName, macro] of Object.entries(macroList)) {
        macroList[methodName] = wrapComments(`${className}.${methodName}`, macro);
    }
}
//# sourceMappingURL=propertyCallMacros.js.map