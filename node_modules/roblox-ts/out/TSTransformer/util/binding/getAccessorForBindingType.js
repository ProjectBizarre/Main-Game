"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAccessorForBindingType = void 0;
const byots_1 = __importDefault(require("byots"));
const LuauAST_1 = __importDefault(require("../../../LuauAST"));
const diagnostics_1 = require("../../../Shared/diagnostics");
const assert_1 = require("../../../Shared/util/assert");
const DiagnosticService_1 = require("../../classes/DiagnosticService");
const types_1 = require("../types");
function peek(array) {
    return array[array.length - 1];
}
const arrayAccessor = (state, parentId, index) => {
    return LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.ComputedIndexExpression, {
        expression: parentId,
        index: LuauAST_1.default.number(index + 1),
    });
};
const stringAccessor = (state, parentId, index, idStack, isOmitted) => {
    let id;
    if (idStack.length === 0) {
        id = state.pushToVar(LuauAST_1.default.call(LuauAST_1.default.globals.string.gmatch, [parentId, LuauAST_1.default.globals.utf8.charpattern]), "matcher");
        idStack.push(id);
    }
    else {
        id = idStack[0];
    }
    const callExp = LuauAST_1.default.call(id);
    if (isOmitted) {
        state.prereq(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.CallStatement, {
            expression: callExp,
        }));
        return LuauAST_1.default.emptyId();
    }
    else {
        return callExp;
    }
};
const setAccessor = (state, parentId, index, idStack, isOmitted) => {
    const args = [parentId];
    const lastId = peek(idStack);
    if (lastId) {
        args.push(lastId);
    }
    const callExp = LuauAST_1.default.call(LuauAST_1.default.globals.next, args);
    if (isOmitted) {
        state.prereq(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.CallStatement, {
            expression: callExp,
        }));
        return LuauAST_1.default.emptyId();
    }
    else {
        const id = state.pushToVar(callExp, "value");
        idStack.push(id);
        return id;
    }
};
const mapAccessor = (state, parentId, index, idStack) => {
    const args = [parentId];
    const lastId = peek(idStack);
    if (lastId) {
        args.push(lastId);
    }
    const keyId = LuauAST_1.default.tempId("k");
    const valueId = LuauAST_1.default.tempId("v");
    const ids = LuauAST_1.default.list.make(keyId, valueId);
    state.prereq(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.VariableDeclaration, {
        left: ids,
        right: LuauAST_1.default.call(LuauAST_1.default.globals.next, args),
    }));
    idStack.push(keyId);
    return LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.Array, { members: ids });
};
const iterableFunctionLuaTupleAccessor = (state, parentId, index, idStack, isOmitted) => {
    const callExp = LuauAST_1.default.call(parentId);
    if (isOmitted) {
        state.prereq(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.CallStatement, {
            expression: callExp,
        }));
        return LuauAST_1.default.emptyId();
    }
    else {
        return LuauAST_1.default.array([callExp]);
    }
};
const iterableFunctionAccessor = (state, parentId, index, idStack, isOmitted) => {
    const callExp = LuauAST_1.default.call(parentId);
    if (isOmitted) {
        state.prereq(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.CallStatement, {
            expression: callExp,
        }));
        return LuauAST_1.default.emptyId();
    }
    else {
        return callExp;
    }
};
const iterAccessor = (state, parentId, index, idStack, isOmitted) => {
    const callExp = LuauAST_1.default.call(LuauAST_1.default.property(parentId, "next"));
    if (isOmitted) {
        state.prereq(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.CallStatement, { expression: callExp }));
        return LuauAST_1.default.emptyId();
    }
    else {
        return LuauAST_1.default.property(callExp, "value");
    }
};
function getAccessorForBindingType(state, node, type) {
    if (byots_1.default.isArray(type) || types_1.isDefinitelyType(type, t => types_1.isArrayType(state, t))) {
        return arrayAccessor;
    }
    else if (types_1.isDefinitelyType(type, t => types_1.isStringType(t))) {
        return stringAccessor;
    }
    else if (types_1.isDefinitelyType(type, t => types_1.isSetType(state, t))) {
        return setAccessor;
    }
    else if (types_1.isDefinitelyType(type, t => types_1.isMapType(state, t))) {
        return mapAccessor;
    }
    else if (types_1.isDefinitelyType(type, t => types_1.isIterableFunctionLuaTupleType(state, t))) {
        return iterableFunctionLuaTupleAccessor;
    }
    else if (types_1.isDefinitelyType(type, t => types_1.isIterableFunctionType(state, t))) {
        return iterableFunctionAccessor;
    }
    else if (types_1.isDefinitelyType(type, t => types_1.isIterableType(state, t))) {
        DiagnosticService_1.DiagnosticService.addDiagnostic(diagnostics_1.errors.noIterableIteration(node));
        return () => LuauAST_1.default.emptyId();
    }
    else if (types_1.isDefinitelyType(type, t => types_1.isGeneratorType(state, t)) ||
        types_1.isDefinitelyType(type, t => types_1.isObjectType(t)) ||
        byots_1.default.isThis(node)) {
        return iterAccessor;
    }
    assert_1.assert(false, `Destructuring not supported for type: ${state.typeChecker.typeToString(type)}`);
}
exports.getAccessorForBindingType = getAccessorForBindingType;
//# sourceMappingURL=getAccessorForBindingType.js.map