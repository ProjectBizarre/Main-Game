"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getTypeArguments = exports.getFirstDefinedSymbol = exports.getFirstConstructSymbol = exports.walkTypes = exports.isRoactElementType = exports.isEmptyStringType = exports.isUndefinedType = exports.isObjectType = exports.isIterableType = exports.isIterableFunctionLuaTupleType = exports.isLuaTupleType = exports.isIterableFunctionType = exports.isGeneratorType = exports.isMapType = exports.isSetType = exports.isArrayType = exports.isStringType = exports.isNaNType = exports.isNumberLiteralType = exports.isNumberType = exports.isBooleanLiteralType = exports.isBooleanType = exports.isAnyType = exports.isDefinedType = exports.isPossiblyType = exports.isDefinitelyType = void 0;
const byots_1 = __importDefault(require("byots"));
const TSTransformer_1 = require("..");
const MacroManager_1 = require("../classes/MacroManager");
function getRecursiveBaseTypesInner(result, type) {
    var _a;
    for (const baseType of (_a = type.getBaseTypes()) !== null && _a !== void 0 ? _a : []) {
        result.push(baseType);
        if (baseType.isClassOrInterface()) {
            getRecursiveBaseTypesInner(result, baseType);
        }
    }
}
function getRecursiveBaseTypes(type) {
    const result = new Array();
    getRecursiveBaseTypesInner(result, type);
    return result;
}
function isDefinitelyTypeInner(type, callback) {
    if (type.isUnion()) {
        return type.types.every(t => isDefinitelyTypeInner(t, callback));
    }
    else if (type.isIntersection()) {
        return type.types.some(t => isDefinitelyTypeInner(t, callback));
    }
    else {
        if (type.isClassOrInterface() && getRecursiveBaseTypes(type).some(t => isDefinitelyTypeInner(t, callback))) {
            return true;
        }
        return callback(type);
    }
}
function isDefinitelyType(type, cb) {
    var _a;
    return isDefinitelyTypeInner((_a = type.getConstraint()) !== null && _a !== void 0 ? _a : type, cb);
}
exports.isDefinitelyType = isDefinitelyType;
function isPossiblyTypeInner(type, callback) {
    if (type.isUnionOrIntersection()) {
        return type.types.some(t => isPossiblyTypeInner(t, callback));
    }
    else {
        if (type.isClassOrInterface() && getRecursiveBaseTypes(type).some(t => isPossiblyTypeInner(t, callback))) {
            return true;
        }
        if (!!(type.flags & (byots_1.default.TypeFlags.TypeVariable | byots_1.default.TypeFlags.AnyOrUnknown))) {
            return true;
        }
        if (isDefinedType(type)) {
            return true;
        }
        return callback(type);
    }
}
function isPossiblyType(type, cb) {
    var _a;
    return isPossiblyTypeInner((_a = type.getConstraint()) !== null && _a !== void 0 ? _a : type, cb);
}
exports.isPossiblyType = isPossiblyType;
function isDefinedType(type) {
    return (type.flags === byots_1.default.TypeFlags.Object && type.getProperties().length === 0 && type.getCallSignatures().length === 0);
}
exports.isDefinedType = isDefinedType;
function isAnyType(type) {
    return !!(type.flags & byots_1.default.TypeFlags.Any);
}
exports.isAnyType = isAnyType;
function isBooleanType(type) {
    return !!(type.flags & (byots_1.default.TypeFlags.Boolean | byots_1.default.TypeFlags.BooleanLiteral));
}
exports.isBooleanType = isBooleanType;
function isBooleanLiteralType(state, type, value) {
    if (!!(type.flags & byots_1.default.TypeFlags.BooleanLiteral)) {
        const valueType = value ? state.typeChecker.getTrueType() : state.typeChecker.getFalseType();
        return type === valueType;
    }
    return isBooleanType(type);
}
exports.isBooleanLiteralType = isBooleanLiteralType;
function isNumberType(type) {
    return !!(type.flags & (byots_1.default.TypeFlags.Number | byots_1.default.TypeFlags.NumberLike | byots_1.default.TypeFlags.NumberLiteral));
}
exports.isNumberType = isNumberType;
function isNumberLiteralType(type, value) {
    if (type.isNumberLiteral()) {
        return type.value === value;
    }
    return isNumberType(type);
}
exports.isNumberLiteralType = isNumberLiteralType;
function isNaNType(type) {
    return isNumberType(type) && !type.isNumberLiteral();
}
exports.isNaNType = isNaNType;
function isStringType(type) {
    return !!(type.flags & (byots_1.default.TypeFlags.String | byots_1.default.TypeFlags.StringLike | byots_1.default.TypeFlags.StringLiteral));
}
exports.isStringType = isStringType;
function isArrayType(state, type) {
    return (state.typeChecker.isTupleType(type) ||
        state.typeChecker.isArrayLikeType(type) ||
        type.symbol === state.services.macroManager.getSymbolOrThrow(TSTransformer_1.SYMBOL_NAMES.ReadonlyArray) ||
        type.symbol === state.services.macroManager.getSymbolOrThrow(TSTransformer_1.SYMBOL_NAMES.Array) ||
        type.symbol === state.services.macroManager.getSymbolOrThrow(TSTransformer_1.SYMBOL_NAMES.ReadVoxelsArray) ||
        type.symbol === state.services.macroManager.getSymbolOrThrow(TSTransformer_1.SYMBOL_NAMES.TemplateStringsArray));
}
exports.isArrayType = isArrayType;
function isSetType(state, type) {
    return (type.symbol === state.services.macroManager.getSymbolOrThrow(TSTransformer_1.SYMBOL_NAMES.Set) ||
        type.symbol === state.services.macroManager.getSymbolOrThrow(TSTransformer_1.SYMBOL_NAMES.ReadonlySet) ||
        type.symbol === state.services.macroManager.getSymbolOrThrow(TSTransformer_1.SYMBOL_NAMES.WeakSet));
}
exports.isSetType = isSetType;
function isMapType(state, type) {
    return (type.symbol === state.services.macroManager.getSymbolOrThrow(TSTransformer_1.SYMBOL_NAMES.Map) ||
        type.symbol === state.services.macroManager.getSymbolOrThrow(TSTransformer_1.SYMBOL_NAMES.ReadonlyMap) ||
        type.symbol === state.services.macroManager.getSymbolOrThrow(TSTransformer_1.SYMBOL_NAMES.WeakMap));
}
exports.isMapType = isMapType;
function isGeneratorType(state, type) {
    return type.symbol === state.services.macroManager.getSymbolOrThrow(TSTransformer_1.SYMBOL_NAMES.Generator);
}
exports.isGeneratorType = isGeneratorType;
function isIterableFunctionType(state, type) {
    return type.symbol === state.services.macroManager.getSymbolOrThrow(TSTransformer_1.SYMBOL_NAMES.IterableFunction);
}
exports.isIterableFunctionType = isIterableFunctionType;
function isLuaTupleType(state, type) {
    return (type.getProperty(MacroManager_1.NOMINAL_LUA_TUPLE_NAME) ===
        state.services.macroManager.getSymbolOrThrow(MacroManager_1.NOMINAL_LUA_TUPLE_NAME));
}
exports.isLuaTupleType = isLuaTupleType;
function isIterableFunctionLuaTupleType(state, type) {
    if (isIterableFunctionType(state, type)) {
        const firstTypeArg = getTypeArguments(state, type)[0];
        return firstTypeArg !== undefined && isLuaTupleType(state, firstTypeArg);
    }
    return false;
}
exports.isIterableFunctionLuaTupleType = isIterableFunctionLuaTupleType;
function isIterableType(state, type) {
    return type.symbol === state.services.macroManager.getSymbolOrThrow(TSTransformer_1.SYMBOL_NAMES.Iterable);
}
exports.isIterableType = isIterableType;
function isObjectType(type) {
    return !!(type.flags & byots_1.default.TypeFlags.Object);
}
exports.isObjectType = isObjectType;
function isUndefinedType(type) {
    return !!(type.flags & (byots_1.default.TypeFlags.Undefined | byots_1.default.TypeFlags.Void));
}
exports.isUndefinedType = isUndefinedType;
function isEmptyStringType(type) {
    if (type.isStringLiteral()) {
        return type.value === "";
    }
    return isStringType(type);
}
exports.isEmptyStringType = isEmptyStringType;
function isRoactElementType(state, type) {
    var _a;
    const symbol = (_a = state.services.roactSymbolManager) === null || _a === void 0 ? void 0 : _a.getSymbolOrThrow(TSTransformer_1.ROACT_SYMBOL_NAMES.Element);
    return symbol !== undefined && type.symbol === symbol;
}
exports.isRoactElementType = isRoactElementType;
function walkTypes(type, callback) {
    if (type.isUnionOrIntersection()) {
        for (const t of type.types) {
            walkTypes(t, callback);
        }
    }
    else {
        const constraint = type.getConstraint();
        if (constraint) {
            walkTypes(constraint, callback);
        }
        else {
            callback(type);
        }
    }
}
exports.walkTypes = walkTypes;
function getFirstConstructSymbol(state, expression) {
    const type = state.getType(expression);
    if (type.symbol) {
        const declarations = type.symbol.getDeclarations();
        if (declarations) {
            for (const declaration of declarations) {
                if (byots_1.default.isInterfaceDeclaration(declaration)) {
                    for (const member of declaration.members) {
                        if (byots_1.default.isConstructSignatureDeclaration(member)) {
                            return member.symbol;
                        }
                    }
                }
            }
        }
    }
}
exports.getFirstConstructSymbol = getFirstConstructSymbol;
function getFirstDefinedSymbol(state, type) {
    if (type.isUnionOrIntersection()) {
        for (const t of type.types) {
            if (t.symbol && !state.typeChecker.isUndefinedSymbol(t.symbol)) {
                return t.symbol;
            }
        }
    }
    else {
        return type.symbol;
    }
}
exports.getFirstDefinedSymbol = getFirstDefinedSymbol;
function getTypeArguments(state, type) {
    var _a;
    return (_a = state.typeChecker.getTypeArguments(type)) !== null && _a !== void 0 ? _a : [];
}
exports.getTypeArguments = getTypeArguments;
//# sourceMappingURL=types.js.map