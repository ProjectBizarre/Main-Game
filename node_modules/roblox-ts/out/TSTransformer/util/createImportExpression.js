"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createImportExpression = void 0;
const byots_1 = __importDefault(require("byots"));
const LuauAST_1 = __importDefault(require("../../LuauAST"));
const path_1 = __importDefault(require("path"));
const RojoResolver_1 = require("../../Shared/classes/RojoResolver");
const constants_1 = require("../../Shared/constants");
const diagnostics_1 = require("../../Shared/diagnostics");
const assert_1 = require("../../Shared/util/assert");
const DiagnosticService_1 = require("../classes/DiagnosticService");
const createGetService_1 = require("./createGetService");
const expressionChain_1 = require("./expressionChain");
const getSourceFileFromModuleSpecifier_1 = require("./getSourceFileFromModuleSpecifier");
function getAbsoluteImport(moduleRbxPath) {
    const pathExpressions = new Array();
    const serviceName = moduleRbxPath[0];
    assert_1.assert(serviceName);
    pathExpressions.push(createGetService_1.createGetService(serviceName));
    for (let i = 1; i < moduleRbxPath.length; i++) {
        pathExpressions.push(LuauAST_1.default.string(moduleRbxPath[i]));
    }
    return pathExpressions;
}
function getRelativeImport(sourceRbxPath, moduleRbxPath) {
    const relativePath = RojoResolver_1.RojoResolver.relative(sourceRbxPath, moduleRbxPath);
    const path = new Array();
    let i = 0;
    while (relativePath[i] === RojoResolver_1.RbxPathParent) {
        path.push(constants_1.PARENT_FIELD);
        i++;
    }
    const pathExpressions = [expressionChain_1.propertyAccessExpressionChain(LuauAST_1.default.globals.script, path)];
    for (; i < relativePath.length; i++) {
        const pathPart = relativePath[i];
        assert_1.assert(typeof pathPart === "string");
        pathExpressions.push(LuauAST_1.default.string(pathPart));
    }
    return pathExpressions;
}
function validateModule(state, scope) {
    const scopedModules = path_1.default.join(state.data.nodeModulesPath, scope);
    if (state.compilerOptions.typeRoots) {
        for (const typeRoot of state.compilerOptions.typeRoots) {
            if (path_1.default.normalize(scopedModules) === path_1.default.normalize(typeRoot)) {
                return true;
            }
        }
    }
    return false;
}
function findRelativeRbxPath(moduleOutPath, pkgRojoResolvers) {
    for (const pkgRojoResolver of pkgRojoResolvers) {
        const relativeRbxPath = pkgRojoResolver.getRbxPathFromFilePath(moduleOutPath);
        if (relativeRbxPath) {
            return relativeRbxPath;
        }
    }
}
function getNodeModulesImport(state, moduleSpecifier, moduleFilePath) {
    var _a;
    const moduleOutPath = state.pathTranslator.getImportPath((_a = state.nodeModulesPathMapping.get(path_1.default.normalize(moduleFilePath))) !== null && _a !== void 0 ? _a : moduleFilePath, true);
    const gameRbxPath = state.rojoResolver.getRbxPathFromFilePath(moduleOutPath);
    const relativeRbxPath = findRelativeRbxPath(moduleOutPath, state.pkgRojoResolvers);
    if (!relativeRbxPath || (!state.data.isPackage && !gameRbxPath)) {
        DiagnosticService_1.DiagnosticService.addDiagnostic(diagnostics_1.errors.noRojoData(moduleSpecifier, path_1.default.relative(state.data.projectPath, moduleOutPath)));
        return LuauAST_1.default.emptyId();
    }
    const relativeFilePath = path_1.default.relative(state.data.nodeModulesPath, moduleOutPath);
    const moduleScope = relativeFilePath.split(path_1.default.sep)[0];
    assert_1.assert(moduleScope && typeof moduleScope === "string");
    if (!moduleScope.startsWith("@")) {
        DiagnosticService_1.DiagnosticService.addDiagnostic(diagnostics_1.errors.noUnscopedModule(moduleSpecifier));
        return LuauAST_1.default.emptyId();
    }
    const moduleName = relativeRbxPath[0];
    assert_1.assert(moduleName && typeof moduleName === "string");
    if (!validateModule(state, moduleScope)) {
        DiagnosticService_1.DiagnosticService.addDiagnostic(diagnostics_1.errors.noInvalidModule(moduleSpecifier));
        return LuauAST_1.default.emptyId();
    }
    return expressionChain_1.propertyAccessExpressionChain(LuauAST_1.default.call(state.TS(moduleSpecifier.parent, "getModule"), [
        LuauAST_1.default.globals.script,
        LuauAST_1.default.string(moduleScope),
        LuauAST_1.default.string(moduleName),
    ]), relativeRbxPath.slice(1));
}
function createImportExpression(state, sourceFile, moduleSpecifier) {
    const moduleFile = getSourceFileFromModuleSpecifier_1.getSourceFileFromModuleSpecifier(state.typeChecker, moduleSpecifier);
    if (!moduleFile) {
        DiagnosticService_1.DiagnosticService.addDiagnostic(diagnostics_1.errors.noModuleSpecifierFile(moduleSpecifier));
        return LuauAST_1.default.emptyId();
    }
    const importPathExpressions = new Array();
    importPathExpressions.push(LuauAST_1.default.globals.script);
    const virtualPath = state.guessVirtualPath(moduleFile.fileName);
    if (byots_1.default.isInsideNodeModules(virtualPath)) {
        importPathExpressions.push(getNodeModulesImport(state, moduleSpecifier, virtualPath));
    }
    else {
        const moduleOutPath = state.pathTranslator.getImportPath(virtualPath);
        const moduleRbxPath = state.rojoResolver.getRbxPathFromFilePath(moduleOutPath);
        if (!moduleRbxPath) {
            DiagnosticService_1.DiagnosticService.addDiagnostic(diagnostics_1.errors.noRojoData(moduleSpecifier, path_1.default.relative(state.data.projectPath, moduleOutPath)));
            return LuauAST_1.default.emptyId();
        }
        const moduleRbxType = state.rojoResolver.getRbxTypeFromFilePath(moduleOutPath);
        if (moduleRbxType === RojoResolver_1.RbxType.Script || moduleRbxType === RojoResolver_1.RbxType.LocalScript) {
            DiagnosticService_1.DiagnosticService.addDiagnostic(diagnostics_1.errors.noNonModuleImport(moduleSpecifier));
            return LuauAST_1.default.emptyId();
        }
        const sourceOutPath = state.pathTranslator.getOutputPath(sourceFile.fileName);
        const sourceRbxPath = state.rojoResolver.getRbxPathFromFilePath(sourceOutPath);
        if (!sourceRbxPath) {
            DiagnosticService_1.DiagnosticService.addDiagnostic(diagnostics_1.errors.noRojoData(sourceFile, path_1.default.relative(state.data.projectPath, sourceOutPath)));
            return LuauAST_1.default.emptyId();
        }
        if (state.projectType === constants_1.ProjectType.Game) {
            const fileRelation = state.rojoResolver.getFileRelation(sourceRbxPath, moduleRbxPath);
            if (fileRelation === RojoResolver_1.FileRelation.OutToOut || fileRelation === RojoResolver_1.FileRelation.InToOut) {
                importPathExpressions.push(...getAbsoluteImport(moduleRbxPath));
            }
            else if (fileRelation === RojoResolver_1.FileRelation.InToIn) {
                importPathExpressions.push(...getRelativeImport(sourceRbxPath, moduleRbxPath));
            }
            else {
                DiagnosticService_1.DiagnosticService.addDiagnostic(diagnostics_1.errors.noIsolatedImport(moduleSpecifier));
                return LuauAST_1.default.emptyId();
            }
        }
        else {
            importPathExpressions.push(...getRelativeImport(sourceRbxPath, moduleRbxPath));
        }
    }
    return LuauAST_1.default.call(state.TS(moduleSpecifier.parent, "import"), importPathExpressions);
}
exports.createImportExpression = createImportExpression;
//# sourceMappingURL=createImportExpression.js.map