"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.expressionMightMutate = void 0;
const byots_1 = __importDefault(require("byots"));
const LuauAST_1 = __importDefault(require("../../LuauAST"));
const isDefinedAsLet_1 = require("./isDefinedAsLet");
const traversal_1 = require("./traversal");
function expressionMightMutate(state, expression, node) {
    if (LuauAST_1.default.isEmptyIdentifier(expression) || LuauAST_1.default.isTemporaryIdentifier(expression)) {
        return false;
    }
    else if (LuauAST_1.default.isParenthesizedExpression(expression)) {
        return expressionMightMutate(state, expression.expression);
    }
    else if (LuauAST_1.default.isSimplePrimitive(expression)) {
        return false;
    }
    else if (LuauAST_1.default.isBinaryExpression(expression)) {
        return expressionMightMutate(state, expression.left) || expressionMightMutate(state, expression.right);
    }
    else if (LuauAST_1.default.isUnaryExpression(expression)) {
        return expressionMightMutate(state, expression.expression);
    }
    else if (LuauAST_1.default.isArray(expression) || LuauAST_1.default.isSet(expression)) {
        return LuauAST_1.default.list.some(expression.members, member => expressionMightMutate(state, member));
    }
    else if (LuauAST_1.default.isMap(expression)) {
        return LuauAST_1.default.list.some(expression.fields, field => expressionMightMutate(state, field.index) || expressionMightMutate(state, field.value));
    }
    else if (LuauAST_1.default.isMixedTable(expression)) {
        return LuauAST_1.default.list.some(expression.fields, field => {
            if (LuauAST_1.default.isMapField(field)) {
                return expressionMightMutate(state, field.index) || expressionMightMutate(state, field.value);
            }
            else {
                return expressionMightMutate(state, field);
            }
        });
    }
    else {
        if (node) {
            node = traversal_1.skipDownwards(node);
            if (byots_1.default.isIdentifier(node)) {
                const symbol = state.typeChecker.getSymbolAtLocation(node);
                if (symbol && !isDefinedAsLet_1.isDefinedAsLet(state, symbol)) {
                    return false;
                }
            }
        }
        return true;
    }
}
exports.expressionMightMutate = expressionMightMutate;
//# sourceMappingURL=expressionMightMutate.js.map