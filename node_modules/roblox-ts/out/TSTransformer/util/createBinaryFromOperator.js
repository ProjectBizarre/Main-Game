"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createBinaryFromOperator = void 0;
const byots_1 = __importDefault(require("byots"));
const LuauAST_1 = __importDefault(require("../../LuauAST"));
const assert_1 = require("../../Shared/util/assert");
const getKindName_1 = require("./getKindName");
const types_1 = require("./types");
const OPERATOR_MAP = new Map([
    [byots_1.default.SyntaxKind.LessThanToken, "<"],
    [byots_1.default.SyntaxKind.GreaterThanToken, ">"],
    [byots_1.default.SyntaxKind.LessThanEqualsToken, "<="],
    [byots_1.default.SyntaxKind.GreaterThanEqualsToken, ">="],
    [byots_1.default.SyntaxKind.EqualsEqualsEqualsToken, "=="],
    [byots_1.default.SyntaxKind.ExclamationEqualsEqualsToken, "~="],
    [byots_1.default.SyntaxKind.MinusToken, "-"],
    [byots_1.default.SyntaxKind.AsteriskToken, "*"],
    [byots_1.default.SyntaxKind.SlashToken, "/"],
    [byots_1.default.SyntaxKind.AsteriskAsteriskToken, "^"],
    [byots_1.default.SyntaxKind.PercentToken, "%"],
]);
const BITWISE_OPERATOR_MAP = new Map([
    [byots_1.default.SyntaxKind.AmpersandToken, "band"],
    [byots_1.default.SyntaxKind.BarToken, "bor"],
    [byots_1.default.SyntaxKind.CaretToken, "bxor"],
    [byots_1.default.SyntaxKind.LessThanLessThanToken, "lshift"],
    [byots_1.default.SyntaxKind.GreaterThanGreaterThanGreaterThanToken, "rshift"],
    [byots_1.default.SyntaxKind.AmpersandEqualsToken, "band"],
    [byots_1.default.SyntaxKind.BarEqualsToken, "bor"],
    [byots_1.default.SyntaxKind.CaretEqualsToken, "bxor"],
    [byots_1.default.SyntaxKind.LessThanLessThanEqualsToken, "lshift"],
    [byots_1.default.SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken, "rshift"],
]);
function createBinaryAdd(left, leftType, right, rightType) {
    const leftIsString = types_1.isDefinitelyType(leftType, t => types_1.isStringType(t));
    const rightIsString = types_1.isDefinitelyType(rightType, t => types_1.isStringType(t));
    if (leftIsString || rightIsString) {
        return LuauAST_1.default.binary(leftIsString ? left : LuauAST_1.default.call(LuauAST_1.default.globals.tostring, [left]), "..", rightIsString ? right : LuauAST_1.default.call(LuauAST_1.default.globals.tostring, [right]));
    }
    else {
        return LuauAST_1.default.binary(left, "+", right);
    }
}
function createBinaryFromOperator(state, node, left, leftType, operatorKind, right, rightType) {
    const operator = OPERATOR_MAP.get(operatorKind);
    if (operator !== undefined) {
        return LuauAST_1.default.binary(left, operator, right);
    }
    if (operatorKind === byots_1.default.SyntaxKind.PlusToken || operatorKind === byots_1.default.SyntaxKind.PlusEqualsToken) {
        return createBinaryAdd(left, leftType, right, rightType);
    }
    const bit32Name = BITWISE_OPERATOR_MAP.get(operatorKind);
    if (bit32Name !== undefined) {
        return LuauAST_1.default.call(LuauAST_1.default.property(LuauAST_1.default.globals.bit32, bit32Name), [left, right]);
    }
    if (operatorKind === byots_1.default.SyntaxKind.GreaterThanGreaterThanToken ||
        operatorKind === byots_1.default.SyntaxKind.GreaterThanGreaterThanEqualsToken) {
        return LuauAST_1.default.call(state.TS(node, "bit_lrsh"), [left, right]);
    }
    assert_1.assert(false, `Unrecognized operator: ${getKindName_1.getKindName(operatorKind)}`);
}
exports.createBinaryFromOperator = createBinaryFromOperator;
//# sourceMappingURL=createBinaryFromOperator.js.map