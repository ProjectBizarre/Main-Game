"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformBinaryExpression = void 0;
const byots_1 = __importDefault(require("byots"));
const LuauAST_1 = __importDefault(require("../../../LuauAST"));
const diagnostics_1 = require("../../../Shared/diagnostics");
const assert_1 = require("../../../Shared/util/assert");
const DiagnosticService_1 = require("../../classes/DiagnosticService");
const transformArrayBindingLiteral_1 = require("../binding/transformArrayBindingLiteral");
const transformObjectBindingLiteral_1 = require("../binding/transformObjectBindingLiteral");
const transformExpression_1 = require("./transformExpression");
const transformInitializer_1 = require("../transformInitializer");
const transformLogical_1 = require("../transformLogical");
const transformLogicalOrCoalescingAssignmentExpression_1 = require("../transformLogicalOrCoalescingAssignmentExpression");
const transformWritable_1 = require("../transformWritable");
const assignment_1 = require("../../util/assignment");
const getSubType_1 = require("../../util/binding/getSubType");
const convertToIndexableExpression_1 = require("../../util/convertToIndexableExpression");
const createBinaryFromOperator_1 = require("../../util/createBinaryFromOperator");
const ensureTransformOrder_1 = require("../../util/ensureTransformOrder");
const isUsedAsStatement_1 = require("../../util/isUsedAsStatement");
const traversal_1 = require("../../util/traversal");
const types_1 = require("../../util/types");
const validateNotAny_1 = require("../../util/validateNotAny");
function transformLuaTupleDestructure(state, bindingLiteral, value, accessType) {
    let index = 0;
    const variables = LuauAST_1.default.list.make();
    const writes = LuauAST_1.default.list.make();
    const statements = state.capturePrereqs(() => {
        for (let element of bindingLiteral.elements) {
            if (byots_1.default.isOmittedExpression(element)) {
                LuauAST_1.default.list.push(writes, LuauAST_1.default.emptyId());
            }
            else if (byots_1.default.isSpreadElement(element)) {
                DiagnosticService_1.DiagnosticService.addDiagnostic(diagnostics_1.errors.noSpreadDestructuring(element));
            }
            else {
                let initializer;
                if (byots_1.default.isBinaryExpression(element)) {
                    initializer = traversal_1.skipDownwards(element.right);
                    element = traversal_1.skipDownwards(element.left);
                }
                if (byots_1.default.isIdentifier(element) ||
                    byots_1.default.isElementAccessExpression(element) ||
                    byots_1.default.isPropertyAccessExpression(element)) {
                    const id = transformWritable_1.transformWritableExpression(state, element, true);
                    LuauAST_1.default.list.push(writes, id);
                    if (initializer) {
                        state.prereq(transformInitializer_1.transformInitializer(state, id, initializer));
                    }
                }
                else if (byots_1.default.isArrayLiteralExpression(element)) {
                    const id = LuauAST_1.default.tempId("binding");
                    LuauAST_1.default.list.push(variables, id);
                    LuauAST_1.default.list.push(writes, id);
                    if (initializer) {
                        state.prereq(transformInitializer_1.transformInitializer(state, id, initializer));
                    }
                    transformArrayBindingLiteral_1.transformArrayBindingLiteral(state, element, id, getSubType_1.getSubType(state, accessType, index));
                }
                else if (byots_1.default.isObjectLiteralExpression(element)) {
                    const id = LuauAST_1.default.tempId("binding");
                    LuauAST_1.default.list.push(variables, id);
                    LuauAST_1.default.list.push(writes, id);
                    if (initializer) {
                        state.prereq(transformInitializer_1.transformInitializer(state, id, initializer));
                    }
                    transformObjectBindingLiteral_1.transformObjectBindingLiteral(state, element, id, getSubType_1.getSubType(state, accessType, index));
                }
                else {
                    assert_1.assert(false);
                }
            }
            index++;
        }
    });
    if (!LuauAST_1.default.list.isEmpty(variables)) {
        state.prereq(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.VariableDeclaration, {
            left: variables,
            right: undefined,
        }));
    }
    if (LuauAST_1.default.list.isEmpty(writes)) {
        if (LuauAST_1.default.isCall(value)) {
            state.prereq(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.CallStatement, {
                expression: value,
            }));
        }
        else {
            state.prereq(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.VariableDeclaration, {
                left: LuauAST_1.default.list.make(LuauAST_1.default.emptyId()),
                right: value,
            }));
        }
    }
    else {
        state.prereq(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.Assignment, {
            left: writes,
            operator: "=",
            right: value,
        }));
    }
    state.prereqList(statements);
}
function transformBinaryExpression(state, node) {
    const operatorKind = node.operatorToken.kind;
    validateNotAny_1.validateNotAnyType(state, node.left);
    validateNotAny_1.validateNotAnyType(state, node.right);
    if (operatorKind === byots_1.default.SyntaxKind.EqualsEqualsToken) {
        DiagnosticService_1.DiagnosticService.addDiagnostic(diagnostics_1.errors.noEqualsEquals(node));
        return LuauAST_1.default.emptyId();
    }
    else if (operatorKind === byots_1.default.SyntaxKind.ExclamationEqualsToken) {
        DiagnosticService_1.DiagnosticService.addDiagnostic(diagnostics_1.errors.noExclamationEquals(node));
        return LuauAST_1.default.emptyId();
    }
    else if (operatorKind === byots_1.default.SyntaxKind.CommaToken) {
        DiagnosticService_1.DiagnosticService.addDiagnostic(diagnostics_1.errors.noComma(node));
        return LuauAST_1.default.emptyId();
    }
    if (operatorKind === byots_1.default.SyntaxKind.AmpersandAmpersandToken ||
        operatorKind === byots_1.default.SyntaxKind.BarBarToken ||
        operatorKind === byots_1.default.SyntaxKind.QuestionQuestionToken) {
        return transformLogical_1.transformLogical(state, node);
    }
    if (byots_1.default.isLogicalOrCoalescingAssignmentExpression(node)) {
        return transformLogicalOrCoalescingAssignmentExpression_1.transformLogicalOrCoalescingAssignmentExpression(state, node);
    }
    if (byots_1.default.isAssignmentOperator(operatorKind)) {
        if (byots_1.default.isArrayLiteralExpression(node.left)) {
            const rightExp = transformExpression_1.transformExpression(state, node.right);
            const accessType = state.getType(node.right);
            if (LuauAST_1.default.isCall(rightExp) && types_1.isLuaTupleType(state, accessType)) {
                transformLuaTupleDestructure(state, node.left, rightExp, accessType);
                if (!isUsedAsStatement_1.isUsedAsStatement(node)) {
                    DiagnosticService_1.DiagnosticService.addDiagnostic(diagnostics_1.errors.noDestructureAssignmentExpression(node));
                }
                return LuauAST_1.default.emptyId();
            }
            const parentId = state.pushToVar(rightExp, "binding");
            transformArrayBindingLiteral_1.transformArrayBindingLiteral(state, node.left, parentId, accessType);
            return parentId;
        }
        else if (byots_1.default.isObjectLiteralExpression(node.left)) {
            const parentId = state.pushToVar(transformExpression_1.transformExpression(state, node.right), "binding");
            const accessType = state.getType(node.right);
            transformObjectBindingLiteral_1.transformObjectBindingLiteral(state, node.left, parentId, accessType);
            return parentId;
        }
        const writableType = state.getType(node.left);
        const valueType = state.getType(node.right);
        const operator = assignment_1.getSimpleAssignmentOperator(writableType, operatorKind, valueType);
        const { writable, readable, value } = transformWritable_1.transformWritableAssignment(state, node.left, node.right, true, operator === undefined);
        if (operator !== undefined) {
            return assignment_1.createAssignmentExpression(state, writable, operator, operator === "..=" && !types_1.isDefinitelyType(valueType, t => types_1.isStringType(t))
                ? LuauAST_1.default.call(LuauAST_1.default.globals.tostring, [value])
                : value);
        }
        else {
            return assignment_1.createCompoundAssignmentExpression(state, node, writable, writableType, readable, operatorKind, value, valueType);
        }
    }
    const [left, right] = ensureTransformOrder_1.ensureTransformOrder(state, [node.left, node.right]);
    if (operatorKind === byots_1.default.SyntaxKind.InKeyword) {
        return LuauAST_1.default.binary(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.ComputedIndexExpression, {
            expression: convertToIndexableExpression_1.convertToIndexableExpression(right),
            index: left,
        }), "~=", LuauAST_1.default.nil());
    }
    else if (operatorKind === byots_1.default.SyntaxKind.InstanceOfKeyword) {
        return LuauAST_1.default.call(state.TS(node, "instanceof"), [left, right]);
    }
    const leftType = state.getType(node.left);
    const rightType = state.getType(node.right);
    if (operatorKind === byots_1.default.SyntaxKind.LessThanToken ||
        operatorKind === byots_1.default.SyntaxKind.LessThanEqualsToken ||
        operatorKind === byots_1.default.SyntaxKind.GreaterThanToken ||
        operatorKind === byots_1.default.SyntaxKind.GreaterThanEqualsToken) {
        if ((!types_1.isDefinitelyType(leftType, t => types_1.isStringType(t)) && !types_1.isDefinitelyType(leftType, t => types_1.isNumberType(t))) ||
            (!types_1.isDefinitelyType(rightType, t => types_1.isStringType(t)) && !types_1.isDefinitelyType(leftType, t => types_1.isNumberType(t)))) {
            DiagnosticService_1.DiagnosticService.addDiagnostic(diagnostics_1.errors.noNonNumberStringRelationOperator(node));
        }
    }
    return createBinaryFromOperator_1.createBinaryFromOperator(state, node, left, leftType, operatorKind, right, rightType);
}
exports.transformBinaryExpression = transformBinaryExpression;
//# sourceMappingURL=transformBinaryExpression.js.map