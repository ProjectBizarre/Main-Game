"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformPrefixUnaryExpression = exports.transformPostfixUnaryExpression = void 0;
const byots_1 = __importDefault(require("byots"));
const LuauAST_1 = __importDefault(require("../../../LuauAST"));
const diagnostics_1 = require("../../../Shared/diagnostics");
const assert_1 = require("../../../Shared/util/assert");
const DiagnosticService_1 = require("../../classes/DiagnosticService");
const transformExpression_1 = require("./transformExpression");
const transformWritable_1 = require("../transformWritable");
const createTruthinessChecks_1 = require("../../util/createTruthinessChecks");
const getKindName_1 = require("../../util/getKindName");
const types_1 = require("../../util/types");
const validateNotAny_1 = require("../../util/validateNotAny");
function transformPostfixUnaryExpression(state, node) {
    validateNotAny_1.validateNotAnyType(state, node.operand);
    const writable = transformWritable_1.transformWritableExpression(state, node.operand, true);
    const origValue = LuauAST_1.default.tempId("original");
    state.prereq(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.VariableDeclaration, {
        left: origValue,
        right: writable,
    }));
    const operator = node.operator === byots_1.default.SyntaxKind.PlusPlusToken ? "+=" : "-=";
    state.prereq(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.Assignment, {
        left: writable,
        operator,
        right: LuauAST_1.default.number(1),
    }));
    return origValue;
}
exports.transformPostfixUnaryExpression = transformPostfixUnaryExpression;
function transformPrefixUnaryExpression(state, node) {
    validateNotAny_1.validateNotAnyType(state, node.operand);
    if (node.operator === byots_1.default.SyntaxKind.PlusPlusToken || node.operator === byots_1.default.SyntaxKind.MinusMinusToken) {
        const writable = transformWritable_1.transformWritableExpression(state, node.operand, true);
        const operator = node.operator === byots_1.default.SyntaxKind.PlusPlusToken ? "+=" : "-=";
        state.prereq(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.Assignment, {
            left: writable,
            operator,
            right: LuauAST_1.default.number(1),
        }));
        return writable;
    }
    else if (node.operator === byots_1.default.SyntaxKind.PlusToken) {
        DiagnosticService_1.DiagnosticService.addDiagnostic(diagnostics_1.errors.noUnaryPlus(node));
        return transformExpression_1.transformExpression(state, node.operand);
    }
    else if (node.operator === byots_1.default.SyntaxKind.MinusToken) {
        if (!types_1.isDefinitelyType(state.getType(node.operand), t => types_1.isNumberType(t))) {
            DiagnosticService_1.DiagnosticService.addDiagnostic(diagnostics_1.errors.noNonNumberUnaryMinus(node));
        }
        return LuauAST_1.default.unary("-", transformExpression_1.transformExpression(state, node.operand));
    }
    else if (node.operator === byots_1.default.SyntaxKind.ExclamationToken) {
        const checks = createTruthinessChecks_1.createTruthinessChecks(state, transformExpression_1.transformExpression(state, node.operand), node.operand, state.getType(node.operand));
        return LuauAST_1.default.unary("not", checks);
    }
    else if (node.operator === byots_1.default.SyntaxKind.TildeToken) {
        return LuauAST_1.default.call(LuauAST_1.default.property(LuauAST_1.default.globals.bit32, "bnot"), [transformExpression_1.transformExpression(state, node.operand)]);
    }
    assert_1.assert(false, `Unsupported PrefixUnaryExpression operator: ${getKindName_1.getKindName(node.operator)}`);
}
exports.transformPrefixUnaryExpression = transformPrefixUnaryExpression;
//# sourceMappingURL=transformUnaryExpression.js.map