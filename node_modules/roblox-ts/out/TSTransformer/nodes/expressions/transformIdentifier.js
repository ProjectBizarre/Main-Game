"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformIdentifier = exports.transformIdentifierDefined = void 0;
const byots_1 = __importDefault(require("byots"));
const LuauAST_1 = __importDefault(require("../../../LuauAST"));
const diagnostics_1 = require("../../../Shared/diagnostics");
const assert_1 = require("../../../Shared/util/assert");
const getOrSetDefault_1 = require("../../../Shared/util/getOrSetDefault");
const TSTransformer_1 = require("../..");
const DiagnosticService_1 = require("../../classes/DiagnosticService");
const typeGuards_1 = require("../../typeGuards");
const isDefinedAsLet_1 = require("../../util/isDefinedAsLet");
const traversal_1 = require("../../util/traversal");
const types_1 = require("../../util/types");
function transformIdentifierDefined(state, node) {
    const symbol = byots_1.default.isShorthandPropertyAssignment(node.parent)
        ? state.typeChecker.getShorthandAssignmentValueSymbol(node.parent)
        : state.typeChecker.getSymbolAtLocation(node);
    assert_1.assert(symbol);
    const replacementId = state.symbolToIdMap.get(symbol);
    if (replacementId) {
        return replacementId;
    }
    return LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.Identifier, {
        name: node.text,
    });
}
exports.transformIdentifierDefined = transformIdentifierDefined;
function getAncestorWhichIsChildOf(parent, node) {
    while (node.parent && node.parent !== parent) {
        node = node.parent;
    }
    return node.parent ? node : undefined;
}
function getDeclarationFromImport(symbol) {
    var _a;
    for (const declaration of (_a = symbol.declarations) !== null && _a !== void 0 ? _a : []) {
        const importDec = traversal_1.getAncestor(declaration, byots_1.default.isImportDeclaration);
        if (importDec) {
            return declaration;
        }
    }
}
function checkIdentifierHoist(state, node, symbol) {
    var _a;
    if (state.isHoisted.get(symbol) !== undefined) {
        return;
    }
    const declaration = (_a = symbol.valueDeclaration) !== null && _a !== void 0 ? _a : getDeclarationFromImport(symbol);
    if (!declaration || traversal_1.getAncestor(declaration, byots_1.default.isParameter) || byots_1.default.isShorthandPropertyAssignment(declaration)) {
        return;
    }
    if (byots_1.default.isClassLike(declaration) && traversal_1.isAncestorOf(declaration, node)) {
        return;
    }
    const declarationStatement = traversal_1.getAncestor(declaration, byots_1.default.isStatement);
    if (!declarationStatement ||
        byots_1.default.isForStatement(declarationStatement) ||
        byots_1.default.isForOfStatement(declarationStatement) ||
        byots_1.default.isTryStatement(declarationStatement)) {
        return;
    }
    const parent = declarationStatement.parent;
    if (!parent || !typeGuards_1.isBlockLike(parent)) {
        return;
    }
    const sibling = getAncestorWhichIsChildOf(parent, node);
    if (!sibling || !byots_1.default.isStatement(sibling)) {
        return;
    }
    const declarationIdx = parent.statements.indexOf(declarationStatement);
    const siblingIdx = parent.statements.indexOf(sibling);
    if (siblingIdx > declarationIdx) {
        return;
    }
    if (siblingIdx === declarationIdx) {
        if ((byots_1.default.isFunctionDeclaration(declarationStatement) &&
            !byots_1.default.getSelectedSyntacticModifierFlags(declarationStatement, byots_1.default.ModifierFlags.Async)) ||
            byots_1.default.isClassDeclaration(declarationStatement) ||
            (byots_1.default.isVariableStatement(declarationStatement) && traversal_1.getAncestor(node, byots_1.default.isStatement) === declarationStatement)) {
            return;
        }
    }
    getOrSetDefault_1.getOrSetDefault(state.hoistsByStatement, sibling, () => new Array()).push(node);
    state.isHoisted.set(symbol, true);
    return;
}
function isValidObjectUse(node) {
    const parent = traversal_1.skipUpwards(node).parent;
    if (byots_1.default.isPropertyAccessExpression(parent) || byots_1.default.isElementAccessExpression(parent)) {
        const grandParent = traversal_1.skipUpwards(parent).parent;
        if (byots_1.default.isCallExpression(grandParent)) {
            return true;
        }
    }
    return false;
}
function transformIdentifier(state, node) {
    const symbol = byots_1.default.isShorthandPropertyAssignment(node.parent)
        ? state.typeChecker.getShorthandAssignmentValueSymbol(node.parent)
        : state.typeChecker.getSymbolAtLocation(node);
    assert_1.assert(symbol);
    if (state.typeChecker.isUndefinedSymbol(symbol)) {
        return LuauAST_1.default.nil();
    }
    else if (state.typeChecker.isArgumentsSymbol(symbol)) {
        DiagnosticService_1.DiagnosticService.addDiagnostic(diagnostics_1.errors.noArguments(node));
    }
    else if (symbol === state.services.globalSymbols.globalThis) {
        DiagnosticService_1.DiagnosticService.addDiagnostic(diagnostics_1.errors.noGlobalThis(node));
    }
    const macro = state.services.macroManager.getIdentifierMacro(symbol);
    if (macro) {
        return macro(state, node);
    }
    if (symbol === state.services.macroManager.getSymbolOrThrow(TSTransformer_1.SYMBOL_NAMES.Object) && !isValidObjectUse(node)) {
        DiagnosticService_1.DiagnosticService.addDiagnostic(diagnostics_1.errors.noObjectWithoutMethod(node));
    }
    const constructSymbol = types_1.getFirstConstructSymbol(state, node);
    if (constructSymbol) {
        const constructorMacro = state.services.macroManager.getConstructorMacro(constructSymbol);
        if (constructorMacro) {
            DiagnosticService_1.DiagnosticService.addDiagnostic(diagnostics_1.errors.noConstructorMacroWithoutNew(node));
        }
    }
    const parent = traversal_1.skipUpwards(node).parent;
    if ((!byots_1.default.isCallExpression(parent) || traversal_1.skipDownwards(parent.expression) != node) &&
        state.services.macroManager.getCallMacro(symbol)) {
        DiagnosticService_1.DiagnosticService.addDiagnostic(diagnostics_1.errors.noMacroWithoutCall(node));
        return LuauAST_1.default.emptyId();
    }
    if (symbol.valueDeclaration && symbol.valueDeclaration.getSourceFile() === node.getSourceFile()) {
        const exportAccess = state.getModuleIdPropertyAccess(symbol);
        if (exportAccess && isDefinedAsLet_1.isDefinedAsLet(state, symbol)) {
            return exportAccess;
        }
    }
    checkIdentifierHoist(state, node, symbol);
    return transformIdentifierDefined(state, node);
}
exports.transformIdentifier = transformIdentifier;
//# sourceMappingURL=transformIdentifier.js.map