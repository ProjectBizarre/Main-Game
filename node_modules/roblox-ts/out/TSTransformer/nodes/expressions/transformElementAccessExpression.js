"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformElementAccessExpression = exports.transformElementAccessExpressionInner = void 0;
const byots_1 = __importDefault(require("byots"));
const LuauAST_1 = __importDefault(require("../../../LuauAST"));
const diagnostics_1 = require("../../../Shared/diagnostics");
const DiagnosticService_1 = require("../../classes/DiagnosticService");
const transformExpression_1 = require("./transformExpression");
const transformOptionalChain_1 = require("../transformOptionalChain");
const addOneIfArrayType_1 = require("../../util/addOneIfArrayType");
const convertToIndexableExpression_1 = require("../../util/convertToIndexableExpression");
const isMethod_1 = require("../../util/isMethod");
const isValidMethodIndexWithoutCall_1 = require("../../util/isValidMethodIndexWithoutCall");
const offset_1 = require("../../util/offset");
const traversal_1 = require("../../util/traversal");
const types_1 = require("../../util/types");
const validateNotAny_1 = require("../../util/validateNotAny");
function transformElementAccessExpressionInner(state, node, expression, argumentExpression) {
    validateNotAny_1.validateNotAnyType(state, node.expression);
    validateNotAny_1.validateNotAnyType(state, node.argumentExpression);
    const expType = state.typeChecker.getNonOptionalType(state.getType(node.expression));
    const symbol = types_1.getFirstDefinedSymbol(state, expType);
    if (symbol) {
        if (state.services.macroManager.getPropertyCallMacro(symbol)) {
            DiagnosticService_1.DiagnosticService.addDiagnostic(diagnostics_1.errors.noMacroWithoutCall(node));
            return LuauAST_1.default.emptyId();
        }
    }
    const parent = traversal_1.skipUpwards(node).parent;
    if (!isValidMethodIndexWithoutCall_1.isValidMethodIndexWithoutCall(parent) && isMethod_1.isMethod(state, node)) {
        DiagnosticService_1.DiagnosticService.addDiagnostic(diagnostics_1.errors.noIndexWithoutCall(node));
        return LuauAST_1.default.emptyId();
    }
    if (byots_1.default.isPrototypeAccess(node)) {
        DiagnosticService_1.DiagnosticService.addDiagnostic(diagnostics_1.errors.noPrototype(node));
    }
    const constantValue = state.typeChecker.getConstantValue(node);
    if (constantValue !== undefined) {
        return typeof constantValue === "string" ? LuauAST_1.default.string(constantValue) : LuauAST_1.default.number(constantValue);
    }
    const [index, prereqs] = state.capture(() => transformExpression_1.transformExpression(state, argumentExpression));
    if (!LuauAST_1.default.list.isEmpty(prereqs)) {
        if (types_1.isLuaTupleType(state, expType)) {
            expression = LuauAST_1.default.array([expression]);
        }
        expression = state.pushToVar(expression, "exp");
        state.prereqList(prereqs);
    }
    if (LuauAST_1.default.isCall(expression) && types_1.isLuaTupleType(state, expType)) {
        if (!LuauAST_1.default.isNumberLiteral(index) || Number(index.value) !== 0) {
            expression = LuauAST_1.default.call(LuauAST_1.default.globals.select, [offset_1.offset(index, 1), expression]);
        }
        return LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.ParenthesizedExpression, { expression });
    }
    if (byots_1.default.isDeleteExpression(parent)) {
        state.prereq(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.Assignment, {
            left: LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.ComputedIndexExpression, {
                expression: convertToIndexableExpression_1.convertToIndexableExpression(expression),
                index: addOneIfArrayType_1.addOneIfArrayType(state, expType, index),
            }),
            operator: "=",
            right: LuauAST_1.default.nil(),
        }));
        return LuauAST_1.default.nil();
    }
    return LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.ComputedIndexExpression, {
        expression: convertToIndexableExpression_1.convertToIndexableExpression(expression),
        index: addOneIfArrayType_1.addOneIfArrayType(state, expType, index),
    });
}
exports.transformElementAccessExpressionInner = transformElementAccessExpressionInner;
function transformElementAccessExpression(state, node) {
    return transformOptionalChain_1.transformOptionalChain(state, node);
}
exports.transformElementAccessExpression = transformElementAccessExpression;
//# sourceMappingURL=transformElementAccessExpression.js.map