"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformTemplateExpression = void 0;
const LuauAST_1 = __importDefault(require("../../../LuauAST"));
const assert_1 = require("../../../Shared/util/assert");
const createStringFromLiteral_1 = require("../../util/createStringFromLiteral");
const ensureTransformOrder_1 = require("../../util/ensureTransformOrder");
const expressionChain_1 = require("../../util/expressionChain");
const types_1 = require("../../util/types");
function transformTemplateExpression(state, node) {
    assert_1.assert(node.templateSpans.length > 0);
    const expressions = new Array();
    if (node.head.text.length > 0) {
        expressions.push(createStringFromLiteral_1.createStringFromLiteral(node.head));
    }
    const orderedExpressions = ensureTransformOrder_1.ensureTransformOrder(state, node.templateSpans.map(templateSpan => templateSpan.expression));
    for (let i = 0; i < node.templateSpans.length; i++) {
        const templateSpan = node.templateSpans[i];
        let exp = orderedExpressions[i];
        if (!types_1.isDefinitelyType(state.getType(templateSpan.expression), t => types_1.isStringType(t))) {
            exp = LuauAST_1.default.call(LuauAST_1.default.globals.tostring, [exp]);
        }
        expressions.push(exp);
        if (templateSpan.literal.text.length > 0) {
            expressions.push(createStringFromLiteral_1.createStringFromLiteral(templateSpan.literal));
        }
    }
    return expressionChain_1.binaryExpressionChain(expressions, "..");
}
exports.transformTemplateExpression = transformTemplateExpression;
//# sourceMappingURL=transformTemplateExpression.js.map