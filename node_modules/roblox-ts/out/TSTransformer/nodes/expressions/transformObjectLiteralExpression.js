"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformObjectLiteralExpression = void 0;
const byots_1 = __importDefault(require("byots"));
const LuauAST_1 = __importDefault(require("../../../LuauAST"));
const diagnostics_1 = require("../../../Shared/diagnostics");
const DiagnosticService_1 = require("../../classes/DiagnosticService");
const transformExpression_1 = require("./transformExpression");
const transformMethodDeclaration_1 = require("../transformMethodDeclaration");
const transformObjectKey_1 = require("../transformObjectKey");
const createTypeCheck_1 = require("../../util/createTypeCheck");
const pointer_1 = require("../../util/pointer");
const types_1 = require("../../util/types");
function transformPropertyAssignment(state, ptr, name, initializer) {
    let [left, leftPrereqs] = state.capture(() => transformObjectKey_1.transformObjectKey(state, name));
    const [right, rightPrereqs] = state.capture(() => transformExpression_1.transformExpression(state, initializer));
    if (!LuauAST_1.default.list.isEmpty(leftPrereqs) || !LuauAST_1.default.list.isEmpty(rightPrereqs)) {
        pointer_1.disableMapInline(state, ptr);
        state.prereqList(leftPrereqs);
        left = state.pushToVar(left, "left");
    }
    state.prereqList(rightPrereqs);
    pointer_1.assignToMapPointer(state, ptr, left, right);
}
function transformSpreadAssignment(state, ptr, property) {
    const expType = state.typeChecker.getNonOptionalType(state.getType(property.expression));
    const symbol = types_1.getFirstDefinedSymbol(state, expType);
    if (symbol && state.services.macroManager.isMacroOnlyClass(symbol)) {
        DiagnosticService_1.DiagnosticService.addDiagnostic(diagnostics_1.errors.noMacroObjectSpread(property));
    }
    pointer_1.disableMapInline(state, ptr);
    let spreadExp = transformExpression_1.transformExpression(state, property.expression);
    const type = state.getType(property.expression);
    const possiblyUndefined = types_1.isPossiblyType(type, t => types_1.isUndefinedType(t));
    const isPossiblyNonObject = types_1.isPossiblyType(type, t => !types_1.isObjectType(t));
    if (possiblyUndefined || isPossiblyNonObject) {
        spreadExp = state.pushToVarIfComplex(spreadExp, "spread");
    }
    const keyId = LuauAST_1.default.tempId("k");
    const valueId = LuauAST_1.default.tempId("v");
    let statement = LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.ForStatement, {
        ids: LuauAST_1.default.list.make(keyId, valueId),
        expression: LuauAST_1.default.call(LuauAST_1.default.globals.pairs, [spreadExp]),
        statements: LuauAST_1.default.list.make(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.Assignment, {
            left: LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.ComputedIndexExpression, {
                expression: ptr.value,
                index: keyId,
            }),
            operator: "=",
            right: valueId,
        })),
    });
    if (isPossiblyNonObject) {
        statement = LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.IfStatement, {
            condition: createTypeCheck_1.createTypeCheck(spreadExp, LuauAST_1.default.strings.table),
            statements: LuauAST_1.default.list.make(statement),
            elseBody: LuauAST_1.default.list.make(),
        });
    }
    else if (possiblyUndefined) {
        statement = LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.IfStatement, {
            condition: spreadExp,
            statements: LuauAST_1.default.list.make(statement),
            elseBody: LuauAST_1.default.list.make(),
        });
    }
    state.prereq(statement);
}
function transformObjectLiteralExpression(state, node) {
    const ptr = { value: LuauAST_1.default.map() };
    for (const property of node.properties) {
        if (byots_1.default.isPropertyAssignment(property)) {
            if (byots_1.default.isPrivateIdentifier(property.name)) {
                DiagnosticService_1.DiagnosticService.addDiagnostic(diagnostics_1.errors.noPrivateIdentifier(property.name));
                continue;
            }
            transformPropertyAssignment(state, ptr, property.name, property.initializer);
        }
        else if (byots_1.default.isShorthandPropertyAssignment(property)) {
            transformPropertyAssignment(state, ptr, property.name, property.name);
        }
        else if (byots_1.default.isSpreadAssignment(property)) {
            transformSpreadAssignment(state, ptr, property);
        }
        else if (byots_1.default.isMethodDeclaration(property)) {
            state.prereqList(transformMethodDeclaration_1.transformMethodDeclaration(state, property, ptr));
        }
        else {
            DiagnosticService_1.DiagnosticService.addDiagnostic(diagnostics_1.errors.noGetterSetter(property));
        }
    }
    return ptr.value;
}
exports.transformObjectLiteralExpression = transformObjectLiteralExpression;
//# sourceMappingURL=transformObjectLiteralExpression.js.map