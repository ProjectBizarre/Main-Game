"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformLogicalOrCoalescingAssignmentExpressionStatement = exports.transformLogicalOrCoalescingAssignmentExpression = void 0;
const byots_1 = __importDefault(require("byots"));
const LuauAST_1 = __importDefault(require("../../LuauAST"));
const transformExpression_1 = require("./expressions/transformExpression");
const transformWritable_1 = require("./transformWritable");
const createTruthinessChecks_1 = require("../util/createTruthinessChecks");
function transformCoalescingAssignmentExpression(state, left, right) {
    const writable = transformWritable_1.transformWritableExpression(state, left, true);
    const [value, valuePreqreqs] = state.capture(() => transformExpression_1.transformExpression(state, right));
    const ifStatements = LuauAST_1.default.list.make();
    LuauAST_1.default.list.pushList(ifStatements, valuePreqreqs);
    LuauAST_1.default.list.push(ifStatements, LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.Assignment, {
        left: writable,
        operator: "=",
        right: value,
    }));
    state.prereq(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.IfStatement, {
        condition: LuauAST_1.default.binary(writable, "==", LuauAST_1.default.nil()),
        statements: ifStatements,
        elseBody: LuauAST_1.default.list.make(),
    }));
    return writable;
}
function transformLogicalAndAssignmentExpression(state, left, right) {
    const writableType = state.getType(left);
    const writable = transformWritable_1.transformWritableExpression(state, left, true);
    const [value, valuePreqreqs] = state.capture(() => transformExpression_1.transformExpression(state, right));
    const conditionId = state.pushToVar(writable, "condition");
    const ifStatements = LuauAST_1.default.list.make();
    LuauAST_1.default.list.pushList(ifStatements, valuePreqreqs);
    LuauAST_1.default.list.push(ifStatements, LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.Assignment, {
        left: conditionId,
        operator: "=",
        right: value,
    }));
    state.prereq(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.IfStatement, {
        condition: createTruthinessChecks_1.createTruthinessChecks(state, writable, left, writableType),
        statements: ifStatements,
        elseBody: LuauAST_1.default.list.make(),
    }));
    state.prereq(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.Assignment, {
        left: writable,
        operator: "=",
        right: conditionId,
    }));
    return writable;
}
function transformLogicalOrAssignmentExpression(state, left, right) {
    const writableType = state.getType(left);
    const writable = transformWritable_1.transformWritableExpression(state, left, true);
    const [value, valuePreqreqs] = state.capture(() => transformExpression_1.transformExpression(state, right));
    const conditionId = state.pushToVar(writable, "condition");
    const ifStatements = LuauAST_1.default.list.make();
    LuauAST_1.default.list.pushList(ifStatements, valuePreqreqs);
    LuauAST_1.default.list.push(ifStatements, LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.Assignment, {
        left: conditionId,
        operator: "=",
        right: value,
    }));
    state.prereq(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.IfStatement, {
        condition: LuauAST_1.default.unary("not", createTruthinessChecks_1.createTruthinessChecks(state, writable, left, writableType)),
        statements: ifStatements,
        elseBody: LuauAST_1.default.list.make(),
    }));
    state.prereq(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.Assignment, {
        left: writable,
        operator: "=",
        right: conditionId,
    }));
    return writable;
}
function transformLogicalOrCoalescingAssignmentExpression(state, node) {
    const operator = node.operatorToken.kind;
    if (operator === byots_1.default.SyntaxKind.QuestionQuestionEqualsToken) {
        return transformCoalescingAssignmentExpression(state, node.left, node.right);
    }
    else if (operator === byots_1.default.SyntaxKind.AmpersandAmpersandEqualsToken) {
        return transformLogicalAndAssignmentExpression(state, node.left, node.right);
    }
    else {
        return transformLogicalOrAssignmentExpression(state, node.left, node.right);
    }
}
exports.transformLogicalOrCoalescingAssignmentExpression = transformLogicalOrCoalescingAssignmentExpression;
function transformLogicalOrCoalescingAssignmentExpressionStatement(state, node) {
    return state.capturePrereqs(() => transformLogicalOrCoalescingAssignmentExpression(state, node));
}
exports.transformLogicalOrCoalescingAssignmentExpressionStatement = transformLogicalOrCoalescingAssignmentExpressionStatement;
//# sourceMappingURL=transformLogicalOrCoalescingAssignmentExpression.js.map