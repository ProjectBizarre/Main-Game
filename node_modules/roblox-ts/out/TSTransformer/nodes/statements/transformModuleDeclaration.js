"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformModuleDeclaration = void 0;
const byots_1 = __importDefault(require("byots"));
const LuauAST_1 = __importDefault(require("../../../LuauAST"));
const diagnostics_1 = require("../../../Shared/diagnostics");
const assert_1 = require("../../../Shared/util/assert");
const getOrSetDefault_1 = require("../../../Shared/util/getOrSetDefault");
const DiagnosticService_1 = require("../../classes/DiagnosticService");
const transformIdentifier_1 = require("../expressions/transformIdentifier");
const transformStatementList_1 = require("../transformStatementList");
const isDefinedAsLet_1 = require("../../util/isDefinedAsLet");
const isSymbolOfValue_1 = require("../../util/isSymbolOfValue");
const traversal_1 = require("../../util/traversal");
const validateIdentifier_1 = require("../../util/validateIdentifier");
function isDeclarationOfNamespace(declaration) {
    var _a;
    if ((_a = declaration.modifiers) === null || _a === void 0 ? void 0 : _a.some(v => v.kind === byots_1.default.SyntaxKind.DeclareKeyword)) {
        return false;
    }
    if (byots_1.default.isModuleDeclaration(declaration) && byots_1.default.isInstantiatedModule(declaration, false)) {
        return true;
    }
    else if (byots_1.default.isFunctionDeclaration(declaration) && declaration.body) {
        return true;
    }
    else if (byots_1.default.isClassDeclaration(declaration)) {
        return true;
    }
    return false;
}
function hasMultipleInstantiations(symbol) {
    let amtValueDeclarations = 0;
    const declarations = symbol.getDeclarations();
    if (declarations) {
        for (const declaration of declarations) {
            if (isDeclarationOfNamespace(declaration)) {
                amtValueDeclarations++;
                if (amtValueDeclarations > 1) {
                    return true;
                }
            }
        }
    }
    return false;
}
function getValueDeclarationStatement(symbol) {
    var _a, _b;
    for (const declaration of (_a = symbol.getDeclarations()) !== null && _a !== void 0 ? _a : []) {
        const statement = traversal_1.getAncestor(declaration, byots_1.default.isStatement);
        if (statement) {
            if (byots_1.default.isFunctionDeclaration(statement) && !statement.body)
                continue;
            if ((_b = statement.modifiers) === null || _b === void 0 ? void 0 : _b.some(v => v.kind === byots_1.default.SyntaxKind.DeclareKeyword))
                continue;
            return statement;
        }
    }
}
function transformNamespace(state, name, body) {
    const symbol = state.typeChecker.getSymbolAtLocation(name);
    assert_1.assert(symbol);
    validateIdentifier_1.validateIdentifier(state, name);
    const nameExp = transformIdentifier_1.transformIdentifierDefined(state, name);
    const statements = LuauAST_1.default.list.make();
    const doStatements = LuauAST_1.default.list.make();
    const containerId = LuauAST_1.default.tempId("container");
    state.setModuleIdBySymbol(symbol, containerId);
    if (state.isHoisted.get(symbol)) {
        LuauAST_1.default.list.push(statements, LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.Assignment, {
            left: nameExp,
            operator: "=",
            right: LuauAST_1.default.map(),
        }));
    }
    else {
        LuauAST_1.default.list.push(statements, LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.VariableDeclaration, {
            left: nameExp,
            right: LuauAST_1.default.map(),
        }));
    }
    const moduleExports = state.getModuleExports(symbol);
    if (moduleExports.length > 0) {
        LuauAST_1.default.list.push(doStatements, LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.VariableDeclaration, { left: containerId, right: nameExp }));
    }
    if (byots_1.default.isModuleBlock(body)) {
        const exportsMap = new Map();
        if (moduleExports.length > 0) {
            for (const exportSymbol of moduleExports) {
                const originalSymbol = byots_1.default.skipAlias(exportSymbol, state.typeChecker);
                if (isSymbolOfValue_1.isSymbolOfValue(originalSymbol) && !isDefinedAsLet_1.isDefinedAsLet(state, originalSymbol)) {
                    const valueDeclarationStatement = getValueDeclarationStatement(exportSymbol);
                    if (valueDeclarationStatement) {
                        getOrSetDefault_1.getOrSetDefault(exportsMap, valueDeclarationStatement, () => []).push(exportSymbol.name);
                    }
                }
            }
        }
        LuauAST_1.default.list.pushList(doStatements, transformStatementList_1.transformStatementList(state, body.statements, {
            id: containerId,
            mapping: exportsMap,
        }));
    }
    else {
        LuauAST_1.default.list.pushList(doStatements, transformNamespace(state, body.name, body.body));
        LuauAST_1.default.list.push(doStatements, LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.Assignment, {
            left: LuauAST_1.default.property(containerId, body.name.text),
            operator: "=",
            right: transformIdentifier_1.transformIdentifierDefined(state, body.name),
        }));
    }
    LuauAST_1.default.list.push(statements, LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.DoStatement, { statements: doStatements }));
    return statements;
}
function transformModuleDeclaration(state, node) {
    if (!byots_1.default.isInstantiatedModule(node, false)) {
        return LuauAST_1.default.list.make();
    }
    const symbol = state.typeChecker.getSymbolAtLocation(node.name);
    if (symbol && hasMultipleInstantiations(symbol)) {
        DiagnosticService_1.DiagnosticService.addDiagnostic(diagnostics_1.errors.noNamespaceMerging(node));
        return LuauAST_1.default.list.make();
    }
    assert_1.assert(!byots_1.default.isStringLiteral(node.name));
    assert_1.assert(node.body && !byots_1.default.isIdentifier(node.body));
    return transformNamespace(state, node.name, node.body);
}
exports.transformModuleDeclaration = transformModuleDeclaration;
//# sourceMappingURL=transformModuleDeclaration.js.map