"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformForOfStatement = void 0;
const byots_1 = __importDefault(require("byots"));
const LuauAST_1 = __importDefault(require("../../../LuauAST"));
const diagnostics_1 = require("../../../Shared/diagnostics");
const assert_1 = require("../../../Shared/util/assert");
const DiagnosticService_1 = require("../../classes/DiagnosticService");
const transformArrayBindingLiteral_1 = require("../binding/transformArrayBindingLiteral");
const transformBindingName_1 = require("../binding/transformBindingName");
const transformObjectBindingLiteral_1 = require("../binding/transformObjectBindingLiteral");
const transformExpression_1 = require("../expressions/transformExpression");
const transformInitializer_1 = require("../transformInitializer");
const transformStatementList_1 = require("../transformStatementList");
const transformWritable_1 = require("../transformWritable");
const getSubType_1 = require("../../util/binding/getSubType");
const convertToIndexableExpression_1 = require("../../util/convertToIndexableExpression");
const getStatements_1 = require("../../util/getStatements");
const traversal_1 = require("../../util/traversal");
const types_1 = require("../../util/types");
const validateIdentifier_1 = require("../../util/validateIdentifier");
function makeForLoopBuilder(callback) {
    return (state, statements, name, exp) => {
        const ids = LuauAST_1.default.list.make();
        const initializers = LuauAST_1.default.list.make();
        const expression = callback(state, name, exp, ids, initializers);
        LuauAST_1.default.list.unshiftList(statements, initializers);
        return LuauAST_1.default.list.make(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.ForStatement, { ids, expression, statements }));
    };
}
function getForInitializerAccessType(state, initializer) {
    const forOfStatement = initializer.parent;
    assert_1.assert(byots_1.default.isForOfStatement(forOfStatement));
    return getSubType_1.getSubType(state, state.getType(forOfStatement.expression), 0);
}
function transformForInitializerExpressionDirect(state, initializer, initializers, value) {
    if (byots_1.default.isArrayLiteralExpression(initializer)) {
        const [parentId, prereqs] = state.capture(() => {
            const parentId = state.pushToVar(value, "binding");
            transformArrayBindingLiteral_1.transformArrayBindingLiteral(state, initializer, parentId, getForInitializerAccessType(state, initializer));
            return parentId;
        });
        LuauAST_1.default.list.pushList(initializers, prereqs);
        return parentId;
    }
    else if (byots_1.default.isObjectLiteralExpression(initializer)) {
        const [parentId, prereqs] = state.capture(() => {
            const parentId = state.pushToVar(value, "binding");
            transformObjectBindingLiteral_1.transformObjectBindingLiteral(state, initializer, parentId, getForInitializerAccessType(state, initializer));
            return parentId;
        });
        LuauAST_1.default.list.pushList(initializers, prereqs);
        return parentId;
    }
    else {
        const expression = transformWritable_1.transformWritableExpression(state, initializer, false);
        LuauAST_1.default.list.push(initializers, LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.Assignment, {
            left: expression,
            operator: "=",
            right: value,
        }));
    }
}
function transformForInitializer(state, initializer, initializers) {
    if (byots_1.default.isVariableDeclarationList(initializer)) {
        return transformBindingName_1.transformBindingName(state, initializer.declarations[0].name, initializers);
    }
    else if (byots_1.default.isArrayLiteralExpression(initializer)) {
        const parentId = LuauAST_1.default.tempId("binding");
        LuauAST_1.default.list.pushList(initializers, state.capturePrereqs(() => transformArrayBindingLiteral_1.transformArrayBindingLiteral(state, initializer, parentId, getForInitializerAccessType(state, initializer))));
        return parentId;
    }
    else if (byots_1.default.isObjectLiteralExpression(initializer)) {
        const parentId = LuauAST_1.default.tempId("binding");
        LuauAST_1.default.list.pushList(initializers, state.capturePrereqs(() => transformObjectBindingLiteral_1.transformObjectBindingLiteral(state, initializer, parentId, getForInitializerAccessType(state, initializer))));
        return parentId;
    }
    else {
        const valueId = LuauAST_1.default.tempId("v");
        const expression = transformWritable_1.transformWritableExpression(state, initializer, false);
        LuauAST_1.default.list.push(initializers, LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.Assignment, {
            left: expression,
            operator: "=",
            right: valueId,
        }));
        return valueId;
    }
}
const buildArrayLoop = makeForLoopBuilder((state, initializer, exp, ids, initializers) => {
    LuauAST_1.default.list.push(ids, LuauAST_1.default.emptyId());
    LuauAST_1.default.list.push(ids, transformForInitializer(state, initializer, initializers));
    return LuauAST_1.default.call(LuauAST_1.default.globals.ipairs, [exp]);
});
const buildSetLoop = makeForLoopBuilder((state, initializer, exp, ids, initializers) => {
    LuauAST_1.default.list.push(ids, transformForInitializer(state, initializer, initializers));
    return LuauAST_1.default.call(LuauAST_1.default.globals.pairs, [exp]);
});
function transformInLineArrayBindingPattern(state, pattern, ids, initializers) {
    for (const element of pattern.elements) {
        if (byots_1.default.isOmittedExpression(element)) {
            LuauAST_1.default.list.push(ids, LuauAST_1.default.emptyId());
        }
        else if (byots_1.default.isSpreadElement(element)) {
            DiagnosticService_1.DiagnosticService.addDiagnostic(diagnostics_1.errors.noSpreadDestructuring(element));
        }
        else {
            const id = transformBindingName_1.transformBindingName(state, element.name, initializers);
            if (element.initializer) {
                LuauAST_1.default.list.push(initializers, transformInitializer_1.transformInitializer(state, id, element.initializer));
            }
            LuauAST_1.default.list.push(ids, id);
        }
    }
}
function transformInLineArrayBindingLiteral(state, bindingLiteral, ids, initializers) {
    LuauAST_1.default.list.pushList(initializers, state.capturePrereqs(() => {
        for (let element of bindingLiteral.elements) {
            if (byots_1.default.isOmittedExpression(element)) {
                LuauAST_1.default.list.push(ids, LuauAST_1.default.emptyId());
            }
            else if (byots_1.default.isSpreadElement(element)) {
                DiagnosticService_1.DiagnosticService.addDiagnostic(diagnostics_1.errors.noSpreadDestructuring(element));
            }
            else {
                let initializer;
                if (byots_1.default.isBinaryExpression(element)) {
                    initializer = traversal_1.skipDownwards(element.right);
                    element = traversal_1.skipDownwards(element.left);
                }
                const valueId = LuauAST_1.default.tempId("binding");
                if (byots_1.default.isIdentifier(element) ||
                    byots_1.default.isElementAccessExpression(element) ||
                    byots_1.default.isPropertyAccessExpression(element)) {
                    const id = transformWritable_1.transformWritableExpression(state, element, initializer !== undefined);
                    state.prereq(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.Assignment, {
                        left: id,
                        operator: "=",
                        right: valueId,
                    }));
                    if (initializer) {
                        state.prereq(transformInitializer_1.transformInitializer(state, id, initializer));
                    }
                }
                else if (byots_1.default.isArrayLiteralExpression(element)) {
                    if (initializer) {
                        state.prereq(transformInitializer_1.transformInitializer(state, valueId, initializer));
                    }
                    transformArrayBindingLiteral_1.transformArrayBindingLiteral(state, element, valueId, state.getType(element));
                }
                else if (byots_1.default.isObjectLiteralExpression(element)) {
                    if (initializer) {
                        state.prereq(transformInitializer_1.transformInitializer(state, valueId, initializer));
                    }
                    transformObjectBindingLiteral_1.transformObjectBindingLiteral(state, element, valueId, state.getType(element));
                }
                else {
                    assert_1.assert(false);
                }
                LuauAST_1.default.list.push(ids, valueId);
            }
        }
    }));
}
const buildMapLoop = makeForLoopBuilder((state, initializer, exp, ids, initializers) => {
    if (byots_1.default.isVariableDeclarationList(initializer)) {
        const name = initializer.declarations[0].name;
        if (byots_1.default.isArrayBindingPattern(name)) {
            transformInLineArrayBindingPattern(state, name, ids, initializers);
            return LuauAST_1.default.call(LuauAST_1.default.globals.pairs, [exp]);
        }
    }
    else if (byots_1.default.isArrayLiteralExpression(initializer)) {
        transformInLineArrayBindingLiteral(state, initializer, ids, initializers);
        return LuauAST_1.default.call(LuauAST_1.default.globals.pairs, [exp]);
    }
    const keyId = LuauAST_1.default.tempId("k");
    const valueId = LuauAST_1.default.tempId("v");
    LuauAST_1.default.list.push(ids, keyId);
    LuauAST_1.default.list.push(ids, valueId);
    if (byots_1.default.isVariableDeclarationList(initializer)) {
        const bindingList = LuauAST_1.default.list.make();
        LuauAST_1.default.list.push(initializers, LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.VariableDeclaration, {
            left: transformForInitializer(state, initializer, bindingList),
            right: LuauAST_1.default.array([keyId, valueId]),
        }));
        LuauAST_1.default.list.pushList(initializers, bindingList);
    }
    else {
        transformForInitializerExpressionDirect(state, initializer, initializers, LuauAST_1.default.array([keyId, valueId]));
    }
    return LuauAST_1.default.call(LuauAST_1.default.globals.pairs, [exp]);
});
const buildStringLoop = makeForLoopBuilder((state, initializer, exp, ids, initializers) => {
    LuauAST_1.default.list.push(ids, transformForInitializer(state, initializer, initializers));
    return LuauAST_1.default.call(LuauAST_1.default.globals.string.gmatch, [exp, LuauAST_1.default.globals.utf8.charpattern]);
});
const buildIterableFunctionLoop = makeForLoopBuilder((state, initializer, exp, ids, initializers) => {
    LuauAST_1.default.list.push(ids, transformForInitializer(state, initializer, initializers));
    return exp;
});
const buildIterableFunctionLuaTupleLoop = type => (state, statements, initializer, exp) => {
    if (byots_1.default.isVariableDeclarationList(initializer)) {
        const name = initializer.declarations[0].name;
        if (byots_1.default.isArrayBindingPattern(name)) {
            const ids = LuauAST_1.default.list.make();
            const initializers = LuauAST_1.default.list.make();
            transformInLineArrayBindingPattern(state, name, ids, initializers);
            LuauAST_1.default.list.unshiftList(statements, initializers);
            return LuauAST_1.default.list.make(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.ForStatement, { ids, expression: exp, statements }));
        }
    }
    else if (byots_1.default.isArrayLiteralExpression(initializer)) {
        const ids = LuauAST_1.default.list.make();
        const initializers = LuauAST_1.default.list.make();
        transformInLineArrayBindingLiteral(state, initializer, ids, initializers);
        LuauAST_1.default.list.unshiftList(statements, initializers);
        return LuauAST_1.default.list.make(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.ForStatement, { ids, expression: exp, statements }));
    }
    else {
        DiagnosticService_1.DiagnosticService.addDiagnostic(diagnostics_1.errors.noForOfLuaTupleAssignment(initializer.parent));
    }
    const iteratorReturnIds = new Array();
    const luaTupleType = types_1.getTypeArguments(state, type)[0];
    assert_1.assert(luaTupleType.aliasTypeArguments && luaTupleType.aliasTypeArguments.length > 0, "No LuaTuple<T> type arguments");
    const tupleArgType = luaTupleType.aliasTypeArguments[0];
    if (state.typeChecker.isTupleType(tupleArgType)) {
        const typeArguments = types_1.getTypeArguments(state, tupleArgType);
        for (let i = 0; i < typeArguments.length; i++) {
            iteratorReturnIds.push(LuauAST_1.default.tempId("element"));
        }
    }
    else {
        const iterFuncId = state.pushToVar(exp, "iterFunc");
        const loopStatements = LuauAST_1.default.list.make();
        const valueId = transformForInitializer(state, initializer, loopStatements);
        LuauAST_1.default.list.push(loopStatements, LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.VariableDeclaration, {
            left: valueId,
            right: LuauAST_1.default.array([LuauAST_1.default.call(iterFuncId)]),
        }));
        LuauAST_1.default.list.push(loopStatements, LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.IfStatement, {
            condition: LuauAST_1.default.binary(LuauAST_1.default.unary("#", valueId), "==", LuauAST_1.default.number(0)),
            statements: LuauAST_1.default.list.make(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.BreakStatement, {})),
            elseBody: LuauAST_1.default.list.make(),
        }));
        LuauAST_1.default.list.pushList(loopStatements, statements);
        return LuauAST_1.default.list.make(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.WhileStatement, {
            condition: LuauAST_1.default.bool(true),
            statements: loopStatements,
        }));
    }
    const tupleId = transformForInitializer(state, initializer, statements);
    const builder = makeForLoopBuilder((state, initializer, exp, ids, initializers) => {
        for (const id of iteratorReturnIds) {
            LuauAST_1.default.list.push(ids, id);
        }
        LuauAST_1.default.list.push(initializers, LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.VariableDeclaration, {
            left: tupleId,
            right: LuauAST_1.default.array(iteratorReturnIds),
        }));
        return exp;
    });
    return builder(state, statements, initializer, exp);
};
const buildGeneratorLoop = makeForLoopBuilder((state, initializer, exp, ids, initializers) => {
    const loopId = LuauAST_1.default.tempId("result");
    LuauAST_1.default.list.push(ids, loopId);
    LuauAST_1.default.list.push(initializers, LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.IfStatement, {
        condition: LuauAST_1.default.property(loopId, "done"),
        statements: LuauAST_1.default.list.make(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.BreakStatement, {})),
        elseBody: LuauAST_1.default.list.make(),
    }));
    if (byots_1.default.isVariableDeclarationList(initializer)) {
        const bindingList = LuauAST_1.default.list.make();
        LuauAST_1.default.list.push(initializers, LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.VariableDeclaration, {
            left: transformForInitializer(state, initializer, bindingList),
            right: LuauAST_1.default.property(loopId, "value"),
        }));
        LuauAST_1.default.list.pushList(initializers, bindingList);
    }
    else {
        transformForInitializerExpressionDirect(state, initializer, initializers, LuauAST_1.default.property(loopId, "value"));
    }
    return LuauAST_1.default.property(convertToIndexableExpression_1.convertToIndexableExpression(exp), "next");
});
function getLoopBuilder(state, node, type) {
    if (types_1.isDefinitelyType(type, t => types_1.isArrayType(state, t))) {
        return buildArrayLoop;
    }
    else if (types_1.isDefinitelyType(type, t => types_1.isSetType(state, t))) {
        return buildSetLoop;
    }
    else if (types_1.isDefinitelyType(type, t => types_1.isMapType(state, t))) {
        return buildMapLoop;
    }
    else if (types_1.isDefinitelyType(type, t => types_1.isStringType(t))) {
        return buildStringLoop;
    }
    else if (types_1.isDefinitelyType(type, t => types_1.isIterableFunctionLuaTupleType(state, t))) {
        return buildIterableFunctionLuaTupleLoop(type);
    }
    else if (types_1.isDefinitelyType(type, t => types_1.isIterableFunctionType(state, t))) {
        return buildIterableFunctionLoop;
    }
    else if (types_1.isDefinitelyType(type, t => types_1.isGeneratorType(state, t))) {
        return buildGeneratorLoop;
    }
    else if (types_1.isDefinitelyType(type, t => types_1.isIterableType(state, t))) {
        DiagnosticService_1.DiagnosticService.addDiagnostic(diagnostics_1.errors.noIterableIteration(node));
        return () => LuauAST_1.default.list.make();
    }
    else if (type.isUnion()) {
        DiagnosticService_1.DiagnosticService.addDiagnostic(diagnostics_1.errors.noMacroUnion(node));
        return () => LuauAST_1.default.list.make();
    }
    else {
        assert_1.assert(false, `ForOf iteration type not implemented: ${state.typeChecker.typeToString(type)}`);
    }
}
function transformForOfStatement(state, node) {
    if (node.awaitModifier) {
        DiagnosticService_1.DiagnosticService.addDiagnostic(diagnostics_1.errors.noAwaitForOf(node));
    }
    if (byots_1.default.isVariableDeclarationList(node.initializer)) {
        const name = node.initializer.declarations[0].name;
        if (byots_1.default.isIdentifier(name)) {
            validateIdentifier_1.validateIdentifier(state, name);
        }
    }
    const result = LuauAST_1.default.list.make();
    const [exp, expPrereqs] = state.capture(() => transformExpression_1.transformExpression(state, node.expression));
    LuauAST_1.default.list.pushList(result, expPrereqs);
    const expType = state.getType(node.expression);
    const statements = transformStatementList_1.transformStatementList(state, getStatements_1.getStatements(node.statement));
    const loopBuilder = getLoopBuilder(state, node.expression, expType);
    LuauAST_1.default.list.pushList(result, loopBuilder(state, statements, node.initializer, exp));
    return result;
}
exports.transformForOfStatement = transformForOfStatement;
//# sourceMappingURL=transformForOfStatement.js.map