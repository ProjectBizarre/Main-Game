"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformExpressionStatement = exports.transformExpressionStatementInner = void 0;
const byots_1 = __importDefault(require("byots"));
const LuauAST_1 = __importDefault(require("../../../LuauAST"));
const transformExpression_1 = require("../expressions/transformExpression");
const transformLogicalOrCoalescingAssignmentExpression_1 = require("../transformLogicalOrCoalescingAssignmentExpression");
const transformWritable_1 = require("../transformWritable");
const typeGuards_1 = require("../../typeGuards");
const assignment_1 = require("../../util/assignment");
const traversal_1 = require("../../util/traversal");
const types_1 = require("../../util/types");
function transformUnaryExpressionStatement(state, node) {
    const writable = transformWritable_1.transformWritableExpression(state, node.operand, false);
    const operator = node.operator === byots_1.default.SyntaxKind.PlusPlusToken ? "+=" : "-=";
    return LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.Assignment, {
        left: writable,
        operator,
        right: LuauAST_1.default.number(1),
    });
}
function transformExpressionStatementInner(state, expression) {
    if (byots_1.default.isBinaryExpression(expression)) {
        const operatorKind = expression.operatorToken.kind;
        if (byots_1.default.isLogicalOrCoalescingAssignmentExpression(expression)) {
            return transformLogicalOrCoalescingAssignmentExpression_1.transformLogicalOrCoalescingAssignmentExpressionStatement(state, expression);
        }
        else if (byots_1.default.isAssignmentOperator(operatorKind) &&
            !byots_1.default.isArrayLiteralExpression(expression.left) &&
            !byots_1.default.isObjectLiteralExpression(expression.left)) {
            const writableType = state.getType(expression.left);
            const valueType = state.getType(expression.right);
            const operator = assignment_1.getSimpleAssignmentOperator(writableType, operatorKind, valueType);
            const { writable, readable, value } = transformWritable_1.transformWritableAssignment(state, expression.left, expression.right, operator === undefined, operator === undefined);
            if (operator !== undefined) {
                return LuauAST_1.default.list.make(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.Assignment, {
                    left: writable,
                    operator,
                    right: operator === "..=" && !types_1.isDefinitelyType(valueType, t => types_1.isStringType(t))
                        ? LuauAST_1.default.call(LuauAST_1.default.globals.tostring, [value])
                        : value,
                }));
            }
            else {
                return LuauAST_1.default.list.make(assignment_1.createCompoundAssignmentStatement(state, expression, writable, writableType, readable, operatorKind, value, valueType));
            }
        }
    }
    else if ((byots_1.default.isPrefixUnaryExpression(expression) || byots_1.default.isPostfixUnaryExpression(expression)) &&
        typeGuards_1.isUnaryAssignmentOperator(expression.operator)) {
        return LuauAST_1.default.list.make(transformUnaryExpressionStatement(state, expression));
    }
    const transformed = transformExpression_1.transformExpression(state, expression);
    if (LuauAST_1.default.isEmptyIdentifier(transformed) ||
        LuauAST_1.default.isTemporaryIdentifier(transformed) ||
        LuauAST_1.default.isNilLiteral(transformed)) {
        return LuauAST_1.default.list.make();
    }
    else if (LuauAST_1.default.isCall(transformed)) {
        return LuauAST_1.default.list.make(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.CallStatement, { expression: transformed }));
    }
    else {
        return LuauAST_1.default.list.make(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.VariableDeclaration, {
            left: LuauAST_1.default.emptyId(),
            right: transformed,
        }));
    }
}
exports.transformExpressionStatementInner = transformExpressionStatementInner;
function transformExpressionStatement(state, node) {
    const expression = traversal_1.skipDownwards(node.expression);
    return transformExpressionStatementInner(state, expression);
}
exports.transformExpressionStatement = transformExpressionStatement;
//# sourceMappingURL=transformExpressionStatement.js.map