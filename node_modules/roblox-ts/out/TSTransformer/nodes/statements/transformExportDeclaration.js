"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformExportDeclaration = void 0;
const byots_1 = __importDefault(require("byots"));
const LuauAST_1 = __importDefault(require("../../../LuauAST"));
const assert_1 = require("../../../Shared/util/assert");
const cleanModuleName_1 = require("../../util/cleanModuleName");
const createImportExpression_1 = require("../../util/createImportExpression");
const isSymbolOfValue_1 = require("../../util/isSymbolOfValue");
function isExportSpecifierValue(state, element) {
    if (state.resolver.isReferencedAliasDeclaration(element)) {
        return true;
    }
    const aliasSymbol = state.typeChecker.getSymbolAtLocation(element.name);
    if (aliasSymbol && isSymbolOfValue_1.isSymbolOfValue(byots_1.default.skipAlias(aliasSymbol, state.typeChecker))) {
        return true;
    }
    return false;
}
function countImportExpUses(state, exportClause) {
    let uses = 0;
    if (exportClause && byots_1.default.isNamedExports(exportClause)) {
        for (const element of exportClause.elements) {
            if (isExportSpecifierValue(state, element)) {
                uses++;
            }
        }
    }
    else {
        uses++;
    }
    return uses;
}
function transformExportFrom(state, node) {
    var _a;
    assert_1.assert(node.moduleSpecifier && byots_1.default.isStringLiteral(node.moduleSpecifier));
    const statements = LuauAST_1.default.list.make();
    let importExp;
    const exportClause = node.exportClause;
    const uses = countImportExpUses(state, exportClause);
    if (uses === 1) {
        importExp = createImportExpression_1.createImportExpression(state, node.getSourceFile(), node.moduleSpecifier);
    }
    else if (uses > 1) {
        const moduleName = node.moduleSpecifier.text.split("/");
        importExp = LuauAST_1.default.tempId(cleanModuleName_1.cleanModuleName(moduleName[moduleName.length - 1]));
        LuauAST_1.default.list.push(statements, LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.VariableDeclaration, {
            left: importExp,
            right: createImportExpression_1.createImportExpression(state, node.getSourceFile(), node.moduleSpecifier),
        }));
    }
    if (!importExp) {
        return statements;
    }
    const moduleId = state.getModuleIdFromNode(node);
    if (exportClause) {
        if (byots_1.default.isNamedExports(exportClause)) {
            for (const element of exportClause.elements) {
                if (isExportSpecifierValue(state, element)) {
                    LuauAST_1.default.list.push(statements, LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.Assignment, {
                        left: LuauAST_1.default.property(moduleId, element.name.text),
                        operator: "=",
                        right: LuauAST_1.default.property(importExp, ((_a = element.propertyName) !== null && _a !== void 0 ? _a : element.name).text),
                    }));
                }
            }
        }
        else {
            LuauAST_1.default.list.push(statements, LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.Assignment, {
                left: LuauAST_1.default.property(moduleId, exportClause.name.text),
                operator: "=",
                right: importExp,
            }));
        }
    }
    else {
        const keyId = LuauAST_1.default.tempId("k");
        const valueId = LuauAST_1.default.tempId("v");
        LuauAST_1.default.list.push(statements, LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.ForStatement, {
            ids: LuauAST_1.default.list.make(keyId, valueId),
            expression: LuauAST_1.default.call(LuauAST_1.default.globals.pairs, [importExp]),
            statements: LuauAST_1.default.list.make(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.Assignment, {
                left: LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.ComputedIndexExpression, {
                    expression: moduleId,
                    index: keyId,
                }),
                operator: "=",
                right: valueId,
            })),
        }));
    }
    state.hasExportFrom = true;
    return statements;
}
function transformExportDeclaration(state, node) {
    if (node.isTypeOnly)
        return LuauAST_1.default.list.make();
    if (node.moduleSpecifier) {
        return transformExportFrom(state, node);
    }
    return LuauAST_1.default.list.make();
}
exports.transformExportDeclaration = transformExportDeclaration;
//# sourceMappingURL=transformExportDeclaration.js.map