"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformEnumDeclaration = void 0;
const byots_1 = __importDefault(require("byots"));
const LuauAST_1 = __importDefault(require("../../../LuauAST"));
const diagnostics_1 = require("../../../Shared/diagnostics");
const assert_1 = require("../../../Shared/util/assert");
const DiagnosticService_1 = require("../../classes/DiagnosticService");
const transformExpression_1 = require("../expressions/transformExpression");
const transformIdentifier_1 = require("../expressions/transformIdentifier");
const validateIdentifier_1 = require("../../util/validateIdentifier");
function hasMultipleDefinitions(symbol) {
    var _a;
    let amtValueDefinitions = 0;
    for (const declaration of (_a = symbol.getDeclarations()) !== null && _a !== void 0 ? _a : []) {
        if (byots_1.default.isEnumDeclaration(declaration) &&
            !byots_1.default.getSelectedSyntacticModifierFlags(declaration, byots_1.default.ModifierFlags.Const)) {
            amtValueDefinitions++;
            if (amtValueDefinitions > 1) {
                return true;
            }
        }
    }
    return false;
}
function transformEnumDeclaration(state, node) {
    if (!!byots_1.default.getSelectedSyntacticModifierFlags(node, byots_1.default.ModifierFlags.Const)) {
        return LuauAST_1.default.list.make();
    }
    const symbol = state.typeChecker.getSymbolAtLocation(node.name);
    if (symbol && hasMultipleDefinitions(symbol)) {
        DiagnosticService_1.DiagnosticService.addDiagnostic(diagnostics_1.errors.noEnumMerging(node));
        return LuauAST_1.default.list.make();
    }
    validateIdentifier_1.validateIdentifier(state, node.name);
    const id = transformIdentifier_1.transformIdentifierDefined(state, node.name);
    const statements = state.capturePrereqs(() => {
        const inverseId = state.pushToVar(LuauAST_1.default.map(), "inverse");
        state.prereq(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.Assignment, {
            left: id,
            operator: "=",
            right: LuauAST_1.default.call(LuauAST_1.default.globals.setmetatable, [
                LuauAST_1.default.map(),
                LuauAST_1.default.map([[LuauAST_1.default.strings.__index, inverseId]]),
            ]),
        }));
        for (const member of node.members) {
            assert_1.assert(byots_1.default.isIdentifier(member.name) || byots_1.default.isStringLiteral(member.name));
            const nameStr = member.name.text;
            const value = state.typeChecker.getConstantValue(member);
            let valueExp;
            if (typeof value === "string") {
                valueExp = LuauAST_1.default.string(value);
            }
            else if (typeof value === "number") {
                valueExp = LuauAST_1.default.number(value);
            }
            else {
                assert_1.assert(member.initializer);
                valueExp = state.pushToVarIfComplex(transformExpression_1.transformExpression(state, member.initializer), "value");
            }
            state.prereq(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.Assignment, {
                left: LuauAST_1.default.property(id, nameStr),
                operator: "=",
                right: valueExp,
            }));
            state.prereq(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.Assignment, {
                left: LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.ComputedIndexExpression, {
                    expression: inverseId,
                    index: valueExp,
                }),
                operator: "=",
                right: LuauAST_1.default.string(nameStr),
            }));
        }
    });
    return LuauAST_1.default.list.make(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.VariableDeclaration, { left: id, right: undefined }), LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.DoStatement, { statements }));
}
exports.transformEnumDeclaration = transformEnumDeclaration;
//# sourceMappingURL=transformEnumDeclaration.js.map