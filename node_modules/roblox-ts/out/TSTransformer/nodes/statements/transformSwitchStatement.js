"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformSwitchStatement = void 0;
const byots_1 = __importDefault(require("byots"));
const LuauAST_1 = __importDefault(require("../../../LuauAST"));
const transformExpression_1 = require("../expressions/transformExpression");
const transformStatementList_1 = require("../transformStatementList");
const createHoistDeclaration_1 = require("../../util/createHoistDeclaration");
function transformCaseClauseExpression(state, caseClauseExpression, switchExpression, fallThroughFlagId, canFallThroughTo) {
    let [expression, prereqStatements] = state.capture(() => transformExpression_1.transformExpression(state, caseClauseExpression));
    expression = LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.ParenthesizedExpression, { expression });
    let condition = LuauAST_1.default.binary(switchExpression, "==", expression);
    if (canFallThroughTo) {
        if (!LuauAST_1.default.list.isEmpty(prereqStatements)) {
            const noFallThroughCondition = LuauAST_1.default.unary("not", fallThroughFlagId);
            LuauAST_1.default.list.push(prereqStatements, LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.Assignment, {
                left: fallThroughFlagId,
                operator: "=",
                right: condition,
            }));
            prereqStatements = LuauAST_1.default.list.make(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.IfStatement, {
                condition: noFallThroughCondition,
                statements: prereqStatements,
                elseBody: LuauAST_1.default.list.make(),
            }));
            condition = fallThroughFlagId;
        }
        else {
            condition = LuauAST_1.default.binary(fallThroughFlagId, "or", condition);
        }
    }
    return {
        condition,
        prereqStatements,
    };
}
function transformCaseClause(state, node, switchExpression, fallThroughFlagId, canFallThroughTo, shouldUpdateFallThroughFlag) {
    const { condition, prereqStatements } = transformCaseClauseExpression(state, node.expression, switchExpression, fallThroughFlagId, canFallThroughTo);
    const nonEmptyStatements = node.statements.filter(v => !byots_1.default.isEmptyStatement(v));
    const firstStatement = nonEmptyStatements[0];
    const statements = transformStatementList_1.transformStatementList(state, nonEmptyStatements.length === 1 && byots_1.default.isBlock(firstStatement) ? firstStatement.statements : node.statements);
    const canFallThroughFrom = statements.tail === undefined || !LuauAST_1.default.isFinalStatement(statements.tail.value);
    if (canFallThroughFrom && shouldUpdateFallThroughFlag) {
        LuauAST_1.default.list.push(statements, LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.Assignment, {
            left: fallThroughFlagId,
            operator: "=",
            right: LuauAST_1.default.bool(true),
        }));
    }
    const clauseStatements = LuauAST_1.default.list.make();
    const hoistDeclaration = createHoistDeclaration_1.createHoistDeclaration(state, node);
    if (hoistDeclaration) {
        LuauAST_1.default.list.push(clauseStatements, hoistDeclaration);
    }
    LuauAST_1.default.list.push(clauseStatements, LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.IfStatement, {
        condition,
        statements,
        elseBody: LuauAST_1.default.list.make(),
    }));
    return {
        canFallThroughFrom,
        prereqs: prereqStatements,
        clauseStatements,
    };
}
function transformSwitchStatement(state, node) {
    const expression = state.pushToVarIfComplex(transformExpression_1.transformExpression(state, node.expression), "exp");
    const fallThroughFlagId = LuauAST_1.default.tempId("fallthrough");
    let isFallThroughFlagNeeded = false;
    const statements = LuauAST_1.default.list.make();
    let canFallThroughTo = false;
    for (let i = 0; i < node.caseBlock.clauses.length; i++) {
        const caseClauseNode = node.caseBlock.clauses[i];
        if (byots_1.default.isCaseClause(caseClauseNode)) {
            const shouldUpdateFallThroughFlag = i < node.caseBlock.clauses.length - 1 && byots_1.default.isCaseClause(node.caseBlock.clauses[i + 1]);
            const { canFallThroughFrom, prereqs, clauseStatements } = transformCaseClause(state, caseClauseNode, expression, fallThroughFlagId, canFallThroughTo, shouldUpdateFallThroughFlag);
            LuauAST_1.default.list.pushList(statements, prereqs);
            LuauAST_1.default.list.pushList(statements, clauseStatements);
            canFallThroughTo = canFallThroughFrom;
            if (canFallThroughFrom) {
                isFallThroughFlagNeeded = true;
            }
        }
        else {
            LuauAST_1.default.list.pushList(statements, transformStatementList_1.transformStatementList(state, caseClauseNode.statements));
            break;
        }
    }
    if (isFallThroughFlagNeeded) {
        LuauAST_1.default.list.unshift(statements, LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.VariableDeclaration, {
            left: fallThroughFlagId,
            right: LuauAST_1.default.bool(false),
        }));
    }
    return LuauAST_1.default.list.make(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.RepeatStatement, {
        condition: LuauAST_1.default.bool(true),
        statements,
    }));
}
exports.transformSwitchStatement = transformSwitchStatement;
//# sourceMappingURL=transformSwitchStatement.js.map