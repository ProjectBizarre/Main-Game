"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformClassLikeDeclaration = void 0;
const byots_1 = __importDefault(require("byots"));
const LuauAST_1 = __importDefault(require("../../../LuauAST"));
const diagnostics_1 = require("../../../Shared/diagnostics");
const assert_1 = require("../../../Shared/util/assert");
const TSTransformer_1 = require("../..");
const DiagnosticService_1 = require("../../classes/DiagnosticService");
const transformClassConstructor_1 = require("./transformClassConstructor");
const transformPropertyDeclaration_1 = require("./transformPropertyDeclaration");
const transformExpression_1 = require("../expressions/transformExpression");
const transformIdentifier_1 = require("../expressions/transformIdentifier");
const transformMethodDeclaration_1 = require("../transformMethodDeclaration");
const convertToIndexableExpression_1 = require("../../util/convertToIndexableExpression");
const extendsRoactComponent_1 = require("../../util/extendsRoactComponent");
const getExtendsNode_1 = require("../../util/getExtendsNode");
const getKindName_1 = require("../../util/getKindName");
const validateIdentifier_1 = require("../../util/validateIdentifier");
const MAGIC_TO_STRING_METHOD = "toString";
function getConstructor(node) {
    return node.members.find((element) => byots_1.default.isConstructorDeclaration(element) && element.body !== undefined);
}
function createNameFunction(name) {
    return LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.FunctionExpression, {
        statements: LuauAST_1.default.list.make(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.ReturnStatement, {
            expression: LuauAST_1.default.string(name),
        })),
        parameters: LuauAST_1.default.list.make(),
        hasDotDotDot: false,
    });
}
function createRoactBoilerplate(state, node, className, isClassExpression) {
    const extendsNode = getExtendsNode_1.getExtendsNode(node);
    assert_1.assert(extendsNode);
    const statements = LuauAST_1.default.list.make();
    const [extendsExp, extendsExpPrereqs] = state.capture(() => transformExpression_1.transformExpression(state, extendsNode.expression));
    LuauAST_1.default.list.pushList(statements, extendsExpPrereqs);
    const classNameStr = LuauAST_1.default.isIdentifier(className) ? className.name : "Anonymous";
    const right = LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.MethodCallExpression, {
        expression: convertToIndexableExpression_1.convertToIndexableExpression(extendsExp),
        name: "extend",
        args: LuauAST_1.default.list.make(LuauAST_1.default.string(classNameStr)),
    });
    if (isClassExpression && node.name) {
        LuauAST_1.default.list.push(statements, LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.VariableDeclaration, {
            left: transformIdentifier_1.transformIdentifierDefined(state, node.name),
            right,
        }));
    }
    else {
        LuauAST_1.default.list.push(statements, LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.Assignment, {
            left: className,
            operator: "=",
            right,
        }));
    }
    return statements;
}
function getExtendsDeclaration(state, extendsExp) {
    if (byots_1.default.isClassLike(extendsExp)) {
        return extendsExp;
    }
    const symbol = state.typeChecker.getSymbolAtLocation(extendsExp);
    if (symbol && symbol.valueDeclaration && byots_1.default.isClassLike(symbol.valueDeclaration)) {
        return symbol.valueDeclaration;
    }
}
function createBoilerplate(state, node, className, isClassExpression) {
    const isAbstract = !!byots_1.default.getSelectedSyntacticModifierFlags(node, byots_1.default.ModifierFlags.Abstract);
    const statements = LuauAST_1.default.list.make();
    const extendsNode = getExtendsNode_1.getExtendsNode(node);
    if (isAbstract && !extendsNode) {
        LuauAST_1.default.list.push(statements, LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.Assignment, {
            left: className,
            operator: "=",
            right: LuauAST_1.default.mixedTable(),
        }));
    }
    else {
        const metatableFields = LuauAST_1.default.list.make();
        LuauAST_1.default.list.push(metatableFields, LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.MapField, {
            index: LuauAST_1.default.strings.__tostring,
            value: createNameFunction(LuauAST_1.default.isTemporaryIdentifier(className) ? "Anonymous" : className.name),
        }));
        if (extendsNode) {
            const extendsDec = getExtendsDeclaration(state, extendsNode.expression);
            if (extendsDec && extendsRoactComponent_1.extendsRoactComponent(state, extendsDec)) {
                DiagnosticService_1.DiagnosticService.addDiagnostic(diagnostics_1.errors.noRoactInheritance(node));
            }
            const [extendsExp, extendsExpPrereqs] = state.capture(() => transformExpression_1.transformExpression(state, extendsNode.expression));
            const superId = LuauAST_1.default.id("super");
            LuauAST_1.default.list.pushList(statements, extendsExpPrereqs);
            LuauAST_1.default.list.push(statements, LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.VariableDeclaration, {
                left: superId,
                right: extendsExp,
            }));
            LuauAST_1.default.list.push(metatableFields, LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.MapField, {
                index: LuauAST_1.default.strings.__index,
                value: superId,
            }));
        }
        const metatable = LuauAST_1.default.call(LuauAST_1.default.globals.setmetatable, [
            LuauAST_1.default.map(),
            LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.Map, { fields: metatableFields }),
        ]);
        if (isClassExpression && node.name) {
            LuauAST_1.default.list.push(statements, LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.VariableDeclaration, {
                left: transformIdentifier_1.transformIdentifierDefined(state, node.name),
                right: metatable,
            }));
        }
        else {
            LuauAST_1.default.list.push(statements, LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.Assignment, {
                left: className,
                operator: "=",
                right: metatable,
            }));
        }
        LuauAST_1.default.list.push(statements, LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.Assignment, {
            left: LuauAST_1.default.property(className, "__index"),
            operator: "=",
            right: className,
        }));
    }
    if (!isAbstract) {
        const statementsInner = LuauAST_1.default.list.make();
        LuauAST_1.default.list.push(statementsInner, LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.VariableDeclaration, {
            left: LuauAST_1.default.globals.self,
            right: LuauAST_1.default.call(LuauAST_1.default.globals.setmetatable, [LuauAST_1.default.map(), className]),
        }));
        LuauAST_1.default.list.push(statementsInner, LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.ReturnStatement, {
            expression: LuauAST_1.default.binary(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.MethodCallExpression, {
                expression: LuauAST_1.default.globals.self,
                name: "constructor",
                args: LuauAST_1.default.list.make(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.VarArgsLiteral, {})),
            }), "or", LuauAST_1.default.globals.self),
        }));
        LuauAST_1.default.list.push(statements, LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.FunctionDeclaration, {
            name: LuauAST_1.default.property(className, "new"),
            parameters: LuauAST_1.default.list.make(),
            hasDotDotDot: true,
            statements: statementsInner,
            localize: false,
        }));
    }
    return statements;
}
function extendsMacroClass(state, node) {
    const extendsNode = getExtendsNode_1.getExtendsNode(node);
    if (extendsNode) {
        const aliasSymbol = state.getType(extendsNode.expression).symbol;
        if (aliasSymbol) {
            const originalSymbol = byots_1.default.skipAlias(aliasSymbol, state.typeChecker);
            return (originalSymbol === state.services.macroManager.getSymbolOrThrow(TSTransformer_1.SYMBOL_NAMES.ArrayConstructor) ||
                originalSymbol === state.services.macroManager.getSymbolOrThrow(TSTransformer_1.SYMBOL_NAMES.SetConstructor) ||
                originalSymbol === state.services.macroManager.getSymbolOrThrow(TSTransformer_1.SYMBOL_NAMES.MapConstructor) ||
                originalSymbol === state.services.macroManager.getSymbolOrThrow(TSTransformer_1.SYMBOL_NAMES.WeakSetConstructor) ||
                originalSymbol === state.services.macroManager.getSymbolOrThrow(TSTransformer_1.SYMBOL_NAMES.WeakMapConstructor) ||
                originalSymbol === state.services.macroManager.getSymbolOrThrow(TSTransformer_1.SYMBOL_NAMES.ReadonlyMapConstructor) ||
                originalSymbol === state.services.macroManager.getSymbolOrThrow(TSTransformer_1.SYMBOL_NAMES.ReadonlySetConstructor));
        }
    }
    return false;
}
function isClassHoisted(state, node) {
    if (node.name) {
        const symbol = state.typeChecker.getSymbolAtLocation(node.name);
        assert_1.assert(symbol);
        return state.isHoisted.get(symbol) === true;
    }
    return false;
}
function transformClassLikeDeclaration(state, node) {
    const isClassExpression = byots_1.default.isClassExpression(node);
    const statements = LuauAST_1.default.list.make();
    const isExportDefault = !!byots_1.default.getSelectedSyntacticModifierFlags(node, byots_1.default.ModifierFlags.ExportDefault);
    if (node.name) {
        validateIdentifier_1.validateIdentifier(state, node.name);
    }
    const shouldUseInternalName = isClassExpression && node.name !== undefined;
    let returnVar;
    if (shouldUseInternalName) {
        returnVar = LuauAST_1.default.tempId("class");
    }
    else if (node.name) {
        returnVar = transformIdentifier_1.transformIdentifierDefined(state, node.name);
    }
    else if (isExportDefault) {
        returnVar = LuauAST_1.default.id("default");
    }
    else {
        returnVar = LuauAST_1.default.tempId("class");
    }
    let internalName;
    if (shouldUseInternalName) {
        internalName = node.name ? transformIdentifier_1.transformIdentifierDefined(state, node.name) : LuauAST_1.default.tempId("class");
    }
    else {
        internalName = returnVar;
    }
    if (!isClassHoisted(state, node)) {
        LuauAST_1.default.list.push(statements, LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.VariableDeclaration, {
            left: returnVar,
            right: undefined,
        }));
    }
    if (extendsMacroClass(state, node)) {
        DiagnosticService_1.DiagnosticService.addDiagnostic(diagnostics_1.errors.noMacroExtends(node));
    }
    const isRoact = extendsRoactComponent_1.extendsRoactComponent(state, node);
    const statementsInner = LuauAST_1.default.list.make();
    if (isRoact) {
        LuauAST_1.default.list.pushList(statementsInner, createRoactBoilerplate(state, node, internalName, isClassExpression));
    }
    else {
        LuauAST_1.default.list.pushList(statementsInner, createBoilerplate(state, node, internalName, isClassExpression));
    }
    LuauAST_1.default.list.pushList(statementsInner, transformClassConstructor_1.transformClassConstructor(state, node, { value: internalName }, getConstructor(node)));
    for (const member of node.members) {
        if ((byots_1.default.isPropertyDeclaration(member) || byots_1.default.isMethodDeclaration(member)) &&
            (byots_1.default.isIdentifier(member.name) || byots_1.default.isStringLiteral(member.name)) &&
            (LuauAST_1.default.isReservedClassField(member.name.text) ||
                (isRoact && LuauAST_1.default.isReservedRoactClassField(member.name.text)))) {
            DiagnosticService_1.DiagnosticService.addDiagnostic(diagnostics_1.errors.noReservedClassFields(member.name));
        }
    }
    const methods = new Array();
    const staticProperties = new Array();
    for (const member of node.members) {
        if (byots_1.default.isConstructorDeclaration(member) ||
            byots_1.default.isIndexSignatureDeclaration(member) ||
            byots_1.default.isSemicolonClassElement(member)) {
            continue;
        }
        else if (byots_1.default.isMethodDeclaration(member)) {
            methods.push(member);
        }
        else if (byots_1.default.isPropertyDeclaration(member)) {
            if (!byots_1.default.hasStaticModifier(member)) {
                continue;
            }
            staticProperties.push(member);
        }
        else if (byots_1.default.isAccessor(member)) {
            DiagnosticService_1.DiagnosticService.addDiagnostic(diagnostics_1.errors.noGetterSetter(member));
        }
        else {
            assert_1.assert(false, `Class member type not implemented: ${getKindName_1.getKindName(member.kind)}`);
        }
    }
    const classType = state.typeChecker.getTypeOfSymbolAtLocation(node.symbol, node);
    const instanceType = state.typeChecker.getDeclaredTypeOfSymbol(node.symbol);
    for (const method of methods) {
        if (byots_1.default.isIdentifier(method.name) || byots_1.default.isStringLiteral(method.name)) {
            if (LuauAST_1.default.isMetamethod(method.name.text)) {
                DiagnosticService_1.DiagnosticService.addDiagnostic(diagnostics_1.errors.noClassMetamethods(method.name));
            }
            if (!!byots_1.default.getSelectedSyntacticModifierFlags(method, byots_1.default.ModifierFlags.Static)) {
                if (instanceType.getProperty(method.name.text) !== undefined) {
                    DiagnosticService_1.DiagnosticService.addDiagnostic(diagnostics_1.errors.noInstanceMethodCollisions(method));
                }
            }
            else {
                if (classType.getProperty(method.name.text) !== undefined) {
                    DiagnosticService_1.DiagnosticService.addDiagnostic(diagnostics_1.errors.noStaticMethodCollisions(method));
                }
            }
        }
        LuauAST_1.default.list.pushList(statementsInner, transformMethodDeclaration_1.transformMethodDeclaration(state, method, { value: internalName }));
    }
    const toStringProperty = instanceType.getProperty(MAGIC_TO_STRING_METHOD);
    if (toStringProperty && !!(toStringProperty.flags & byots_1.default.SymbolFlags.Method)) {
        LuauAST_1.default.list.push(statementsInner, LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.MethodDeclaration, {
            expression: internalName,
            name: "__tostring",
            hasDotDotDot: false,
            parameters: LuauAST_1.default.list.make(),
            statements: LuauAST_1.default.list.make(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.ReturnStatement, {
                expression: LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.MethodCallExpression, {
                    expression: LuauAST_1.default.globals.self,
                    name: MAGIC_TO_STRING_METHOD,
                    args: LuauAST_1.default.list.make(),
                }),
            })),
        }));
    }
    for (const property of staticProperties) {
        LuauAST_1.default.list.pushList(statementsInner, transformPropertyDeclaration_1.transformPropertyDeclaration(state, property, { value: internalName }));
    }
    if (shouldUseInternalName) {
        LuauAST_1.default.list.push(statementsInner, LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.Assignment, {
            left: returnVar,
            operator: "=",
            right: internalName,
        }));
    }
    LuauAST_1.default.list.push(statements, LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.DoStatement, {
        statements: statementsInner,
    }));
    return { statements, name: returnVar };
}
exports.transformClassLikeDeclaration = transformClassLikeDeclaration;
//# sourceMappingURL=transformClassLikeDeclaration.js.map