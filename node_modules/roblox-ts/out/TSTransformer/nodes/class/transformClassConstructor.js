"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformClassConstructor = void 0;
const byots_1 = __importDefault(require("byots"));
const LuauAST_1 = __importDefault(require("../../../LuauAST"));
const diagnostics_1 = require("../../../Shared/diagnostics");
const DiagnosticService_1 = require("../../classes/DiagnosticService");
const transformExpression_1 = require("../expressions/transformExpression");
const transformIdentifier_1 = require("../expressions/transformIdentifier");
const transformObjectKey_1 = require("../transformObjectKey");
const transformParameters_1 = require("../transformParameters");
const transformStatementList_1 = require("../transformStatementList");
const extendsRoactComponent_1 = require("../../util/extendsRoactComponent");
const getExtendsNode_1 = require("../../util/getExtendsNode");
const getStatements_1 = require("../../util/getStatements");
function transformClassConstructor(state, node, ptr, originNode) {
    var _a;
    const statements = LuauAST_1.default.list.make();
    let bodyStatements = originNode ? getStatements_1.getStatements(originNode.body) : [];
    const isRoact = extendsRoactComponent_1.extendsRoactComponent(state, node);
    let removeFirstSuper = isRoact;
    let parameters = LuauAST_1.default.list.make();
    let hasDotDotDot = false;
    if (originNode) {
        const { statements: paramStatements, parameters: constructorParams, hasDotDotDot: constructorHasDotDotDot, } = transformParameters_1.transformParameters(state, originNode);
        LuauAST_1.default.list.pushList(statements, paramStatements);
        parameters = constructorParams;
        hasDotDotDot = constructorHasDotDotDot;
    }
    else if (!isRoact && getExtendsNode_1.getExtendsNode(node)) {
        hasDotDotDot = true;
        LuauAST_1.default.list.push(statements, LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.CallStatement, {
            expression: LuauAST_1.default.call(LuauAST_1.default.property(LuauAST_1.default.globals.super, "constructor"), [
                LuauAST_1.default.globals.self,
                LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.VarArgsLiteral, {}),
            ]),
        }));
    }
    function transformFirstSuper() {
        if (!removeFirstSuper) {
            removeFirstSuper = true;
            if (bodyStatements.length > 0) {
                const firstStatement = bodyStatements[0];
                if (byots_1.default.isExpressionStatement(firstStatement) && byots_1.default.isSuperCall(firstStatement.expression)) {
                    LuauAST_1.default.list.pushList(statements, transformStatementList_1.transformStatementList(state, [firstStatement]));
                }
            }
        }
    }
    for (const parameter of (_a = originNode === null || originNode === void 0 ? void 0 : originNode.parameters) !== null && _a !== void 0 ? _a : []) {
        if (byots_1.default.isParameterPropertyDeclaration(parameter, parameter.parent)) {
            transformFirstSuper();
            const paramId = transformIdentifier_1.transformIdentifierDefined(state, parameter.name);
            LuauAST_1.default.list.push(statements, LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.Assignment, {
                left: LuauAST_1.default.property(LuauAST_1.default.globals.self, paramId.name),
                operator: "=",
                right: paramId,
            }));
        }
    }
    for (const member of node.members) {
        if (byots_1.default.isPropertyDeclaration(member) && !byots_1.default.hasStaticModifier(member)) {
            transformFirstSuper();
            const name = member.name;
            if (byots_1.default.isPrivateIdentifier(name)) {
                DiagnosticService_1.DiagnosticService.addDiagnostic(diagnostics_1.errors.noPrivateIdentifier(node));
                continue;
            }
            const initializer = member.initializer;
            if (!initializer) {
                continue;
            }
            const [index, indexPrereqs] = state.capture(() => transformObjectKey_1.transformObjectKey(state, name));
            LuauAST_1.default.list.pushList(statements, indexPrereqs);
            const [right, rightPrereqs] = state.capture(() => transformExpression_1.transformExpression(state, initializer));
            LuauAST_1.default.list.pushList(statements, rightPrereqs);
            LuauAST_1.default.list.push(statements, LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.Assignment, {
                left: LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.ComputedIndexExpression, {
                    expression: LuauAST_1.default.globals.self,
                    index,
                }),
                operator: "=",
                right,
            }));
        }
    }
    if (removeFirstSuper && bodyStatements.length > 0) {
        const firstStatement = bodyStatements[0];
        if (byots_1.default.isExpressionStatement(firstStatement) && byots_1.default.isSuperCall(firstStatement.expression)) {
            bodyStatements = bodyStatements.slice(1);
        }
    }
    LuauAST_1.default.list.pushList(statements, transformStatementList_1.transformStatementList(state, bodyStatements));
    return LuauAST_1.default.list.make(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.MethodDeclaration, {
        expression: ptr.value,
        name: isRoact ? "init" : "constructor",
        statements,
        parameters,
        hasDotDotDot,
    }));
}
exports.transformClassConstructor = transformClassConstructor;
//# sourceMappingURL=transformClassConstructor.js.map