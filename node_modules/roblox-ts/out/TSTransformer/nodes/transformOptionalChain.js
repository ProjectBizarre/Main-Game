"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformOptionalChain = exports.flattenOptionalChain = void 0;
const byots_1 = __importDefault(require("byots"));
const LuauAST_1 = __importDefault(require("../../LuauAST"));
const diagnostics_1 = require("../../Shared/diagnostics");
const DiagnosticService_1 = require("../classes/DiagnosticService");
const transformCallExpression_1 = require("./expressions/transformCallExpression");
const transformElementAccessExpression_1 = require("./expressions/transformElementAccessExpression");
const transformExpression_1 = require("./expressions/transformExpression");
const transformPropertyAccessExpression_1 = require("./expressions/transformPropertyAccessExpression");
const convertToIndexableExpression_1 = require("../util/convertToIndexableExpression");
const ensureTransformOrder_1 = require("../util/ensureTransformOrder");
const isMethod_1 = require("../util/isMethod");
const isUsedAsStatement_1 = require("../util/isUsedAsStatement");
const traversal_1 = require("../util/traversal");
const types_1 = require("../util/types");
const wrapReturnIfLuaTuple_1 = require("../util/wrapReturnIfLuaTuple");
var OptionalChainItemKind;
(function (OptionalChainItemKind) {
    OptionalChainItemKind[OptionalChainItemKind["PropertyAccess"] = 0] = "PropertyAccess";
    OptionalChainItemKind[OptionalChainItemKind["ElementAccess"] = 1] = "ElementAccess";
    OptionalChainItemKind[OptionalChainItemKind["Call"] = 2] = "Call";
    OptionalChainItemKind[OptionalChainItemKind["PropertyCall"] = 3] = "PropertyCall";
    OptionalChainItemKind[OptionalChainItemKind["ElementCall"] = 4] = "ElementCall";
})(OptionalChainItemKind || (OptionalChainItemKind = {}));
function createPropertyAccessItem(state, node) {
    return {
        node,
        kind: OptionalChainItemKind.PropertyAccess,
        optional: node.questionDotToken !== undefined,
        type: state.getType(node.expression),
        name: node.name.text,
    };
}
function createElementAccessItem(state, node) {
    return {
        node,
        kind: OptionalChainItemKind.ElementAccess,
        optional: node.questionDotToken !== undefined,
        type: state.getType(node.expression),
        expression: node.argumentExpression,
    };
}
function createCallItem(state, node) {
    return {
        node,
        kind: OptionalChainItemKind.Call,
        optional: node.questionDotToken !== undefined,
        type: state.getType(node.expression),
        args: node.arguments,
    };
}
function createPropertyCallItem(state, node, expression) {
    return {
        node,
        expression,
        kind: OptionalChainItemKind.PropertyCall,
        optional: expression.questionDotToken !== undefined,
        type: state.getType(node.expression),
        name: expression.name.text,
        callType: state.getType(node),
        callOptional: node.questionDotToken !== undefined,
        args: node.arguments,
    };
}
function createElementCallItem(state, node, expression) {
    return {
        node,
        expression,
        kind: OptionalChainItemKind.ElementCall,
        optional: expression.questionDotToken !== undefined,
        type: state.getType(expression),
        argumentExpression: expression.argumentExpression,
        callType: state.getType(node),
        callOptional: node.questionDotToken !== undefined,
        args: node.arguments,
    };
}
function flattenOptionalChain(state, expression) {
    const chain = new Array();
    while (true) {
        if (byots_1.default.isPropertyAccessExpression(expression)) {
            chain.unshift(createPropertyAccessItem(state, expression));
            expression = expression.expression;
        }
        else if (byots_1.default.isElementAccessExpression(expression)) {
            chain.unshift(createElementAccessItem(state, expression));
            expression = expression.expression;
        }
        else if (byots_1.default.isCallExpression(expression)) {
            const subExp = traversal_1.skipDownwards(expression.expression);
            if (byots_1.default.isPropertyAccessExpression(subExp)) {
                chain.unshift(createPropertyCallItem(state, expression, subExp));
                expression = subExp.expression;
            }
            else if (byots_1.default.isElementAccessExpression(subExp)) {
                chain.unshift(createElementCallItem(state, expression, subExp));
                expression = subExp.expression;
            }
            else {
                chain.unshift(createCallItem(state, expression));
                expression = subExp;
            }
        }
        else {
            break;
        }
    }
    return { chain, expression };
}
exports.flattenOptionalChain = flattenOptionalChain;
function transformChainItem(state, baseExpression, item) {
    if (item.kind === OptionalChainItemKind.PropertyAccess) {
        return transformPropertyAccessExpression_1.transformPropertyAccessExpressionInner(state, item.node, baseExpression, item.name);
    }
    else if (item.kind === OptionalChainItemKind.ElementAccess) {
        return transformElementAccessExpression_1.transformElementAccessExpressionInner(state, item.node, baseExpression, item.expression);
    }
    else if (item.kind === OptionalChainItemKind.Call) {
        return transformCallExpression_1.transformCallExpressionInner(state, item.node, baseExpression, item.args);
    }
    else if (item.kind === OptionalChainItemKind.PropertyCall) {
        return transformCallExpression_1.transformPropertyCallExpressionInner(state, item.node, item.expression, baseExpression, item.name, item.args);
    }
    else {
        return transformCallExpression_1.transformElementCallExpressionInner(state, item.node, item.expression, baseExpression, item.argumentExpression, item.args);
    }
}
function createOrSetTempId(state, tempId, expression, node) {
    if (tempId === undefined) {
        tempId = state.pushToVar(expression, node.parent && byots_1.default.isVariableDeclaration(node.parent) && byots_1.default.isIdentifier(node.parent.name)
            ? node.parent.name.text
            : "result");
    }
    else {
        if (tempId !== expression) {
            state.prereq(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.Assignment, {
                left: tempId,
                operator: "=",
                right: expression,
            }));
        }
    }
    return tempId;
}
function createNilCheck(tempId, statements) {
    return LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.IfStatement, {
        condition: LuauAST_1.default.binary(tempId, "~=", LuauAST_1.default.nil()),
        statements,
        elseBody: LuauAST_1.default.list.make(),
    });
}
function isCompoundCall(item) {
    return item.kind === OptionalChainItemKind.PropertyCall || item.kind === OptionalChainItemKind.ElementCall;
}
function transformOptionalChainInner(state, chain, baseExpression, tempId = undefined, index = 0) {
    if (index >= chain.length)
        return baseExpression;
    const item = chain[index];
    if (item.optional || (isCompoundCall(item) && item.callOptional)) {
        let isMethodCall = false;
        let isSuperCall = false;
        let selfParam;
        if (isCompoundCall(item)) {
            isMethodCall = isMethod_1.isMethod(state, item.expression);
            isSuperCall = byots_1.default.isSuperProperty(item.expression);
            if (item.callOptional && isMethodCall && !isSuperCall) {
                selfParam = state.pushToVar(baseExpression, "self");
                baseExpression = selfParam;
            }
            if (item.optional) {
                tempId = createOrSetTempId(state, tempId, baseExpression, chain[chain.length - 1].node);
                baseExpression = tempId;
            }
            if (item.callOptional) {
                if (item.kind === OptionalChainItemKind.PropertyCall) {
                    baseExpression = LuauAST_1.default.property(convertToIndexableExpression_1.convertToIndexableExpression(baseExpression), item.name);
                }
                else {
                    baseExpression = LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.ComputedIndexExpression, {
                        expression: convertToIndexableExpression_1.convertToIndexableExpression(baseExpression),
                        index: transformExpression_1.transformExpression(state, item.argumentExpression),
                    });
                }
            }
        }
        const [result, prereqStatements] = state.capture(() => {
            tempId = createOrSetTempId(state, tempId, baseExpression, chain[chain.length - 1].node);
            const [newValue, ifStatements] = state.capture(() => {
                let newExpression;
                if (isCompoundCall(item) && item.callOptional) {
                    const expType = state.typeChecker.getNonOptionalType(state.getType(item.node.expression));
                    const symbol = types_1.getFirstDefinedSymbol(state, expType);
                    if (symbol) {
                        const macro = state.services.macroManager.getPropertyCallMacro(symbol);
                        if (macro) {
                            DiagnosticService_1.DiagnosticService.addDiagnostic(diagnostics_1.errors.noOptionalMacroCall(item.node));
                            return LuauAST_1.default.emptyId();
                        }
                    }
                    const args = ensureTransformOrder_1.ensureTransformOrder(state, item.args);
                    if (isMethodCall) {
                        if (isSuperCall) {
                            args.unshift(LuauAST_1.default.globals.self);
                        }
                        else {
                            args.unshift(selfParam);
                        }
                    }
                    newExpression = wrapReturnIfLuaTuple_1.wrapReturnIfLuaTuple(state, item.node, LuauAST_1.default.call(tempId, args));
                }
                else {
                    newExpression = transformChainItem(state, tempId, item);
                }
                return transformOptionalChainInner(state, chain, newExpression, tempId, index + 1);
            });
            const isUsed = !LuauAST_1.default.isEmptyIdentifier(newValue) && !LuauAST_1.default.isNilLiteral(newValue) && !isUsedAsStatement_1.isUsedAsStatement(item.node);
            if (tempId !== newValue && isUsed) {
                LuauAST_1.default.list.push(ifStatements, LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.Assignment, {
                    left: tempId,
                    operator: "=",
                    right: newValue,
                }));
            }
            else {
                if (LuauAST_1.default.isCall(newValue)) {
                    LuauAST_1.default.list.push(ifStatements, LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.CallStatement, {
                        expression: newValue,
                    }));
                }
            }
            state.prereq(createNilCheck(tempId, ifStatements));
            return isUsed ? tempId : LuauAST_1.default.emptyId();
        });
        if (isCompoundCall(item) && item.optional && item.callOptional) {
            state.prereq(createNilCheck(tempId, prereqStatements));
        }
        else {
            state.prereqList(prereqStatements);
        }
        return result;
    }
    else {
        return transformOptionalChainInner(state, chain, transformChainItem(state, baseExpression, item), tempId, index + 1);
    }
}
function transformOptionalChain(state, node) {
    const { chain, expression } = flattenOptionalChain(state, node);
    return transformOptionalChainInner(state, chain, transformExpression_1.transformExpression(state, expression));
}
exports.transformOptionalChain = transformOptionalChain;
//# sourceMappingURL=transformOptionalChain.js.map