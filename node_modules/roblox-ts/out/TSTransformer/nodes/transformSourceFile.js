"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformSourceFile = void 0;
const byots_1 = __importDefault(require("byots"));
const LuauAST_1 = __importDefault(require("../../LuauAST"));
const RojoResolver_1 = require("../../Shared/classes/RojoResolver");
const constants_1 = require("../../Shared/constants");
const assert_1 = require("../../Shared/util/assert");
const transformIdentifier_1 = require("./expressions/transformIdentifier");
const transformStatementList_1 = require("./transformStatementList");
const isDefinedAsLet_1 = require("../util/isDefinedAsLet");
const isSymbolOfValue_1 = require("../util/isSymbolOfValue");
const traversal_1 = require("../util/traversal");
function getExportPair(state, exportSymbol) {
    var _a, _b;
    const declaration = (_a = exportSymbol.getDeclarations()) === null || _a === void 0 ? void 0 : _a[0];
    if (declaration && byots_1.default.isExportSpecifier(declaration)) {
        return [declaration.name.text, transformIdentifier_1.transformIdentifierDefined(state, (_b = declaration.propertyName) !== null && _b !== void 0 ? _b : declaration.name)];
    }
    else {
        let name = exportSymbol.name;
        if (exportSymbol.name === "default" &&
            declaration &&
            (byots_1.default.isFunctionDeclaration(declaration) || byots_1.default.isClassDeclaration(declaration)) &&
            declaration.name) {
            name = declaration.name.text;
        }
        return [exportSymbol.name, LuauAST_1.default.id(name)];
    }
}
function isExportSymbolFromExportFrom(exportSymbol) {
    if (exportSymbol.declarations) {
        for (const exportSpecifier of exportSymbol.declarations) {
            if (byots_1.default.isExportSpecifier(exportSpecifier)) {
                const exportDec = exportSpecifier.parent.parent;
                if (byots_1.default.isExportDeclaration(exportDec) && exportDec.moduleSpecifier) {
                    return true;
                }
            }
        }
    }
    return false;
}
function getIgnoredExportSymbols(state, sourceFile) {
    const ignoredSymbols = new Set();
    for (const statement of sourceFile.statements) {
        if (byots_1.default.isExportDeclaration(statement) && statement.moduleSpecifier) {
            if (!statement.exportClause) {
                const moduleSymbol = state.getOriginalSymbol(statement.moduleSpecifier);
                if (moduleSymbol) {
                    state.getModuleExports(moduleSymbol).forEach(v => ignoredSymbols.add(v));
                }
            }
            else if (byots_1.default.isNamespaceExport(statement.exportClause)) {
                const idSymbol = state.typeChecker.getSymbolAtLocation(statement.exportClause.name);
                if (idSymbol) {
                    ignoredSymbols.add(idSymbol);
                }
            }
        }
    }
    return ignoredSymbols;
}
function handleExports(state, sourceFile, symbol, statements) {
    var _a;
    const ignoredExportSymbols = getIgnoredExportSymbols(state, sourceFile);
    let mustPushExports = state.hasExportFrom;
    const exportPairs = new Array();
    if (!state.hasExportEquals) {
        for (const exportSymbol of state.getModuleExports(symbol)) {
            if (ignoredExportSymbols.has(exportSymbol))
                continue;
            if (!!(exportSymbol.flags & byots_1.default.SymbolFlags.Prototype))
                continue;
            if (isExportSymbolFromExportFrom(exportSymbol))
                continue;
            const originalSymbol = byots_1.default.skipAlias(exportSymbol, state.typeChecker);
            if (!isSymbolOfValue_1.isSymbolOfValue(originalSymbol))
                continue;
            if (isDefinedAsLet_1.isDefinedAsLet(state, originalSymbol)) {
                mustPushExports = true;
                continue;
            }
            if (originalSymbol.valueDeclaration) {
                const statement = traversal_1.getAncestor(originalSymbol.valueDeclaration, byots_1.default.isStatement);
                if ((_a = statement === null || statement === void 0 ? void 0 : statement.modifiers) === null || _a === void 0 ? void 0 : _a.some(v => v.kind === byots_1.default.SyntaxKind.DeclareKeyword)) {
                    continue;
                }
            }
            exportPairs.push(getExportPair(state, exportSymbol));
        }
    }
    if (state.hasExportEquals) {
        const finalStatement = sourceFile.statements[sourceFile.statements.length - 1];
        if (!(byots_1.default.isExportAssignment(finalStatement) && finalStatement.isExportEquals)) {
            LuauAST_1.default.list.push(statements, LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.ReturnStatement, {
                expression: LuauAST_1.default.globals.exports,
            }));
        }
    }
    else if (mustPushExports) {
        LuauAST_1.default.list.unshift(statements, LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.VariableDeclaration, {
            left: LuauAST_1.default.globals.exports,
            right: LuauAST_1.default.map(),
        }));
        for (const [exportKey, exportId] of exportPairs) {
            LuauAST_1.default.list.push(statements, LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.Assignment, {
                left: LuauAST_1.default.property(LuauAST_1.default.globals.exports, exportKey),
                operator: "=",
                right: exportId,
            }));
        }
        LuauAST_1.default.list.push(statements, LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.ReturnStatement, {
            expression: LuauAST_1.default.globals.exports,
        }));
    }
    else if (exportPairs.length > 0) {
        const fields = LuauAST_1.default.list.make();
        for (const [exportKey, exportId] of exportPairs) {
            LuauAST_1.default.list.push(fields, LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.MapField, {
                index: LuauAST_1.default.string(exportKey),
                value: exportId,
            }));
        }
        LuauAST_1.default.list.push(statements, LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.ReturnStatement, {
            expression: LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.Map, {
                fields,
            }),
        }));
    }
}
function getLastNonCommentStatement(listNode) {
    while (listNode && LuauAST_1.default.isComment(listNode.value)) {
        listNode = listNode.prev;
    }
    return listNode;
}
function transformSourceFile(state, node) {
    const symbol = state.typeChecker.getSymbolAtLocation(node);
    assert_1.assert(symbol);
    state.setModuleIdBySymbol(symbol, LuauAST_1.default.globals.exports);
    const statements = transformStatementList_1.transformStatementList(state, node.statements);
    handleExports(state, node, symbol, statements);
    const lastStatement = getLastNonCommentStatement(statements.tail);
    if (!lastStatement || !LuauAST_1.default.isReturnStatement(lastStatement.value)) {
        const outputPath = state.pathTranslator.getOutputPath(node.fileName);
        if (state.rojoResolver.getRbxTypeFromFilePath(outputPath) === RojoResolver_1.RbxType.ModuleScript) {
            LuauAST_1.default.list.push(statements, LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.ReturnStatement, { expression: LuauAST_1.default.nil() }));
        }
    }
    if (state.usesRuntimeLib) {
        LuauAST_1.default.list.unshift(statements, state.createRuntimeLibImport(node));
    }
    LuauAST_1.default.list.unshift(statements, LuauAST_1.default.comment(`Compiled with roblox-ts v${constants_1.COMPILER_VERSION}`));
    return statements;
}
exports.transformSourceFile = transformSourceFile;
//# sourceMappingURL=transformSourceFile.js.map