"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransformState = void 0;
const byots_1 = __importDefault(require("byots"));
const LuauAST_1 = __importDefault(require("../../LuauAST"));
const LuauRenderer_1 = require("../../LuauRenderer");
const solveTempIds_1 = require("../../LuauRenderer/solveTempIds");
const path_1 = __importDefault(require("path"));
const RojoResolver_1 = require("../../Shared/classes/RojoResolver");
const constants_1 = require("../../Shared/constants");
const diagnostics_1 = require("../../Shared/diagnostics");
const assert_1 = require("../../Shared/util/assert");
const getOrSetDefault_1 = require("../../Shared/util/getOrSetDefault");
const DiagnosticService_1 = require("./DiagnosticService");
const createGetService_1 = require("../util/createGetService");
const expressionChain_1 = require("../util/expressionChain");
const traversal_1 = require("../util/traversal");
class TransformState {
    constructor(data, services, pathTranslator, multiTransformState, compilerOptions, rojoResolver, pkgRojoResolvers, nodeModulesPathMapping, reverseSymlinkMap, runtimeLibRbxPath, typeChecker, projectType, sourceFile) {
        this.data = data;
        this.services = services;
        this.pathTranslator = pathTranslator;
        this.multiTransformState = multiTransformState;
        this.compilerOptions = compilerOptions;
        this.rojoResolver = rojoResolver;
        this.pkgRojoResolvers = pkgRojoResolvers;
        this.nodeModulesPathMapping = nodeModulesPathMapping;
        this.reverseSymlinkMap = reverseSymlinkMap;
        this.runtimeLibRbxPath = runtimeLibRbxPath;
        this.typeChecker = typeChecker;
        this.projectType = projectType;
        this.hasExportEquals = false;
        this.hasExportFrom = false;
        this.tryUsesStack = new Array();
        this.prereqStatementsStack = new Array();
        this.hoistsByStatement = new Map();
        this.isHoisted = new Map();
        this.getTypeCache = new Map();
        this.usesRuntimeLib = false;
        this.moduleIdBySymbol = new Map();
        this.symbolToIdMap = new Map();
        this.sourceFileText = sourceFile.getFullText();
        this.resolver = typeChecker.getEmitResolver(sourceFile);
        const sourceOutPath = this.pathTranslator.getOutputPath(sourceFile.fileName);
        const rbxPath = this.rojoResolver.getRbxPathFromFilePath(sourceOutPath);
        this.isInReplicatedFirst = rbxPath !== undefined && rbxPath[0] === "ReplicatedFirst";
    }
    debugRender(node) {
        const state = new LuauRenderer_1.RenderState();
        solveTempIds_1.solveTempIds(state, node);
        return LuauRenderer_1.render(state, node);
    }
    debugRenderList(list) {
        const state = new LuauRenderer_1.RenderState();
        solveTempIds_1.solveTempIds(state, list);
        return LuauRenderer_1.renderStatements(state, list);
    }
    pushTryUsesStack() {
        const tryUses = {
            usesReturn: false,
            usesBreak: false,
            usesContinue: false,
        };
        this.tryUsesStack.push(tryUses);
        return tryUses;
    }
    markTryUses(property) {
        if (this.tryUsesStack.length !== 0) {
            this.tryUsesStack[this.tryUsesStack.length - 1][property] = true;
        }
    }
    popTryUsesStack() {
        this.tryUsesStack.pop();
    }
    prereq(statement) {
        LuauAST_1.default.list.push(this.prereqStatementsStack[this.prereqStatementsStack.length - 1], statement);
    }
    prereqList(statements) {
        LuauAST_1.default.list.pushList(this.prereqStatementsStack[this.prereqStatementsStack.length - 1], statements);
    }
    pushPrereqStatementsStack() {
        const prereqStatements = LuauAST_1.default.list.make();
        this.prereqStatementsStack.push(prereqStatements);
        return prereqStatements;
    }
    popPrereqStatementsStack() {
        const poppedValue = this.prereqStatementsStack.pop();
        assert_1.assert(poppedValue);
        return poppedValue;
    }
    getLeadingComments(node) {
        var _a;
        const commentRanges = (_a = byots_1.default.getLeadingCommentRanges(this.sourceFileText, node.pos)) !== null && _a !== void 0 ? _a : [];
        return LuauAST_1.default.list.make(...commentRanges.map(commentRange => LuauAST_1.default.comment(this.sourceFileText.substring(commentRange.pos + 2, commentRange.kind === byots_1.default.SyntaxKind.SingleLineCommentTrivia
            ? commentRange.end
            : commentRange.end - 2))));
    }
    capturePrereqs(callback) {
        this.pushPrereqStatementsStack();
        callback();
        return this.popPrereqStatementsStack();
    }
    capture(callback) {
        let value;
        const prereqs = this.capturePrereqs(() => (value = callback()));
        return [value, prereqs];
    }
    noPrereqs(callback) {
        let expression;
        const statements = this.capturePrereqs(() => (expression = callback()));
        assert_1.assert(LuauAST_1.default.list.isEmpty(statements));
        return expression;
    }
    getType(node) {
        return getOrSetDefault_1.getOrSetDefault(this.getTypeCache, node, () => this.typeChecker.getTypeAtLocation(traversal_1.skipUpwards(node)));
    }
    getOriginalSymbol(node) {
        const symbol = this.typeChecker.getSymbolAtLocation(node);
        if (symbol) {
            return byots_1.default.skipAlias(symbol, this.typeChecker);
        }
    }
    TS(node, name) {
        this.usesRuntimeLib = true;
        if (this.projectType === constants_1.ProjectType.Game && this.isInReplicatedFirst) {
            DiagnosticService_1.DiagnosticService.addDiagnostic(diagnostics_1.warnings.runtimeLibUsedInReplicatedFirst(node));
        }
        return LuauAST_1.default.property(LuauAST_1.default.globals.TS, name);
    }
    createRuntimeLibImport(sourceFile) {
        if (this.runtimeLibRbxPath) {
            if (this.projectType === constants_1.ProjectType.Game) {
                const serviceName = this.runtimeLibRbxPath[0];
                assert_1.assert(serviceName);
                let expression = createGetService_1.createGetService(serviceName);
                for (let i = 1; i < this.runtimeLibRbxPath.length; i++) {
                    expression = LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.MethodCallExpression, {
                        expression,
                        name: "WaitForChild",
                        args: LuauAST_1.default.list.make(LuauAST_1.default.string(this.runtimeLibRbxPath[i])),
                    });
                }
                expression = LuauAST_1.default.call(LuauAST_1.default.globals.require, [expression]);
                return LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.VariableDeclaration, {
                    left: LuauAST_1.default.globals.TS,
                    right: expression,
                });
            }
            else {
                const sourceOutPath = this.pathTranslator.getOutputPath(sourceFile.fileName);
                const rbxPath = this.rojoResolver.getRbxPathFromFilePath(sourceOutPath);
                if (!rbxPath) {
                    DiagnosticService_1.DiagnosticService.addDiagnostic(diagnostics_1.errors.noRojoData(sourceFile, path_1.default.relative(this.data.projectPath, sourceOutPath)));
                    return LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.VariableDeclaration, {
                        left: LuauAST_1.default.globals.TS,
                        right: LuauAST_1.default.nil(),
                    });
                }
                return LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.VariableDeclaration, {
                    left: LuauAST_1.default.globals.TS,
                    right: LuauAST_1.default.call(LuauAST_1.default.globals.require, [
                        expressionChain_1.propertyAccessExpressionChain(LuauAST_1.default.globals.script, RojoResolver_1.RojoResolver.relative(rbxPath, this.runtimeLibRbxPath).map(v => v === RojoResolver_1.RbxPathParent ? constants_1.PARENT_FIELD : v)),
                    ]),
                });
            }
        }
        else {
            return LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.VariableDeclaration, {
                left: LuauAST_1.default.globals.TS,
                right: LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.ComputedIndexExpression, {
                    expression: LuauAST_1.default.globals._G,
                    index: LuauAST_1.default.globals.script,
                }),
            });
        }
    }
    pushToVar(expression, name) {
        const temp = LuauAST_1.default.tempId(name);
        this.prereq(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.VariableDeclaration, {
            left: temp,
            right: expression,
        }));
        return temp;
    }
    pushToVarIfComplex(expression, name) {
        if (LuauAST_1.default.isSimple(expression)) {
            return expression;
        }
        return this.pushToVar(expression, name);
    }
    pushToVarIfNonId(expression, name) {
        if (LuauAST_1.default.isAnyIdentifier(expression)) {
            return expression;
        }
        return this.pushToVar(expression, name);
    }
    getModuleExports(moduleSymbol) {
        return getOrSetDefault_1.getOrSetDefault(this.multiTransformState.getModuleExportsCache, moduleSymbol, () => this.typeChecker.getExportsOfModule(moduleSymbol));
    }
    getModuleExportsAliasMap(moduleSymbol) {
        return getOrSetDefault_1.getOrSetDefault(this.multiTransformState.getModuleExportsAliasMapCache, moduleSymbol, () => {
            var _a;
            const aliasMap = new Map();
            for (const exportSymbol of this.getModuleExports(moduleSymbol)) {
                const originalSymbol = byots_1.default.skipAlias(exportSymbol, this.typeChecker);
                const declaration = (_a = exportSymbol.getDeclarations()) === null || _a === void 0 ? void 0 : _a[0];
                if (declaration && byots_1.default.isExportSpecifier(declaration)) {
                    aliasMap.set(originalSymbol, declaration.name.text);
                }
                else {
                    aliasMap.set(originalSymbol, exportSymbol.name);
                }
            }
            return aliasMap;
        });
    }
    getModuleSymbolFromNode(node) {
        const moduleAncestor = traversal_1.getModuleAncestor(node);
        const exportSymbol = this.typeChecker.getSymbolAtLocation(byots_1.default.isSourceFile(moduleAncestor) ? moduleAncestor : moduleAncestor.name);
        assert_1.assert(exportSymbol);
        return exportSymbol;
    }
    getModuleIdFromSymbol(moduleSymbol) {
        const moduleId = this.moduleIdBySymbol.get(moduleSymbol);
        assert_1.assert(moduleId);
        return moduleId;
    }
    setModuleIdBySymbol(moduleSymbol, moduleId) {
        this.moduleIdBySymbol.set(moduleSymbol, moduleId);
    }
    getModuleIdFromNode(node) {
        const moduleSymbol = this.getModuleSymbolFromNode(node);
        return this.getModuleIdFromSymbol(moduleSymbol);
    }
    getModuleIdPropertyAccess(idSymbol) {
        if (idSymbol.valueDeclaration) {
            const moduleSymbol = this.getModuleSymbolFromNode(idSymbol.valueDeclaration);
            const alias = this.getModuleExportsAliasMap(moduleSymbol).get(idSymbol);
            if (alias) {
                return LuauAST_1.default.property(this.getModuleIdFromSymbol(moduleSymbol), alias);
            }
        }
    }
    guessVirtualPath(fsPath) {
        const original = fsPath;
        while (true) {
            const parent = path_1.default.dirname(fsPath);
            if (fsPath === parent)
                break;
            fsPath = parent;
            const symlink = this.reverseSymlinkMap.get(fsPath);
            if (symlink) {
                return path_1.default.join(symlink, path_1.default.relative(fsPath, original));
            }
        }
        return original;
    }
}
exports.TransformState = TransformState;
//# sourceMappingURL=TransformState.js.map