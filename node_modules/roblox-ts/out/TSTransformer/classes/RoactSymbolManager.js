"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RoactSymbolManager = exports.ROACT_SYMBOL_NAMES = void 0;
const byots_1 = __importDefault(require("byots"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const constants_1 = require("../../Shared/constants");
const assert_1 = require("../../Shared/util/assert");
const realPathExistsSync_1 = require("../../Shared/util/realPathExistsSync");
exports.ROACT_SYMBOL_NAMES = {
    Component: "Component",
    PureComponent: "PureComponent",
    Fragment: "Fragment",
    Element: "Element",
};
class RoactSymbolManager {
    constructor(typeChecker, roactIndexSourceFile) {
        var _a, _b, _c;
        this.symbols = new Map();
        this.jsxIntrinsicNameMap = new Map();
        const roactNamespace = (_b = (_a = roactIndexSourceFile.locals) === null || _a === void 0 ? void 0 : _a.get(byots_1.default.escapeLeadingUnderscores("Roact"))) === null || _b === void 0 ? void 0 : _b.valueDeclaration;
        assert_1.assert(roactNamespace);
        const roactExports = roactNamespace.symbol.exports;
        assert_1.assert(roactExports);
        for (const symbolName of Object.values(exports.ROACT_SYMBOL_NAMES)) {
            const symbol = roactExports.get(byots_1.default.escapeLeadingUnderscores(symbolName));
            assert_1.assert(symbol);
            this.symbols.set(symbolName, byots_1.default.skipAlias(symbol, typeChecker));
        }
        for (const symbol of typeChecker.getJsxIntrinsicTagNamesAt(roactIndexSourceFile)) {
            assert_1.assert(symbol.valueDeclaration && byots_1.default.isPropertySignature(symbol.valueDeclaration));
            assert_1.assert(symbol.valueDeclaration.type && byots_1.default.isTypeReferenceNode(symbol.valueDeclaration.type));
            const className = (_c = symbol.valueDeclaration.type.typeArguments) === null || _c === void 0 ? void 0 : _c[0].getText();
            assert_1.assert(className);
            this.jsxIntrinsicNameMap.set(symbol, className);
        }
    }
    static create(data, program, typeChecker) {
        var _a, _b;
        const pkgPath = path_1.default.join(data.nodeModulesPath, constants_1.RBXTS_SCOPE, "roact");
        const pkgJsonPath = realPathExistsSync_1.realPathExistsSync(path_1.default.join(pkgPath, "package.json"));
        if (pkgJsonPath !== undefined) {
            const pkgJson = fs_extra_1.default.readJsonSync(pkgJsonPath);
            const typesPath = realPathExistsSync_1.realPathExistsSync(path_1.default.join(pkgPath, (_b = (_a = pkgJson.types) !== null && _a !== void 0 ? _a : pkgJson.typings) !== null && _b !== void 0 ? _b : "index.d.ts"));
            if (typesPath !== undefined) {
                const roactIndexSourceFile = program.getSourceFile(typesPath);
                if (roactIndexSourceFile) {
                    return new RoactSymbolManager(typeChecker, roactIndexSourceFile);
                }
            }
        }
        const roactIndexSourceFilePath = path_1.default.join(data.nodeModulesPath, constants_1.RBXTS_SCOPE, "roact", "src", "index.d.ts");
        const roactIndexSourceFile = program.getSourceFile(roactIndexSourceFilePath);
        if (roactIndexSourceFile) {
            return new RoactSymbolManager(typeChecker, roactIndexSourceFile);
        }
    }
    getSymbolOrThrow(symbolName) {
        const symbol = this.symbols.get(symbolName);
        assert_1.assert(symbol, `Could not find symbol for ${symbolName}`);
        return symbol;
    }
    getIntrinsicElementClassNameFromSymbol(symbol) {
        return this.jsxIntrinsicNameMap.get(symbol);
    }
}
exports.RoactSymbolManager = RoactSymbolManager;
//# sourceMappingURL=RoactSymbolManager.js.map