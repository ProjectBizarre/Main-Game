"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.list = void 0;
const luau = __importStar(require("../bundle"));
const assert_1 = require("../../Shared/util/assert");
const LIST_MARKER = Symbol("List");
var list;
(function (list_1) {
    function makeNode(value) {
        return { value };
    }
    list_1.makeNode = makeNode;
    function make(...values) {
        if (values.length > 0) {
            const head = luau.list.makeNode(values[0]);
            let tail = head;
            for (let i = 1; i < values.length; i++) {
                const node = luau.list.makeNode(values[i]);
                if (tail) {
                    tail.next = node;
                    node.prev = tail;
                }
                tail = node;
            }
            return { [LIST_MARKER]: true, head, tail, readonly: false };
        }
        else {
            return { [LIST_MARKER]: true, readonly: false };
        }
    }
    list_1.make = make;
    function join(...lists) {
        const nonEmptyLists = lists.filter(list => list.head !== undefined && list.tail !== undefined);
        if (nonEmptyLists.length === 0) {
            return luau.list.make();
        }
        const newList = luau.list.make();
        newList.head = nonEmptyLists[0].head;
        newList.tail = nonEmptyLists[nonEmptyLists.length - 1].tail;
        for (let i = 1; i < nonEmptyLists.length; i++) {
            const list = nonEmptyLists[i];
            const prevList = nonEmptyLists[i - 1];
            assert_1.assert(!list.readonly);
            assert_1.assert(!prevList.readonly);
            list.readonly = true;
            list.head.prev = prevList.tail;
            prevList.tail.next = list.head;
        }
        return newList;
    }
    list_1.join = join;
    function isList(value) {
        return typeof value === "object" && value[LIST_MARKER] === true;
    }
    list_1.isList = isList;
    function clone(list) {
        const newList = luau.list.make();
        luau.list.forEach(list, element => {
            luau.list.push(newList, { ...element });
        });
        return newList;
    }
    list_1.clone = clone;
    function push(list, value) {
        assert_1.assert(!list.readonly);
        const node = luau.list.makeNode(value);
        if (list.tail) {
            list.tail.next = node;
            node.prev = list.tail;
        }
        else {
            list.head = node;
        }
        list.tail = node;
    }
    list_1.push = push;
    function pushList(list, other) {
        assert_1.assert(!list.readonly);
        assert_1.assert(!other.readonly);
        other.readonly = true;
        if (other.head && other.tail) {
            if (list.head && list.tail) {
                list.tail.next = other.head;
                other.head.prev = list.tail;
                list.tail = other.tail;
            }
            else {
                list.head = other.head;
                list.tail = other.tail;
            }
        }
    }
    list_1.pushList = pushList;
    function pop(list) {
        assert_1.assert(!list.readonly);
        if (list.tail) {
            const tail = list.tail;
            if (tail.prev) {
                list.tail = tail.prev;
                tail.prev.next = undefined;
            }
            else {
                list.head = undefined;
                list.tail = undefined;
            }
            return tail.value;
        }
    }
    list_1.pop = pop;
    function shift(list) {
        assert_1.assert(!list.readonly);
        if (list.head) {
            const head = list.head;
            if (head.next) {
                list.head = head.next;
                head.next.prev = undefined;
            }
            else {
                list.tail = undefined;
                list.head = undefined;
            }
            return head.value;
        }
    }
    list_1.shift = shift;
    function unshift(list, value) {
        assert_1.assert(!list.readonly);
        const node = luau.list.makeNode(value);
        if (list.head) {
            list.head.prev = node;
            node.next = list.head;
        }
        else {
            list.tail = node;
        }
        list.head = node;
    }
    list_1.unshift = unshift;
    function unshiftList(list, other) {
        assert_1.assert(!list.readonly);
        assert_1.assert(!other.readonly);
        other.readonly = true;
        if (other.head && other.tail) {
            if (list.head && list.tail) {
                list.head.prev = other.tail;
                other.tail.next = list.head;
                list.head = other.head;
            }
            else {
                list.head = other.head;
                list.tail = other.tail;
            }
        }
    }
    list_1.unshiftList = unshiftList;
    function isEmpty(list) {
        return list.head === undefined;
    }
    list_1.isEmpty = isEmpty;
    function isNonEmpty(list) {
        return list.head !== undefined;
    }
    list_1.isNonEmpty = isNonEmpty;
    function forEach(list, callback) {
        let node = list.head;
        while (node) {
            callback(node.value);
            node = node.next;
        }
    }
    list_1.forEach = forEach;
    function forEachListNode(list, callback) {
        let node = list.head;
        while (node) {
            callback(node);
            node = node.next;
        }
    }
    list_1.forEachListNode = forEachListNode;
    function mapToArray(list, callback) {
        const result = new Array();
        luau.list.forEach(list, value => result.push(callback(value)));
        return result;
    }
    list_1.mapToArray = mapToArray;
    function toArray(list) {
        const result = new Array();
        luau.list.forEach(list, value => result.push(value));
        return result;
    }
    list_1.toArray = toArray;
    function every(list, callback) {
        let node = list.head;
        while (node) {
            if (!callback(node.value)) {
                return false;
            }
            node = node.next;
        }
        return true;
    }
    list_1.every = every;
    function some(list, callback) {
        let node = list.head;
        while (node) {
            if (callback(node.value)) {
                return true;
            }
            node = node.next;
        }
        return false;
    }
    list_1.some = some;
    function size(list) {
        let size = 0;
        let node = list.head;
        while (node) {
            size++;
            node = node.next;
        }
        return size;
    }
    list_1.size = size;
})(list = exports.list || (exports.list = {}));
//# sourceMappingURL=List.js.map